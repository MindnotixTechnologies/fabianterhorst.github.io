<html><head><meta charset="UTF-8"><style>

  /*******************************
            Flex Layout
  *******************************/

  html /deep/ .layout.horizontal,
  html /deep/ .layout.horizontal-reverse,
  html /deep/ .layout.vertical,
  html /deep/ .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }

  html /deep/ .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }

  html /deep/ .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }

  html /deep/ .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }

  html /deep/ .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }

  html /deep/ .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }

  html /deep/ .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }

  html /deep/ .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }

  html /deep/ .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }

  html /deep/ .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }

  html /deep/ .flex,
  html /deep/ .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }

  html /deep/ .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }

  html /deep/ .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }

  html /deep/ .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }

  html /deep/ .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }

  html /deep/ .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }

  html /deep/ .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }

  html /deep/ .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }

  html /deep/ .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }

  html /deep/ .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }

  html /deep/ .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }

  html /deep/ .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }

  /* alignment in cross axis */

  html /deep/ .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }

  html /deep/ .layout.center,
  html /deep/ .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }

  html /deep/ .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }

  /* alignment in main axis */

  html /deep/ .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }

  html /deep/ .layout.center-justified,
  html /deep/ .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }

  html /deep/ .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }

  html /deep/ .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }

  html /deep/ .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }

  /* self alignment */

  html /deep/ .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }

  html /deep/ .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }

  html /deep/ .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }

  html /deep/ .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }

  /*******************************
            Other Layout
  *******************************/

  html /deep/ .block {
    display: block;
  }

  /* IE 10 support for HTML5 hidden attr */
  html /deep/ [hidden] {
    display: none !important;
  }

  html /deep/ .invisible {
    visibility: hidden !important;
  }

  html /deep/ .relative {
    position: relative;
  }

  html /deep/ .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }

  body.fullbleed {
    margin: 0;
    height: 100vh;
  }

  html /deep/ .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }

  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }

  html /deep/ .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }

  html /deep/ .fixed-right {
    top: 0;
    right: 0;
    botttom: 0;
  }

  html /deep/ .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }

  html /deep/ .fixed-left {
    top: 0;
    botttom: 0;
    left: 0;
  }

</style>
<style>

  /*******************************
            Flex Layout
  *******************************/

  .layout.horizontal,
  .layout.horizontal-reverse,
  .layout.vertical,
  .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }

  .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }

  .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }

  .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }

  .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }

  .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }

  .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }

  .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }

  .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }

  .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }

  .flex,
  .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }

  .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }

  .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }

  .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }

  .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }

  .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }

  .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }

  .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }

  .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }

  .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }

  .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }

  .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }

  /* alignment in cross axis */

  .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }

  .layout.center,
  .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }

  .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }

  /* alignment in main axis */

  .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }

  .layout.center-justified,
  .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }

  .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }

  .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }

  .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }

  /* self alignment */

  .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }

  .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }

  .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }

  .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }

  /*******************************
            Other Layout
  *******************************/

  .block {
    display: block;
  }

  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }

  .invisible {
    visibility: hidden !important;
  }

  .relative {
    position: relative;
  }

  .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }

  body.fullbleed {
    margin: 0;
    height: 100vh;
  }

  .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }

  /* fixed position */

  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }

  .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }

  .fixed-right {
    top: 0;
    right: 0;
    bottom: 0;
  }

  .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }

  .fixed-left {
    top: 0;
    bottom: 0;
    left: 0;
  }

</style>
<script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());
Polymer = {
Settings: function () {
var user = window.Polymer || {};
location.search.slice(1).split('&').forEach(function (o) {
o = o.split('=');
o[0] && (user[o[0]] = o[1] || true);
});
var wantShadow = user.dom === 'shadow';
var hasShadow = Boolean(Element.prototype.createShadowRoot);
var nativeShadow = hasShadow && !window.ShadowDOMPolyfill;
var useShadow = wantShadow && hasShadow;
var hasNativeImports = Boolean('import' in document.createElement('link'));
var useNativeImports = hasNativeImports;
var useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
return {
wantShadow: wantShadow,
hasShadow: hasShadow,
nativeShadow: nativeShadow,
useShadow: useShadow,
useNativeShadow: useShadow && nativeShadow,
useNativeImports: useNativeImports,
useNativeCustomElements: useNativeCustomElements
};
}()
};
(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
var ctor = desugar(prototype);
prototype = ctor.prototype;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
document.registerElement(prototype.is, options);
return ctor;
};
var desugar = function (prototype) {
prototype = Polymer.Base.chainObject(prototype, Polymer.Base);
prototype.registerCallback();
return prototype.constructor;
};
window.Polymer = Polymer;
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = desugar;
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};
Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript).ownerDocument;
}
});
Polymer.Base = {
_addFeature: function (feature) {
this.extend(this, feature);
},
registerCallback: function () {
this._registerFeatures();
this._doBehavior('registered');
},
createdCallback: function () {
Polymer.telemetry.instanceCount++;
this.root = this;
this._doBehavior('created');
this._initFeatures();
},
attachedCallback: function () {
this.isAttached = true;
this._doBehavior('attached');
},
detachedCallback: function () {
this.isAttached = false;
this._doBehavior('detached');
},
attributeChangedCallback: function (name) {
this._setAttributeToProperty(this, name);
this._doBehavior('attributeChanged', arguments);
},
extend: function (prototype, api) {
if (prototype && api) {
Object.getOwnPropertyNames(api).forEach(function (n) {
this.copyOwnProperty(n, api, prototype);
}, this);
}
return prototype || api;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_log: console.log.apply.bind(console.log, console),
_warn: console.warn.apply.bind(console.warn, console),
_error: console.error.apply.bind(console.error, console),
_logf: function () {
return this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
Polymer.telemetry.instanceCount = 0;
(function () {
var modules = {};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
DomModule.prototype.constructor = DomModule;
DomModule.prototype.createdCallback = function () {
var id = this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
}
};
DomModule.prototype.import = function (id, slctr) {
var m = modules[id];
if (!m) {
forceDocumentUpgrade();
m = modules[id];
}
if (m && slctr) {
m = m.querySelector(slctr);
}
return m;
};
var cePolyfill = window.CustomElements && !CustomElements.useNative;
if (cePolyfill) {
var ready = CustomElements.ready;
CustomElements.ready = true;
}
document.registerElement('dom-module', DomModule);
if (cePolyfill) {
CustomElements.ready = ready;
}
function forceDocumentUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
if (script) {
CustomElements.upgradeAll(script.ownerDocument);
}
}
}
}());
Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
}
});
Polymer.Base._addFeature({
behaviors: [],
_prepBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._flattenBehaviorsList(this.behaviors);
}
this._prepAllBehaviors(this.behaviors);
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
behaviors.forEach(function (b) {
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}, this);
return flat;
},
_prepAllBehaviors: function (behaviors) {
for (var i = behaviors.length - 1; i >= 0; i--) {
this._mixinBehavior(behaviors[i]);
}
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_mixinBehavior: function (b) {
Object.getOwnPropertyNames(b).forEach(function (n) {
switch (n) {
case 'hostAttributes':
case 'registered':
case 'properties':
case 'observers':
case 'listeners':
case 'created':
case 'attached':
case 'detached':
case 'attributeChanged':
case 'configure':
case 'ready':
break;
default:
if (!this.hasOwnProperty(n)) {
this.copyOwnProperty(n, b, this);
}
break;
}
}, this);
},
_doBehavior: function (name, args) {
this.behaviors.forEach(function (b) {
this._invokeBehavior(b, name, args);
}, this);
this._invokeBehavior(this, name, args);
},
_invokeBehavior: function (b, name, args) {
var fn = b[name];
if (fn) {
fn.apply(this, args || Polymer.nar);
}
},
_marshalBehaviors: function () {
this.behaviors.forEach(function (b) {
this._marshalBehavior(b);
}, this);
this._marshalBehavior(this);
}
});
Polymer.Base._addFeature({
_prepExtends: function () {
if (this.extends) {
this.__proto__ = this._getExtendedPrototype(this.extends);
}
},
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
var np = this.getNativePrototype(tag);
p = this.extend(Object.create(np), Polymer.Base);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});
Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
properties: {},
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
this.behaviors.some(function (b) {
return info = this._getPropertyInfo(property, b.properties);
}, this);
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
}
});
Polymer.CaseMap = {
_caseMap: {},
dashToCamelCase: function (dash) {
var mapped = Polymer.CaseMap._caseMap[dash];
if (mapped) {
return mapped;
}
if (dash.indexOf('-') < 0) {
return Polymer.CaseMap._caseMap[dash] = dash;
}
return Polymer.CaseMap._caseMap[dash] = dash.replace(/-([a-z])/g, function (m) {
return m[1].toUpperCase();
});
},
camelToDashCase: function (camel) {
var mapped = Polymer.CaseMap._caseMap[camel];
if (mapped) {
return mapped;
}
return Polymer.CaseMap._caseMap[camel] = camel.replace(/([a-z][A-Z])/g, function (g) {
return g[0] + '-' + g[1].toLowerCase();
});
}
};
Polymer.Base._addFeature({
_prepAttributes: function () {
this._aggregatedAttributes = {};
},
_addHostAttributes: function (attributes) {
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
this._applyAttributes(this, this._aggregatedAttributes);
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
this.serializeValueToAttribute(attr$[n], n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
for (var i = 0, l = this.attributes.length; i < l; i++) {
this._setAttributeToProperty(model, this.attributes[i].name);
}
},
_setAttributeToProperty: function (model, attrName) {
if (!this._serializing) {
var propName = Polymer.CaseMap.dashToCamelCase(attrName);
var info = this.getPropertyInfo(propName);
if (info.defined || this._propertyEffects && this._propertyEffects[propName]) {
var val = this.getAttribute(attrName);
model[propName] = this.deserialize(val, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (name) {
this._serializing = true;
this.serializeValueToAttribute(this[name], Polymer.CaseMap.camelToDashCase(name));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
(node || this)[str === undefined ? 'removeAttribute' : 'setAttribute'](attribute, str);
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value !== null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value;
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});
Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return debouncer && debouncer.finish;
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});
Polymer.version = '1.0.5';
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepExtends();
this._prepConstructor();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
}
});</script>

<script>Polymer.Base._addFeature({
_prepTemplate: function () {
this._template = this._template || Polymer.DomModule.import(this.is, 'template');
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});
(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_pushHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._beginHost();
},
_beginHost: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_popHost: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
this._setupRoot();
this._readyClients();
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
this._finishDistribute();
this._clientsReadied = true;
this._clients = null;
},
_readySelf: function () {
this._doBehavior('ready');
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
}
});
}());
Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (var i = 1; i < rowCount; i++) {
for (var j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
var splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();
Polymer.EventApi = function () {
var Settings = Polymer.Settings;
var EventApi = function (event) {
this.event = event;
};
if (Settings.useShadow) {
EventApi.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
return this.event.path;
}
};
} else {
EventApi.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var o = this.rootTarget;
while (o) {
path.push(o);
o = Polymer.dom(o).parentNode || o.host;
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new EventApi(event);
}
return event.__eventApi;
};
return { factory: factory };
}();
Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
c$ = composed ? node._composedChildren : c$;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();
Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
var nativeAppendChild = Element.prototype.appendChild;
var dirtyRoots = [];
var DomApi = function (node) {
this.node = node;
if (this.patch) {
this.patch();
}
};
DomApi.prototype = {
flush: function () {
for (var i = 0, host; i < dirtyRoots.length; i++) {
host = dirtyRoots[i];
host.flushDebouncer('_distribute');
}
dirtyRoots = [];
},
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
host.debounce('_distribute', host._distributeContent);
dirtyRoots.push(host);
}
},
appendChild: function (node) {
var handled;
this._removeNodeFromHost(node, true);
if (this._nodeIsInLogicalTree(this.node)) {
this._addLogicalInfo(node, this.node);
this._addNodeToHost(node);
handled = this._maybeDistribute(node, this.node);
}
if (!handled && !this._tryRemoveUndistributedNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
addToComposedParent(container, node);
nativeAppendChild.call(container, node);
}
return node;
},
insertBefore: function (node, ref_node) {
if (!ref_node) {
return this.appendChild(node);
}
var handled;
this._removeNodeFromHost(node, true);
if (this._nodeIsInLogicalTree(this.node)) {
saveLightChildrenIfNeeded(this.node);
var children = this.childNodes;
var index = children.indexOf(ref_node);
if (index < 0) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
this._addLogicalInfo(node, this.node, index);
this._addNodeToHost(node);
handled = this._maybeDistribute(node, this.node);
}
if (!handled && !this._tryRemoveUndistributedNode(node)) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
var container = this.node._isShadyRoot ? this.node.host : this.node;
addToComposedParent(container, node, ref_node);
nativeInsertBefore.call(container, node, ref_node);
}
return node;
},
removeChild: function (node) {
if (factory(node).parentNode !== this.node) {
console.warn('The node to be removed is not a child of this node', node);
}
var handled;
if (this._nodeIsInLogicalTree(this.node)) {
this._removeNodeFromHost(node);
handled = this._maybeDistribute(node, this.node);
}
if (!handled) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (container === node.parentNode) {
removeFromComposedParent(container, node);
nativeRemoveChild.call(container, node);
}
}
return node;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
if (node._ownerShadyRoot === undefined) {
var root;
if (node._isShadyRoot) {
root = node;
} else {
var parent = Polymer.dom(node).parentNode;
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
node._ownerShadyRoot = root;
}
return node._ownerShadyRoot;
},
_maybeDistribute: function (node, parent) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && Polymer.dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && Polymer.dom(fragContent).parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this._ownerShadyRootForNode(parent);
if (root) {
var host = root.host;
this._updateInsertionPoints(host);
this._lazyDistribute(host);
}
}
var parentNeedsDist = this._parentNeedsDistribution(parent);
if (parentNeedsDist) {
this._lazyDistribute(parent);
}
return parentNeedsDist || hasContent && !wrappedContent;
},
_tryRemoveUndistributedNode: function (node) {
if (this.node.shadyRoot) {
if (node.parentNode) {
nativeRemoveChild.call(node.parentNode, node);
}
return true;
}
},
_updateInsertionPoints: function (host) {
host.shadyRoot._insertionPoints = factory(host.shadyRoot).querySelectorAll(CONTENT);
},
_nodeIsInLogicalTree: function (node) {
return Boolean(node._lightParent || node._isShadyRoot || this._ownerShadyRootForNode(node) || node.shadyRoot);
},
_parentNeedsDistribution: function (parent) {
return parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot);
},
_removeNodeFromHost: function (node, ensureComposedRemoval) {
var hostNeedsDist;
var root;
var parent = node._lightParent;
if (parent) {
root = this._ownerShadyRootForNode(node);
if (root) {
root.host._elementRemove(node);
hostNeedsDist = this._removeDistributedChildren(root, node);
}
this._removeLogicalInfo(node, node._lightParent);
}
this._removeOwnerShadyRoot(node);
if (root && hostNeedsDist) {
this._updateInsertionPoints(root.host);
this._lazyDistribute(root.host);
} else if (ensureComposedRemoval) {
removeFromComposedParent(parent || node.parentNode, node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = factory(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = node.parentNode;
if (parent) {
removeFromComposedParent(parent, node);
nativeRemoveChild.call(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = factory(node).parentNode;
}
},
_addNodeToHost: function (node) {
var checkNode = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? node.firstChild : node;
var root = this._ownerShadyRootForNode(checkNode);
if (root) {
root.host._elementAdd(node);
}
},
_addLogicalInfo: function (node, container, index) {
saveLightChildrenIfNeeded(container);
var children = factory(container).childNodes;
index = index === undefined ? children.length : index;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
children.splice(index++, 0, n);
n._lightParent = container;
}
} else {
children.splice(index, 0, node);
node._lightParent = container;
}
},
_removeLogicalInfo: function (node, container) {
var children = factory(container).childNodes;
var index = children.indexOf(node);
if (index < 0 || container !== node._lightParent) {
throw Error('The node to be removed is not a child of this node');
}
children.splice(index, 1);
node._lightParent = null;
},
_removeOwnerShadyRoot: function (node) {
var hasCachedRoot = factory(node).getOwnerRoot() !== undefined;
if (hasCachedRoot) {
var c$ = factory(node).childNodes;
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = factory(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = factory(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
return this.querySelectorAll(selector)[0];
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return matchesSelector.call(n, selector);
}, this.node);
},
_query: function (matcher, node) {
node = node || this.node;
var list = [];
this._queryElements(factory(node).childNodes, matcher, list);
return list;
},
_queryElements: function (elements, matcher, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
this._queryElement(c, matcher, list);
}
}
},
_queryElement: function (node, matcher, list) {
if (matcher(node)) {
list.push(node);
}
this._queryElements(factory(node).childNodes, matcher, list);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
queryDistributedElements: function (selector) {
var c$ = this.childNodes;
var list = [];
this._distributedFilter(selector, c$, list);
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
this._distributedFilter(selector, factory(c).getDistributedNodes(), list);
}
}
return list;
},
_distributedFilter: function (selector, list, results) {
results = results || [];
for (var i = 0, l = list.length, d; i < l && (d = list[i]); i++) {
if (d.nodeType === Node.ELEMENT_NODE && d.localName !== CONTENT && matchesSelector.call(d, selector)) {
results.push(d);
}
}
return results;
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._distributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._distributeParent();
},
_distributeParent: function () {
if (this._parentNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
}
}
};
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
if (!Settings.useShadow) {
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
var c$ = getLightChildren(this.node);
return Array.isArray(c$) ? c$ : Array.prototype.slice.call(c$);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
configurable: true
},
parentNode: {
get: function () {
return this.node._lightParent || (this.node.__patched ? this.node._composedParent : this.node.parentNode);
},
configurable: true
},
firstChild: {
get: function () {
return this.childNodes[0];
},
configurable: true
},
lastChild: {
get: function () {
var c$ = this.childNodes;
return c$[c$.length - 1];
},
configurable: true
},
nextSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
firstElementChild: {
get: function () {
return this.children[0];
},
configurable: true
},
lastElementChild: {
get: function () {
var c$ = this.children;
return c$[c$.length - 1];
},
configurable: true
},
nextElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
textContent: {
get: function () {
if (this.node.nodeType === Node.TEXT_NODE) {
return this.node.textContent;
} else {
return Array.prototype.map.call(this.childNodes, function (c) {
return c.textContent;
}).join('');
}
},
set: function (text) {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
},
configurable: true
},
innerHTML: {
get: function () {
if (this.node.nodeType === Node.TEXT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
if (this.node.nodeType !== Node.TEXT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
for (var e = d.firstChild; e; e = e.nextSibling) {
this.appendChild(e);
}
}
},
configurable: true
}
});
DomApi.prototype._getComposedInnerHTML = function () {
return getInnerHTML(this.node, true);
};
} else {
DomApi.prototype.querySelectorAll = function (selector) {
return Array.prototype.slice.call(this.node.querySelectorAll(selector));
};
DomApi.prototype.getOwnerRoot = function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
};
DomApi.prototype.getDestinationInsertionPoints = function () {
var n$ = this.node.getDestinationInsertionPoints();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype.getDistributedNodes = function () {
var n$ = this.node.getDistributedNodes();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype._distributeParent = function () {
};
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
return Array.prototype.slice.call(this.node.childNodes);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.slice.call(this.node.children);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwards = [
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
];
forwards.forEach(function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
});
}
var CONTENT = 'content';
var factory = function (node, patch) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi(node, patch);
}
return node.__domApi;
};
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return factory(obj, patch);
}
};
Polymer.dom.flush = DomApi.prototype.flush;
function getLightChildren(node) {
var children = node._lightChildren;
return children ? children : node.childNodes;
}
function getComposedChildren(node) {
if (!node._composedChildren) {
node._composedChildren = Array.prototype.slice.call(node.childNodes);
}
return node._composedChildren;
}
function addToComposedParent(parent, node, ref_node) {
var children = getComposedChildren(parent);
var i = ref_node ? children.indexOf(ref_node) : -1;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var fragChildren = getComposedChildren(node);
for (var j = 0; j < fragChildren.length; j++) {
addNodeToComposedChildren(fragChildren[j], parent, children, i + j);
}
node._composedChildren = null;
} else {
addNodeToComposedChildren(node, parent, children, i);
}
}
function addNodeToComposedChildren(node, parent, children, i) {
node._composedParent = parent;
children.splice(i >= 0 ? i : children.length, 0, node);
}
function removeFromComposedParent(parent, node) {
node._composedParent = null;
if (parent) {
var children = getComposedChildren(parent);
var i = children.indexOf(node);
if (i >= 0) {
children.splice(i, 1);
}
}
}
function saveLightChildrenIfNeeded(node) {
if (!node._lightChildren) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
child._lightParent = child._lightParent || node;
}
node._lightChildren = c$;
}
}
function hasInsertionPoint(root) {
return Boolean(root._insertionPoints.length);
}
var p = Element.prototype;
var matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return {
getLightChildren: getLightChildren,
getComposedChildren: getComposedChildren,
removeFromComposedParent: removeFromComposedParent,
saveLightChildrenIfNeeded: saveLightChildrenIfNeeded,
matchesSelector: matchesSelector,
hasInsertionPoint: hasInsertionPoint,
ctor: DomApi,
factory: factory
};
}();
(function () {
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_poolContent: function () {
if (this._useContent) {
saveLightChildrenIfNeeded(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLightChildren(this._lightChildren);
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
saveLightChildrenIfNeeded(this.shadyRoot);
this.shadyRoot.host = this;
},
get domHost() {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
var dom = Polymer.dom(this);
if (updateInsertionPoints) {
dom._updateInsertionPoints(this);
}
var host = getTopDistributingHost(this);
dom._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
if (hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
} else {
if (!this.shadyRoot._hasDistributed) {
this.textContent = '';
this._composedChildren = null;
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
this.shadyRoot._hasDistributed = true;
this.shadyRoot._distributionClean = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = getLightChildren(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = p._lightParent || p.parentNode;
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = getLightChildren(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = getComposedChildren(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
remove(n);
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (var j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;
var getLightChildren = Polymer.DomApi.getLightChildren;
var matchesSelector = Polymer.DomApi.matchesSelector;
var hasInsertionPoint = Polymer.DomApi.hasInsertionPoint;
var getComposedChildren = Polymer.DomApi.getComposedChildren;
var removeFromComposedParent = Polymer.DomApi.removeFromComposedParent;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = content._lightParent;
if (parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
function insertBefore(parentNode, newChild, refChild) {
var newChildParent = getComposedParent(newChild);
if (newChildParent !== parentNode) {
removeFromComposedParent(newChildParent, newChild);
}
remove(newChild);
saveLightChildrenIfNeeded(parentNode);
nativeInsertBefore.call(parentNode, newChild, refChild || null);
newChild._composedParent = parentNode;
}
function remove(node) {
var parentNode = getComposedParent(node);
if (parentNode) {
saveLightChildrenIfNeeded(parentNode);
node._composedParent = null;
nativeRemoveChild.call(parentNode, node);
}
}
function getComposedParent(node) {
return node.__patched ? node._composedParent : node.parentNode;
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = Polymer.dom(host).children;
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName === 'content') {
return host.domHost;
}
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLightChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());
if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}
Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepExtends();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script>

<script>Polymer.nar = [];
Polymer.Annotations = {
parseAnnotations: function (template) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list);
return list;
},
_parseNodeAnnotations: function (node, list) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list);
},
_testEscape: function (value) {
var escape = value.slice(0, 2);
if (escape === '{{' || escape === '[[') {
return escape;
}
},
_parseTextNodeAnnotation: function (node, list) {
var v = node.textContent;
var escape = this._testEscape(v);
if (escape) {
node.textContent = ' ';
var annote = {
bindings: [{
kind: 'text',
mode: escape[0],
value: v.slice(2, -2).trim()
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, callback) {
if (root.firstChild) {
for (var i = 0, node = root.firstChild; node; node = node.nextSibling, i++) {
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote);
}
var childAnnotation = this._parseNodeAnnotations(node, list, callback);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
}
},
_parseTemplate: function (node, index, list, parent) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
for (var i = node.attributes.length - 1, a; a = node.attributes[i]; i--) {
var n = a.name, v = a.value;
if (n === 'id' && !this._testEscape(v)) {
annotation.id = v;
} else if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else {
var b = this._parseNodeAttributeAnnotation(node, n, v);
if (b) {
annotation.bindings.push(b);
}
}
}
},
_parseNodeAttributeAnnotation: function (node, n, v) {
var escape = this._testEscape(v);
if (escape) {
var customEvent;
var name = n;
var mode = escape[0];
v = v.slice(2, -2).trim();
var not = false;
if (v[0] == '!') {
v = v.substring(1);
not = true;
}
var kind = 'property';
if (n[n.length - 1] == '$') {
name = n.slice(0, -1);
kind = 'attribute';
}
var notifyEvent, colon;
if (mode == '{' && (colon = v.indexOf('::')) > 0) {
notifyEvent = v.substring(colon + 2);
v = v.substring(0, colon);
customEvent = true;
}
if (node.localName == 'input' && n == 'value') {
node.setAttribute(n, '');
}
node.removeAttribute(n);
if (kind === 'property') {
name = Polymer.CaseMap.dashToCamelCase(name);
}
return {
kind: kind,
mode: mode,
name: name,
value: v,
negate: not,
event: notifyEvent,
customEvent: customEvent
};
}
},
_localSubTree: function (node, host) {
return node === host ? node.childNodes : node._lightChildren || node.childNodes;
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
return !parent ? root : Polymer.Annotations._localSubTree(parent, root)[annote.index];
}
};
(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && url[0] === '#') {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl
};
}());
Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
Polymer.Annotations.prepElement = this._prepElement.bind(this);
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
b.signature = this._parseMethod(b.value);
if (!b.signature) {
b.model = this._modelForPath(b.value);
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
bindings.push({
index: note.index,
kind: 'property',
mode: '{',
name: '_parent_' + prop,
model: prop,
value: prop
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
notes.forEach(function (n) {
n.bindings.forEach(function (b) {
if (b.signature) {
var args = b.signature.args;
for (var k = 0; k < args.length; k++) {
pp[args[k].model] = true;
}
} else {
pp[b.model] = true;
}
});
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
});
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
this._configureTemplateContent();
},
_configureTemplateContent: function () {
this._notes.forEach(function (note, i) {
if (note.templateContent) {
this._nodes[i]._content = note.templateContent;
}
}, this);
},
_marshalIdNodes: function () {
this.$ = {};
this._notes.forEach(function (a) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}, this);
},
_marshalAnnotatedNodes: function () {
if (this._nodes) {
this._nodes = this._nodes.map(function (a) {
return this._findAnnotatedNode(this.root, a);
}, this);
}
},
_marshalAnnotatedListeners: function () {
this._notes.forEach(function (a) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
a.events.forEach(function (e) {
this.listen(node, e.name, e.value);
}, this);
}
}, this);
}
});
Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, key;
for (key in listeners) {
if (key.indexOf('.') < 0) {
node = this;
name = key;
} else {
name = key.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[key]);
}
},
listen: function (node, eventName, methodName) {
this._listen(node, eventName, this._createEventHandler(node, eventName, methodName));
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
hbl.set(target, bl);
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});
(function () {
'use strict';
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var mouseCanceller = function (mouseEvent) {
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
en = MOUSE_EVENTS[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse() {
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = ev.currentTarget;
var gobj = node[GESTURE_KEY];
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
if (type === 'touchend') {
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
ignoreMouse(true);
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
}
}
},
add: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = {};
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
if (gd[name] === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var se = detail.sourceEvent;
if (se && se.preventDefault) {
se.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
emits: [
'down',
'up'
],
mousedown: function (e) {
var t = e.currentTarget;
var self = this;
var upfn = function upfn(e) {
self.fire('up', t, e);
document.removeEventListener('mouseup', upfn);
};
document.addEventListener('mouseup', upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', e.currentTarget, e.changedTouches[0]);
},
touchend: function (e) {
this.fire('up', e.currentTarget, e.changedTouches[0]);
},
fire: function (type, target, event) {
var self = this;
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
prevent: Gestures.prevent.bind(Gestures)
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
prevent: false
},
clearInfo: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
var t = e.currentTarget;
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
self.info.addMove({
x: x,
y: y
});
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
Gestures.prevent('tap');
movefn(e);
}
self.clearInfo();
document.removeEventListener('mousemove', movefn);
document.removeEventListener('mouseup', upfn);
};
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = e.currentTarget;
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = e.currentTarget;
var ct = e.changedTouches[0];
if (this.info.started) {
Gestures.prevent('tap');
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct);
}
this.clearInfo();
},
fire: function (target, touch) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
this.save(e);
},
click: function (e) {
this.forward(e);
},
touchstart: function (e) {
this.save(e.changedTouches[0]);
},
touchend: function (e) {
this.forward(e.changedTouches[0]);
},
forward: function (e) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) {
if (!this.info.prevent) {
Gestures.fire(e.target, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e
});
}
}
this.reset();
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());
Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new (window.MutationObserver || JsMutationObserver)(Polymer.Async._atEndOfMicrotask.bind(Polymer.Async)).observe(Polymer.Async._twiddle, { characterData: true });
Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
this.boundComplete = this.complete.bind(this);
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
}
},
complete: function () {
if (this.finish) {
this.stop();
this.callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getContentChildNodes: function (slctr) {
return Polymer.dom(Polymer.dom(this.root).querySelector(slctr || 'content')).getDistributedNodes();
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
var detail = detail === null || detail === undefined ? Polymer.nob : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var event = new CustomEvent(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable,
detail: detail
});
node.dispatchEvent(event);
return event;
},
async: function (callback, waitTime) {
return Polymer.Async.run(callback.bind(this), waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this.get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror) {
var l = document.createElement('link');
l.rel = 'import';
l.href = href;
if (onload) {
l.onload = onload.bind(this);
}
if (onerror) {
l.onerror = onerror.bind(this);
}
document.head.appendChild(l);
return l;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
}
});
Polymer.Bind = {
prepareModel: function (model) {
model._propertyEffects = {};
model._bindListeners = [];
var api = this._modelApi;
for (var n in api) {
model[n] = api[n];
}
},
_modelApi: {
_notifyChange: function (property) {
var eventName = Polymer.CaseMap.camelToDashCase(property) + '-changed';
this.fire(eventName, { value: this[property] }, { bubbles: false });
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
effects.forEach(function (fx) {
var fn = Polymer.Bind['_' + fx.kind + 'Effect'];
if (fn) {
fn.call(this, property, value, fx.effect, old, fromAbove);
}
}, this);
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (prop.indexOf(path + '.') === 0) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
fx.push({
kind: kind,
effect: effect
});
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'computedAnnotation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
if (model.getPropertyInfo && model.getPropertyInfo(property).readOnly) {
model['_set' + this.upper(property)] = setter;
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event) {
var fn = this._notedListenerFactory(property, path, this._isStructured(path), this._isEventBogus);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isStructured: function (path) {
return path.indexOf('.') > 0;
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, bogusTest) {
return function (e, target) {
if (!bogusTest(e, target)) {
if (e.detail && e.detail.path) {
this.notifyPath(this._fixPath(path, property, e.detail.path), e.detail.value);
} else {
var value = target[property];
if (!isStructured) {
this[path] = target[property];
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
inst._bindListeners.forEach(function (info) {
var node = inst._nodes[info.index];
node.addEventListener(info.event, inst._notifyListener.bind(inst, info.changedFn));
});
}
};
Polymer.Base.extend(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.mode === '{' && !effect.negate && effect.kind != 'attribute';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this.get(effect.value);
this.__data__[effect.value] = value;
}
var calc = effect.negate ? !value : value;
if (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {
return this._applyEffectValue(calc, effect);
}
},
_reflectEffect: function (source) {
this.reflectPropertyToAttribute(source);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var fn = this[effect.method];
if (fn) {
this.__setProperty(effect.property, fn.apply(this, args));
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
if (effect.negate) {
computedvalue = !computedvalue;
}
this._applyEffectValue(computedvalue, effect);
}
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (arg.structured) {
v = Polymer.Base.get(name, model);
} else {
v = model[name];
}
if (args.length > 1 && v === undefined) {
return;
}
if (arg.wildcard) {
var baseChanged = name.indexOf(path + '.') === 0;
var matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});
Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
Polymer.Bind.addPropertyEffect(this, property, kind, effect);
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify');
}
if (prop.reflectToAttribute) {
this._addPropertyEffect(p, 'reflect');
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
property: name
});
}, this);
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
observers.forEach(function (observer) {
this._addComplexObserverEffect(observer);
}, this);
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg
});
}, this);
},
_addAnnotationEffects: function (notes) {
this._nodes = [];
notes.forEach(function (note) {
var index = this._nodes.push(note) - 1;
note.bindings.forEach(function (binding) {
this._addAnnotationEffect(binding, index);
}, this);
}, this);
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.value, note.event);
}
if (note.signature) {
this._addAnnotatedComputationEffect(note, index);
} else {
note.index = index;
this._addPropertyEffect(note.model, 'annotation', note);
}
},
_addAnnotatedComputationEffect: function (note, index) {
var sig = note.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, sig, null);
} else {
sig.args.forEach(function (arg) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, sig, arg);
}
}, this);
}
},
__addAnnotatedComputationEffect: function (property, index, note, sig, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
kind: note.kind,
property: note.name,
negate: note.negate,
method: sig.method,
args: sig.args,
trigger: trigger
});
},
_parseMethod: function (expression) {
var m = expression.match(/(\w*)\((.*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = {
name: arg,
model: this._modelForPath(arg)
};
var fc = arg[0];
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.structured = arg.indexOf('.') > 0;
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
Polymer.Bind.setupBindListeners(this);
},
_applyEffectValue: function (value, info) {
var node = this._nodes[info.index];
var property = info.property || info.name || 'textContent';
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
return node[property] = value;
}
},
_executeStaticEffects: function () {
if (this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = initialConfig || {};
this._handlers = [];
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_configValue: function (name, value) {
this._config[name] = value;
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
this.behaviors.forEach(function (b) {
this._configureProperties(b.properties, config);
}, this);
this._configureProperties(this.properties, config);
this._mixinConfigure(config, this._aboveConfig);
this._config = config;
this._distributeConfig(this._config);
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_mixinConfigure: function (a, b) {
for (var prop in b) {
if (!this.getPropertyInfo(prop).readOnly) {
a[prop] = b[prop];
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
if (node._configValue) {
var value = p === x.effect.value ? config[p] : this.get(x.effect.value, config);
node._configValue(x.effect.name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!this._clientsReadied) {
this._queueHandler([
fn,
e,
e.target
]);
} else {
return fn.call(this, e, e.target);
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2]);
}
}
});
(function () {
'use strict';
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPath(path, value);
}
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
prop = prop[parts[i]];
if (array) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old = prop[last];
var key = coll.getKey(old);
if (key) {
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this.notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var last = parts.pop();
while (parts.length) {
prop = prop[parts.shift()];
if (!prop) {
return;
}
}
return prop[last];
},
_pathEffector: function (path, value) {
var model = this._modelForPath(path);
var fx$ = this._propertyEffects[model];
if (fx$) {
fx$.forEach(function (fx) {
var fxFn = this['_' + fx.kind + 'PathEffect'];
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}, this);
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (effect.value === path || effect.value.indexOf(path + '.') === 0) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {
var node = this._nodes[effect.index];
if (node && node.notifyPath) {
var p = this._fixPath(effect.name, effect.value, path);
node.notifyPath(p, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
_pathMatchesEffect: function (path, effect) {
var effectArg = effect.trigger.name;
return effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unbindPath(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
var from, to;
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (path.indexOf(a + '.') == 0) {
from = a;
to = b;
break;
}
if (path.indexOf(b + '.') == 0) {
from = b;
to = a;
break;
}
}
if (from && to) {
var p = this._fixPath(to, from, path);
this.notifyPath(p, value);
}
},
_fixPath: function (property, root, path) {
return property + path.slice(root.length);
},
_notifyPath: function (path, value) {
var rootName = this._modelForPath(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, { bubbles: false });
},
_modelForPath: function (path) {
var dot = path.indexOf('.');
return dot < 0 ? path : path.slice(0, dot);
},
_EVENT_CHANGED: '-changed',
_notifySplice: function (array, path, index, added, removed) {
var splices = [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}];
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
this.set(path + '.splices', change);
if (added != removed.length) {
this.notifyPath(path + '.length', array.length);
}
change.keySplices = null;
change.indexSplices = null;
},
push: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
this._notifySplice(array, path, len, args.length, []);
return ret;
},
pop: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var rem = array.slice(-1);
var ret = array.pop.apply(array, args);
this._notifySplice(array, path, array.length, 0, rem);
return ret;
},
splice: function (path, start, deleteCount) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
this._notifySplice(array, path, start, args.length - 2, ret);
return ret;
},
shift: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
this._notifySplice(array, path, 0, 0, [ret]);
return ret;
},
unshift: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
this._notifySplice(array, path, 0, args.length, []);
return ret;
}
});
}());
Polymer.Base._addFeature({
resolveUrl: function (url) {
var module = Polymer.DomModule.import(this.is);
var root = '';
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
}
return Polymer.ResolveUrl.resolveUrl(url, root);
}
});
Polymer.CssParse = function () {
var api = {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(rx.comments, '').replace(rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, s = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(AT_START) === 0;
if (node.atRule) {
if (s.indexOf(MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
}
} else {
if (s.indexOf(VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && (preserveProperties || !hasMixinRules(r$))) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}'
};
function hasMixinRules(rules) {
return rules[0].selector.indexOf(VAR_START) >= 0;
}
function removeCustomProps(cssText) {
return cssText.replace(rx.customProp, '').replace(rx.mixinProp, '').replace(rx.mixinApply, '').replace(rx.varApply, '');
}
var VAR_START = '--';
var MEDIA_START = '@media';
var AT_START = '@';
var rx = {
comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^|[\s;])--[^;{]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^|[\s;])--[^;{]*?:[^{;]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply[\s]*\([^)]*?\)[\s]*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*var[^;]*(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/
};
return api;
}();
Polymer.StyleUtil = function () {
return {
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css]',
toCssText: function (rules, callback, preserveProperties) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachStyleRule(rules, callback);
}
return this.parser.stringify(rules, preserveProperties);
},
forRulesInStyles: function (styles, callback) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachStyleRule(this.rulesForStyle(s), callback);
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
clearStyleRules: function (style) {
style.__cssRules = null;
},
forEachStyleRule: function (node, callback) {
var s = node.selector;
var skipRules = false;
if (node.type === this.ruleTypes.STYLE_RULE) {
callback(node);
} else if (node.type === this.ruleTypes.KEYFRAMES_RULE || node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachStyleRule(r, callback);
}
}
},
applyCss: function (cssText, moniker, target, afterNode) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
target = target || document.head;
if (!afterNode) {
var n$ = target.querySelectorAll('style[scope]');
afterNode = n$[n$.length - 1];
}
target.insertBefore(style, afterNode && afterNode.nextSibling || target.firstChild);
return style;
},
cssFromModule: function (moduleId) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
var cssText = '';
var e$ = Array.prototype.slice.call(m.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'style') {
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
} else {
e = e.import && e.import.body;
}
if (e) {
cssText += Polymer.ResolveUrl.resolveCss(e.textContent, e.ownerDocument);
}
}
m._cssText = cssText;
}
return m && m._cssText || '';
},
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();
Polymer.StyleTransformer = function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, c + (c ? ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
for (var i = 0, l = styles.length, s, text; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
rule.selector = p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
selector = selector.replace(HOST, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!nativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
if (rule.selector === ROOT) {
rule.selector = 'body';
}
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)([^\s>+~]+)/g;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(\:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?:\:host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /\:\:content|\:\:shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
return api;
}();
Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachStyleRule(rules, function (rule) {
var map = self._mapRule(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRule: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || (target.extends = []);
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();
(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle) {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow && Boolean(this._template);
}
this._styles = this._collectStyles();
var cssText = styleTransformer.elementStyles(this);
if (cssText && this._template) {
var style = styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null);
if (!nativeShadow) {
this._scopeStyle = style;
}
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
node.className = self._scopeElementClass(node, node.className);
var n$ = node.querySelectorAll('*');
Array.prototype.forEach.call(n$, function (n) {
n.className = self._scopeElementClass(n, n.className);
});
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
mxns.forEach(function (m) {
if (m.addedNodes) {
for (var i = 0; i < m.addedNodes.length; i++) {
scopify(m.addedNodes[i]);
}
}
});
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());
Polymer.StyleProperties = function () {
'use strict';
var nativeShadow = Polymer.Settings.useNativeShadow;
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
return {
decorateStyles: function (styles) {
var self = this, props = {};
styleUtil.forRulesInStyles(styles, function (rule) {
self.decorateRule(rule);
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
});
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var any;
while (m = rx.exec(cssText)) {
properties[m[1]] = (m[2] || m[3]).trim();
any = true;
}
return any;
}
},
collectCssText: function (rule) {
var customCssText = '';
var cssText = rule.parsedCssText;
cssText = cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
var parts = cssText.split(';');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
if (p.match(this.rx.MIXIN_MATCH) || p.match(this.rx.VAR_MATCH)) {
customCssText += p + ';\n';
}
}
return customCssText;
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CAPTURE.exec(cssText)) {
props[m[1]] = true;
var def = m[2];
if (def && def.match(this.rx.IS_VAR)) {
props[def] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (all, prefix, value, fallback) {
var propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);
return prefix + (propertyValue || '');
};
property = property.replace(this.rx.VAR_MATCH, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length && (p = parts[i]); i++) {
m = p.match(this.rx.MIXIN_MATCH);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var pp = p.split(':');
if (pp[1]) {
pp[1] = pp[1].trim();
pp[1] = this.valueForProperty(pp[1], props) || pp[1];
}
p = pp.join(':');
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [], i = 0;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.selector)) {
self.collectProperties(rule, props);
addToBitMask(i, o);
}
i++;
});
return {
properties: props,
key: o
};
},
scopePropertiesFromStyles: function (styles) {
if (!styles._scopeStyleProperties) {
styles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);
}
return styles._scopeStyleProperties;
},
hostPropertiesFromStyles: function (styles) {
if (!styles._hostStyleProperties) {
styles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);
}
return styles._hostStyleProperties;
},
selectedPropertiesFromStyles: function (styles, selectors) {
var props = {}, self = this;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
for (var i = 0; i < selectors.length; i++) {
if (rule.parsedSelector === selectors[i]) {
self.collectProperties(rule, props);
return;
}
}
});
return props;
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (rule.cssText && !nativeShadow) {
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, hostSelector + scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.className;
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.className = v;
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !nativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (nativeShadow || (!style || !style.parentNode)) {
if (nativeShadow && element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
rx: {
VAR_ASSIGN: /(?:^|[;\n]\s*)(--[\w-]*?):\s*?(?:([^;{]*?)|{([^}]*)})(?:(?=[;\n])|$)/gim,
MIXIN_MATCH: /(?:^|\W+)@apply[\s]*\(([^)]*)\)/im,
VAR_MATCH: /(^|\W+)var\([\s]*([^,)]*)[\s]*,?[\s]*((?:[^,)]*)|(?:[^;]*\([^;)]*\)))[\s]*?\)/gim,
VAR_CAPTURE: /\([\s]*(--[^,\s)]*)(?:,[\s]*(--[^,\s)]*))?(?:\)|,)/gim,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
HOST_SELECTORS: [':host'],
SCOPE_SELECTORS: [':root'],
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();
(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());
Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var StyleCache = Polymer.StyleCache;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.scopePropertiesFromStyles(this._styles);
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
}
};
return api;
}();
(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleUtil = Polymer.StyleUtil;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
this._ownStylePropertyNames = this._styles ? propertyUtils.decorateStyles(this._styles) : [];
},
_setupStyleProperties: function () {
this.customStyle = {};
},
_needsStyleProperties: function () {
return Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_beforeAttached: function () {
if (!this._scopeSelector && this._needsStyleProperties()) {
this._updateStyleProperties();
}
},
_updateStyleProperties: function () {
var info, scope = this.domHost || styleDefaults;
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this.domHost || styleDefaults;
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
this.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class') {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = Polymer.dom(node);
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector += (selector ? ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (this.isAttached) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepExtends();
this._prepConstructor();
this._prepTemplate();
this._prepStyles();
this._prepStyleProperties();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._setupConfigure();
this._setupStyleProperties();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalAnnotationReferences();
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
this._listenListeners(b.listeners);
}
});
(function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
Polymer({
is: 'custom-style',
extends: 'style',
created: function () {
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement || this;
styleDefaults.addStyle(e);
if (e.textContent) {
this._apply();
} else {
var observer = new MutationObserver(function () {
observer.disconnect();
this._apply();
}.bind(this));
observer.observe(e, { childList: true });
}
}
}
},
_apply: function () {
var e = this.__appliedElement || this;
this._computeStyleProperties();
var props = this._styleProperties;
var self = this;
e.textContent = styleUtil.toCssText(styleUtil.rulesForStyle(e), function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = css.replace(propertyUtils.rx.VAR_ASSIGN, '');
rule.cssText = propertyUtils.valueForProperties(css, props);
}
styleTransformer.documentRule(rule);
});
}
});
}());
Polymer.Templatizer = {
properties: { _hideTemplateChildren: { observer: '_showHideChildren' } },
_templatizerStatic: {
count: 0,
callbacks: {},
debouncer: null
},
_instanceProps: Polymer.nob,
created: function () {
this._templatizerId = this._templatizerStatic.count++;
},
templatize: function (template) {
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepBindings();
this._prepParentProperties(archetype, template);
archetype._notifyPath = this._notifyPathImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildren: function (hidden) {
},
_debounceTemplate: function (fn) {
this._templatizerStatic.callbacks[this._templatizerId] = fn.bind(this);
this._templatizerStatic.debouncer = Polymer.Debounce(this._templatizerStatic.debouncer, this._flushTemplates.bind(this, true));
},
_flushTemplates: function (debouncerExpired) {
var db = this._templatizerStatic.debouncer;
while (debouncerExpired || db && db.finish) {
db.stop();
var cbs = this._templatizerStatic.callbacks;
this._templatizerStatic.callbacks = {};
for (var id in cbs) {
cbs[id]();
}
debouncerExpired = false;
}
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (var prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = rootDataHost._prepElement.bind(rootDataHost);
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
}
for (prop in parentProps) {
var parentProp = '_parent_' + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop)
},
{ kind: 'notify' }
];
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = this._forwardParentProp.bind(this);
}
this._extendTemplate(template, proto);
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
return function (source, value) {
this.dataHost['_parent_' + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
Object.getOwnPropertyNames(proto).forEach(function (n) {
var val = template[n];
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
});
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathImpl: function (path, value) {
var dataHost = this.dataHost;
var dot = path.indexOf('.');
var root = dot < 0 ? path : path.slice(0, dot);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost.notifyPath('_parent_' + path, value);
}
},
_pathEffector: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf('_parent_') === 0) {
this._forwardParentPath(path.substring(8), value);
}
}
Polymer.Base._pathEffector.apply(this, arguments);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._pushHost(host);
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._popHost();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
for (var prop in this._parentProps) {
model[prop] = this['_parent_' + prop];
}
}
return new this.ctor(model, this);
}
};
Polymer({
is: 'dom-template',
extends: 'template',
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});
Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return key;
},
removeKey: function (key) {
this._removeFromMap(this.store[key]);
delete this.store[key];
},
_removeFromMap: function (item) {
if (typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
if (typeof item == 'object') {
return this.omap.get(item);
} else {
return this.pmap[item];
}
},
getKeys: function () {
return Object.keys(this.store);
},
setItem: function (key, item) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
},
getItem: function (key) {
return this.store[key];
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keySplices = [];
for (var i = 0; i < splices.length; i++) {
var j, o, key, s = splices[i];
var removed = [];
for (j = 0; j < s.removed.length; j++) {
o = s.removed[j];
key = this.remove(o);
removed.push(key);
}
var added = [];
for (j = 0; j < s.addedCount; j++) {
o = this.userArray[s.index + j];
key = this.add(o);
added.push(key);
}
keySplices.push({
index: s.index,
removed: removed,
removedItems: s.removed,
added: added
});
}
return keySplices;
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};
Polymer({
is: 'dom-repeat',
extends: 'template',
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
detached: function () {
if (this.rows) {
for (var i = 0; i < this.rows.length; i++) {
this._detachRow(i);
}
}
},
attached: function () {
if (this.rows) {
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < this.rows.length; i++) {
Polymer.dom(parentNode).insertBefore(this.rows[i].root, this);
}
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function () {
var dataHost = this._getRootDataHost();
var sort = this.sort;
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._fullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function () {
var dataHost = this._getRootDataHost();
var filter = this.filter;
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._fullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._splices = [];
this._fullRefresh = true;
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._splices = this._splices.concat(change.value.keySplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._fullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._fullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
var c = this.collection;
if (!this._fullRefresh) {
if (this._sortFn) {
this._applySplicesViewSort(this._splices);
} else {
if (this._filterFn) {
this._fullRefresh = true;
} else {
this._applySplicesArraySort(this._splices);
}
}
}
if (this._fullRefresh) {
this._sortAndFilter();
this._fullRefresh = false;
}
this._splices = [];
var rowForKey = this._rowForKey = {};
var keys = this._orderedKeys;
this.rows = this.rows || [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var item = c.getItem(key);
var row = this.rows[i];
rowForKey[key] = i;
if (!row) {
this.rows.push(row = this._insertRow(i, null, item));
}
row.__setProperty(this.as, item, true);
row.__setProperty('__key__', key, true);
row.__setProperty(this.indexAs, i, true);
}
for (; i < this.rows.length; i++) {
this._detachRow(i);
}
this.rows.splice(keys.length, this.rows.length - keys.length);
this.fire('dom-change');
},
_sortAndFilter: function () {
var c = this.collection;
if (!this._sortFn) {
this._orderedKeys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
this._orderedKeys.push(c.getKey(items[i]));
}
}
} else {
this._orderedKeys = c ? c.getKeys() : [];
}
if (this._filterFn) {
this._orderedKeys = this._orderedKeys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
if (this._sortFn) {
this._orderedKeys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
}
},
_keySort: function (a, b) {
return this.collection.getKey(a) - this.collection.getKey(b);
},
_applySplicesViewSort: function (splices) {
var c = this.collection;
var keys = this._orderedKeys;
var rows = this.rows;
var removedRows = [];
var addedKeys = [];
var pool = [];
var sortFn = this._sortFn || this._keySort.bind(this);
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
var idx = this._rowForKey[s.removed[i]];
if (idx != null) {
removedRows.push(idx);
}
}
for (var i = 0; i < s.added.length; i++) {
addedKeys.push(s.added[i]);
}
}, this);
if (removedRows.length) {
removedRows.sort();
for (var i = removedRows.length - 1; i >= 0; i--) {
var idx = removedRows[i];
pool.push(this._detachRow(idx));
rows.splice(idx, 1);
keys.splice(idx, 1);
}
}
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
addedKeys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
var start = 0;
for (var i = 0; i < addedKeys.length; i++) {
start = this._insertRowIntoViewSort(start, addedKeys[i], pool);
}
}
},
_insertRowIntoViewSort: function (start, key, pool) {
var c = this.collection;
var item = c.getItem(key);
var end = this.rows.length - 1;
var idx = -1;
var sortFn = this._sortFn || this._keySort.bind(this);
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._orderedKeys[mid];
var cmp = sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._orderedKeys.splice(idx, 0, key);
this.rows.splice(idx, 0, this._insertRow(idx, pool, c.getItem(key)));
return idx;
},
_applySplicesArraySort: function (splices) {
var keys = this._orderedKeys;
var pool = [];
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
pool.push(this._detachRow(s.index + i));
}
this.rows.splice(s.index, s.removed.length);
}, this);
var c = this.collection;
splices.forEach(function (s) {
var args = [
s.index,
s.removed.length
].concat(s.added);
keys.splice.apply(keys, args);
for (var i = 0; i < s.added.length; i++) {
var item = c.getItem(s.added[i]);
var row = this._insertRow(s.index + i, pool, item);
this.rows.splice(s.index + i, 0, row);
}
}, this);
},
_detachRow: function (idx) {
var row = this.rows[idx];
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < row._children.length; i++) {
var el = row._children[i];
Polymer.dom(row.root).appendChild(el);
}
return row;
},
_insertRow: function (idx, pool, item) {
var row = pool && pool.pop() || this._generateRow(idx, item);
var beforeRow = this.rows[idx];
var beforeNode = beforeRow ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
Polymer.dom(parentNode).insertBefore(row.root, beforeNode);
return row;
},
_generateRow: function (idx, item) {
var model = { __key__: this.collection.getKey(item) };
model[this.as] = item;
model[this.indexAs] = idx;
var row = this.stamp(model);
return row;
},
_showHideChildren: function (hidden) {
if (this.rows) {
for (var i = 0; i < this.rows.length; i++) {
var c$ = this.rows[i]._children;
for (var j = 0; j < c$.length; j++) {
var c = c$[j];
if (c.style) {
c.style.display = hidden ? 'none' : '';
}
c._hideTemplateChildren = hidden;
}
}
}
},
_forwardInstanceProp: function (row, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(row.__key__));
} else {
idx = row[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (row, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this.notifyPath('items.' + row.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
if (this.rows) {
this.rows.forEach(function (row) {
row.__setProperty(prop, value, true);
}, this);
}
},
_forwardParentPath: function (path, value) {
if (this.rows) {
this.rows.forEach(function (row) {
row.notifyPath(path, value, true);
}, this);
}
},
_forwardItemPath: function (path, value) {
if (this._rowForKey) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._rowForKey[key];
var row = this.rows[idx];
if (row) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
row.notifyPath(path, value, true);
} else {
row.__setProperty(this.as, value, true);
}
}
}
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});
Polymer({
is: 'array-selector',
properties: {
items: {
type: Array,
observer: '_itemsChanged'
},
selected: {
type: Object,
notify: true
},
toggle: Boolean,
multi: Boolean
},
_itemsChanged: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
}
if (this.multi) {
this.selected = [];
} else {
this.selected = null;
}
},
deselect: function (item) {
if (this.multi) {
var scol = Polymer.Collection.get(this.selected);
var sidx = this.selected.indexOf(item);
if (sidx >= 0) {
var skey = scol.getKey(item);
this.splice('selected', sidx, 1);
this.unlinkPaths('selected.' + skey);
return true;
}
} else {
this.selected = null;
this.unlinkPaths('selected');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
var scol = Polymer.Collection.get(this.selected);
var skey = scol.getKey(item);
if (skey >= 0) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
this.async(function () {
skey = scol.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
});
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.linkPaths('selected', 'items.' + key);
this.selected = item;
}
}
}
});
Polymer({
is: 'dom-if',
extends: 'template',
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
}
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
this._teardownInstance();
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this._wrapTextNodes(this._content || this.content);
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
this.fire('dom-change');
this._lastIf = this.if;
}
},
_ensureInstance: function () {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
var parent = Polymer.dom(Polymer.dom(this).parentNode);
parent.insertBefore(root, this);
}
},
_teardownInstance: function () {
if (this._instance) {
var c = this._instance._children;
if (c) {
var parent = Polymer.dom(Polymer.dom(c[0]).parentNode);
c.forEach(function (n) {
parent.removeChild(n);
});
}
this._instance = null;
}
},
_wrapTextNodes: function (root) {
for (var n = root.firstChild; n; n = n.nextSibling) {
if (n.nodeType === Node.TEXT_NODE) {
var s = document.createElement('span');
root.insertBefore(s, n);
s.appendChild(n);
n = s;
}
}
},
_showHideChildren: function () {
var hidden = this._hideTemplateChildren || !this.if;
if (this._instance) {
var c$ = this._instance._children;
for (var i = 0; i < c$.length; i++) {
var c = c$[i];
c.style.display = hidden ? 'none' : '';
c._hideTemplateChildren = hidden;
}
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance[prop] = value;
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance.notifyPath(path, value, true);
}
}
});
Polymer.ImportStatus = {
_ready: false,
_callbacks: [],
whenLoaded: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_importsLoaded: function () {
this._ready = true;
this._callbacks.forEach(function (cb) {
cb();
});
this._callbacks = [];
}
};
window.addEventListener('load', function () {
Polymer.ImportStatus._importsLoaded();
});
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.ImportStatus._importsLoaded();
});
}
Polymer({
is: 'dom-bind',
extends: 'template',
created: function () {
Polymer.ImportStatus.whenLoaded(this._readySelf.bind(this));
},
_registerFeatures: function () {
this._prepExtends();
this._prepConstructor();
},
_insertChildren: function () {
var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
parentDom.insertBefore(this.root, this);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
this._setupConfigure = this._setupConfigure.bind(this, config);
},
attached: function () {
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
Polymer.Base._initFeatures.call(this);
this._children = Array.prototype.slice.call(this.root.childNodes);
}
this._insertChildren();
this.fire('dom-change');
},
detached: function () {
this._removeChildren();
}
});</script>
<script>
  /**
   * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
   * coordinate the flow of resize events between "resizers" (elements that control the
   * size or hidden state of their children) and "resizables" (elements that need to be
   * notified when they are resized or un-hidden by their parents in order to take
   * action on their new measurements).
   * Elements that perform measurement should add the `IronResizableBehavior` behavior to
   * their element definition and listen for the `iron-resize` event on themselves.
   * This event will be fired when they become showing after having been hidden,
   * when they are resized explicitly by another resizable, or when the window has been
   * resized.
   * Note, the `iron-resize` event is non-bubbling.
   *
   * @polymerBehavior Polymer.IronResizableBehavior
   * @demo demo/index.html
   **/
  Polymer.IronResizableBehavior = {
    properties: {
      _parentResizable: {
        type: Object,
        observer: '_parentResizableChanged'
      }
    },

    listeners: {
      'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
    },

    created: function() {
      // We don't really need property effects on these, and also we want them
      // to be created before the `_parentResizable` observer fires:
      this._interestedResizables = [];
      this._boundNotifyResize = this.notifyResize.bind(this);
    },

    attached: function() {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    },

    detached: function() {
      if (this._parentResizable) {
        this._parentResizable.stopResizeNotificationsFor(this);
      } else {
        window.removeEventListener('resize', this._boundNotifyResize);
      }

      this._parentResizable = null;
    },

    /**
     * Can be called to manually notify a resizable and its descendant
     * resizables of a resize change.
     */
    notifyResize: function() {
      if (!this.isAttached) {
        return;
      }

      this._interestedResizables.forEach(function(resizable) {
        // TODO(cdata): Currently behaviors cannot define "abstract" methods..
        if (!this.resizerShouldNotify || this.resizerShouldNotify(resizable)) {
          resizable.notifyResize();
        }
      }, this);

      this.fire('iron-resize', null, {
        node: this,
        bubbles: false
      });
    },

    /**
     * Used to assign the closest resizable ancestor to this resizable
     * if the ancestor detects a request for notifications.
     */
    assignParentResizable: function(parentResizable) {
      this._parentResizable = parentResizable;
    },

    /**
     * Used to remove a resizable descendant from the list of descendants
     * that should be notified of a resize change.
     */
    stopResizeNotificationsFor: function(target) {
      var index = this._interestedResizables.indexOf(target);

      if (index > -1) {
        this._interestedResizables.splice(index, 1);
      }
    },

    // TODO(cdata): Currently behaviors cannot define "abstract" methods.
    // resizerShouldNotify: function(el) { return true; },

    _parentResizableChanged: function(parentResizable) {
      if (parentResizable) {
        window.removeEventListener('resize', this._boundNotifyResize);
      }
    },

    _onIronRequestResizeNotifications: function(event) {
      var target = event.path ? event.path[0] : event.target;

      if (target === this) {
        return;
      }

      if (this._interestedResizables.indexOf(target) === -1) {
        this._interestedResizables.push(target);
      }

      target.assignParentResizable(this);

      event.stopPropagation();
    }
  };
</script>

<script>

  /**
   * @param {!Function} selectCallback
   * @constructor
   */
  Polymer.IronSelection = function(selectCallback) {
    this.selection = [];
    this.selectCallback = selectCallback;
  };

  Polymer.IronSelection.prototype = {

    /**
     * Retrieves the selected item(s).
     *
     * @method get
     * @returns Returns the selected item(s). If the multi property is true,
     * `get` will return an array, otherwise it will return
     * the selected item or undefined if there is no selection.
     */
    get: function() {
      return this.multi ? this.selection : this.selection[0];
    },

    /**
     * Clears all the selection except the ones indicated.
     *
     * @method clear
     * @param {Array} excludes items to be excluded.
     */
    clear: function(excludes) {
      this.selection.slice().forEach(function(item) {
        if (!excludes || excludes.indexOf(item) < 0) {
          this.setItemSelected(item, false);
        }
      }, this);
    },

    /**
     * Indicates if a given item is selected.
     *
     * @method isSelected
     * @param {*} item The item whose selection state should be checked.
     * @returns Returns true if `item` is selected.
     */
    isSelected: function(item) {
      return this.selection.indexOf(item) >= 0;
    },

    /**
     * Sets the selection state for a given item to either selected or deselected.
     *
     * @method setItemSelected
     * @param {*} item The item to select.
     * @param {boolean} isSelected True for selected, false for deselected.
     */
    setItemSelected: function(item, isSelected) {
      if (item != null) {
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    },

    /**
     * Sets the selection state for a given item. If the `multi` property
     * is true, then the selected state of `item` will be toggled; otherwise
     * the `item` will be selected.
     *
     * @method select
     * @param {*} item The item to select.
     */
    select: function(item) {
      if (this.multi) {
        this.toggle(item);
      } else if (this.get() !== item) {
        this.setItemSelected(this.get(), false);
        this.setItemSelected(item, true);
      }
    },

    /**
     * Toggles the selection state for `item`.
     *
     * @method toggle
     * @param {*} item The item to toggle.
     */
    toggle: function(item) {
      this.setItemSelected(item, !this.isSelected(item));
    }

  };

</script>
<script>

  /** @polymerBehavior */
  Polymer.IronSelectableBehavior = {

    properties: {

      /**
       * If you want to use the attribute value of an element for `selected` instead of the index,
       * set this to the name of the attribute.
       *
       * @attribute attrForSelected
       * @type {string}
       */
      attrForSelected: {
        type: String,
        value: null
      },

      /**
       * Gets or sets the selected element. The default is to use the index of the item.
       *
       * @attribute selected
       * @type {string}
       */
      selected: {
        type: String,
        notify: true
      },

      /**
       * Returns the currently selected item.
       *
       * @attribute selectedItem
       * @type {Object}
       */
      selectedItem: {
        type: Object,
        readOnly: true,
        notify: true
      },

      /**
       * The event that fires from items when they are selected. Selectable
       * will listen for this event from items and update the selection state.
       * Set to empty string to listen to no events.
       *
       * @attribute activateEvent
       * @type {string}
       * @default 'tap'
       */
      activateEvent: {
        type: String,
        value: 'tap',
        observer: '_activateEventChanged'
      },

      /**
       * This is a CSS selector sting.  If this is set, only items that matches the CSS selector
       * are selectable.
       *
       * @attribute selectable
       * @type {string}
       */
      selectable: String,

      /**
       * The class to set on elements when selected.
       *
       * @attribute selectedClass
       * @type {string}
       */
      selectedClass: {
        type: String,
        value: 'iron-selected'
      },

      /**
       * The attribute to set on elements when selected.
       *
       * @attribute selectedAttribute
       * @type {string}
       */
      selectedAttribute: {
        type: String,
        value: null
      }

    },

    observers: [
      '_updateSelected(attrForSelected, selected)'
    ],

    excludedLocalNames: {
      'template': 1
    },

    created: function() {
      this._bindFilterItem = this._filterItem.bind(this);
      this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
    },

    attached: function() {
      this._observer = this._observeItems(this);
      this._contentObserver = this._observeContent(this);
    },

    detached: function() {
      if (this._observer) {
        this._observer.disconnect();
      }
      if (this._contentObserver) {
        this._contentObserver.disconnect();
      }
      this._removeListener(this.activateEvent);
    },

    /**
     * Returns an array of selectable items.
     *
     * @property items
     * @type Array
     */
    get items() {
      var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
      return Array.prototype.filter.call(nodes, this._bindFilterItem);
    },

    /**
     * Returns the index of the given item.
     *
     * @method indexOf
     * @param {Object} item
     * @returns Returns the index of the item
     */
    indexOf: function(item) {
      return this.items.indexOf(item);
    },

    /**
     * Selects the given value.
     *
     * @method select
     * @param {string} value the value to select.
     */
    select: function(value) {
      this.selected = value;
    },

    /**
     * Selects the previous item.
     *
     * @method selectPrevious
     */
    selectPrevious: function() {
      var length = this.items.length;
      var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
      this.selected = this._indexToValue(index);
    },

    /**
     * Selects the next item.
     *
     * @method selectNext
     */
    selectNext: function() {
      var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
      this.selected = this._indexToValue(index);
    },

    _addListener: function(eventName) {
      this.listen(this, eventName, '_activateHandler');
    },

    _removeListener: function(eventName) {
      // There is no unlisten yet...
      // https://github.com/Polymer/polymer/issues/1639
      //this.removeEventListener(eventName, this._bindActivateHandler);
    },

    _activateEventChanged: function(eventName, old) {
      this._removeListener(old);
      this._addListener(eventName);
    },

    _updateSelected: function() {
      this._selectSelected(this.selected);
    },

    _selectSelected: function(selected) {
      this._selection.select(this._valueToItem(this.selected));
    },

    _filterItem: function(node) {
      return !this.excludedLocalNames[node.localName];
    },

    _valueToItem: function(value) {
      return (value == null) ? null : this.items[this._valueToIndex(value)];
    },

    _valueToIndex: function(value) {
      if (this.attrForSelected) {
        for (var i = 0, item; item = this.items[i]; i++) {
          if (this._valueForItem(item) == value) {
            return i;
          }
        }
      } else {
        return Number(value);
      }
    },

    _indexToValue: function(index) {
      if (this.attrForSelected) {
        var item = this.items[index];
        if (item) {
          return this._valueForItem(item);
        }
      } else {
        return index;
      }
    },

    _valueForItem: function(item) {
      return item[this.attrForSelected] || item.getAttribute(this.attrForSelected);
    },

    _applySelection: function(item, isSelected) {
      if (this.selectedClass) {
        this.toggleClass(this.selectedClass, isSelected, item);
      }
      if (this.selectedAttribute) {
        this.toggleAttribute(this.selectedAttribute, isSelected, item);
      }
      this._selectionChange();
      this.fire('iron-' + (isSelected ? 'select' : 'deselect'), {item: item});
    },

    _selectionChange: function() {
      this._setSelectedItem(this._selection.get());
    },

    // observe content changes under the given node.
    _observeContent: function(node) {
      var content = node.querySelector('content');
      if (content && content.parentElement === node) {
        return this._observeItems(node.domHost);
      }
    },

    // observe items change under the given node.
    _observeItems: function(node) {
      var observer = new MutationObserver(function() {
        if (this.selected != null) {
          this._updateSelected();
        }
      }.bind(this));
      observer.observe(node, {
        childList: true,
        subtree: true
      });
      return observer;
    },

    _activateHandler: function(e) {
      // TODO: remove this when https://github.com/Polymer/polymer/issues/1639 is fixed so we
      // can just remove the old event listener.
      if (e.type !== this.activateEvent) {
        return;
      }
      var t = e.target;
      var items = this.items;
      while (t && t != this) {
        var i = items.indexOf(t);
        if (i >= 0) {
          var value = this._indexToValue(i);
          this._itemActivate(value, t);
          return;
        }
        t = t.parentNode;
      }
    },

    _itemActivate: function(value, item) {
      if (!this.fire('iron-activate',
          {selected: value, item: item}, {cancelable: true}).defaultPrevented) {
        this.select(value);
      }
    }

  };

</script>


<script>
  /** @polymerBehavior Polymer.IronMultiSelectableBehavior */
  Polymer.IronMultiSelectableBehaviorImpl = {
    properties: {

      /**
       * If true, multiple selections are allowed.
       */
      multi: {
        type: Boolean,
        value: false,
        observer: 'multiChanged'
      },

      /**
       * Gets or sets the selected elements. This is used instead of `selected` when `multi`
       * is true.
       */
      selectedValues: {
        type: Array,
        notify: true
      },

      /**
       * Returns an array of currently selected items.
       */
      selectedItems: {
        type: Array,
        readOnly: true,
        notify: true
      },

    },

    observers: [
      '_updateSelected(attrForSelected, selectedValues)'
    ],

    /**
     * Selects the given value. If the `multi` property is true, then the selected state of the
     * `value` will be toggled; otherwise the `value` will be selected.
     *
     * @method select
     * @param {string} value the value to select.
     */
    select: function(value) {
      if (this.multi) {
        if (this.selectedValues) {
          this._toggleSelected(value);
        } else {
          this.selectedValues = [value];
        }
      } else {
        this.selected = value;
      }
    },

    multiChanged: function(multi) {
      this._selection.multi = multi;
    },

    _updateSelected: function() {
      if (this.multi) {
        this._selectMulti(this.selectedValues);
      } else {
        this._selectSelected(this.selected);
      }
    },

    _selectMulti: function(values) {
      this._selection.clear();
      if (values) {
        for (var i = 0; i < values.length; i++) {
          this._selection.setItemSelected(this._valueToItem(values[i]), true);
        }
      }
    },

    _selectionChange: function() {
      var s = this._selection.get();
      if (this.multi) {
        this._setSelectedItems(s);
      } else {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      }
    },

    _toggleSelected: function(value) {
      var i = this.selectedValues.indexOf(value);
      var unselected = i < 0;
      if (unselected) {
        this.selectedValues.push(value);
      } else {
        this.selectedValues.splice(i, 1);
      }
      this._selection.setItemSelected(this._valueToItem(value), unselected);
    }
  };

  /** @polymerBehavior */
  Polymer.IronMultiSelectableBehavior = [
    Polymer.IronSelectableBehavior,
    Polymer.IronMultiSelectableBehaviorImpl
  ];

</script>
<script>
  /**
  `iron-selector` is an element which can be used to manage a list of elements
  that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
  which item is being selected.  The default is to use the index of the item.

  Example:

      <iron-selector selected="0">
        <div>Item 1</div>
        <div>Item 2</div>
        <div>Item 3</div>
      </iron-selector>

  If you want to use the attribute value of an element for `selected` instead of the index,
  set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
  `name`, set `attrForSelected` to `name`.

  Example:

      <iron-selector attr-for-selected="name" selected="foo">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="zot">Zot</div>
      </iron-selector>

  `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.

  Example:

      <style>
        .iron-selected {
          background: #eee;
        }
      </style>

      ...

      <iron-selector selected="0">
        <div>Item 1</div>
        <div>Item 2</div>
        <div>Item 3</div>
      </iron-selector>

  @demo demo/index.html
  */

  Polymer({

    is: 'iron-selector',

    behaviors: [
      Polymer.IronMultiSelectableBehavior
    ]

  });

</script>




<script>

  (function() {

    // monostate data
    var metaDatas = {};
    var metaArrays = {};

    Polymer.IronMeta = Polymer({

      is: 'iron-meta',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         *
         * @attribute type
         * @type String
         * @default 'default'
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * The key used to store `value` under the `type` namespace.
         *
         * @attribute key
         * @type String
         * @default ''
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         *
         * @attribute value
         * @type *
         * @default this
         */
        value: {
          type: Object,
          notify: true,
          observer: '_valueChanged'
        },

        /**
         * If true, `value` is set to the iron-meta instance itself.
         *
         * @attribute self
         * @type Boolean
         * @default false
         */
         self: {
          type: Boolean,
          observer: '_selfChanged'
        },

        /**
         * Array of all meta-data values for the given type.
         *
         * @property list
         * @type Array
         */
        list: {
          type: Array,
          notify: true
        }

      },

      /**
       * Only runs if someone invokes the factory/constructor directly
       * e.g. `new Polymer.IronMeta()`
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
              case 'value':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key, old) {
        this._resetRegistration(old);
      },

      _valueChanged: function(value) {
        this._resetRegistration(this.key);
      },

      _selfChanged: function(self) {
        if (self) {
          this.value = this;
        }
      },

      _typeChanged: function(type) {
        this._unregisterKey(this.key);
        if (!metaDatas[type]) {
          metaDatas[type] = {};
        }
        this._metaData = metaDatas[type];
        if (!metaArrays[type]) {
          metaArrays[type] = [];
        }
        this.list = metaArrays[type];
        this._registerKeyValue(this.key, this.value);
      },

      /**
       * Retrieves meta data value by key.
       *
       * @method byKey
       * @param {String} key The key of the meta-data to be returned.
       * @returns *
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      },

      _resetRegistration: function(oldKey) {
        this._unregisterKey(oldKey);
        this._registerKeyValue(this.key, this.value);
      },

      _unregisterKey: function(key) {
        this._unregister(key, this._metaData, this.list);
      },

      _registerKeyValue: function(key, value) {
        this._register(key, value, this._metaData, this.list);
      },

      _register: function(key, value, data, list) {
        if (key && data && value !== undefined) {
          data[key] = value;
          list.push(value);
        }
      },

      _unregister: function(key, data, list) {
        if (key && data) {
          if (key in data) {
            var value = data[key];
            delete data[key];
            this.arrayDelete(list, value);
          }
        }
      }

    });

    /**
    `iron-meta-query` can be used to access infomation stored in `iron-meta`.

    Examples:

    If I create an instance like this:

        <iron-meta key="info" value="foo/bar"></iron-meta>

    Note that keyUrl="foo/bar" is the metadata I've defined. I could define more
    attributes or use child nodes to define additional metadata.

    Now I can access that element (and it's metadata) from any `iron-meta-query` instance:

         var value = new Polymer.IronMetaQuery({key: 'info'}).value;

    @group Polymer Iron Elements
    @element iron-meta-query
    */
    Polymer.IronMetaQuery = Polymer({

      is: 'iron-meta-query',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         *
         * @attribute type
         * @type String
         * @default 'default'
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * Specifies a key to use for retrieving `value` from the `type`
         * namespace.
         *
         * @attribute key
         * @type String
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         *
         * @attribute value
         * @type *
         * @default this
         */
        value: {
          type: Object,
          notify: true,
          readOnly: true
        },

        /**
         * Array of all meta-data values for the given type.
         *
         * @property list
         * @type Array
         */
        list: {
          type: Array,
          notify: true
        }

      },

      /**
       * Actually a factory method, not a true constructor. Only runs if
       * someone invokes it directly (via `new Polymer.IronMeta()`);
       */
      constructor: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key) {
        this._setValue(this._metaData && this._metaData[key]);
      },

      _typeChanged: function(type) {
        this._metaData = metaDatas[type];
        this.list = metaArrays[type];
        if (this.key) {
          this._keyChanged(this.key);
        }
      },

      /**
       * Retrieves meta data value by key.
       *
       * @method byKey
       * @param {String} key The key of the meta-data to be returned.
       * @returns *
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      }

    });

  })();
</script>
<script>
  /**
   * The `iron-iconset-svg` element allows users to define their own icon sets
   * that contain svg icons. The svg icon elements should be children of the
   * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
   *
   * Using svg elements to create icons has a few advantages over traditional
   * bitmap graphics like jpg or png. Icons that use svg are vector based so they
   * are resolution independent and should look good on any device. They are
   * stylable via css. Icons can be themed, colorized, and even animated.
   *
   * Example:
   *
   *     <iron-iconset-svg id="my-svg-icons" iconSize="24">
   *       <svg>
   *         <defs>
   *           <g id="shape">
   *             <rect x="50" y="50" width="50" height="50" />
   *             <circle cx="50" cy="50" r="50" />
   *           </g>
   *         </defs>
   *       </svg>
   *     </iron-iconset-svg>
   *
   * This will automatically register the icon set "my-svg-icons" to the iconset
   * database.  To use these icons from within another element, make a
   * `iron-iconset` element and call the `byId` method
   * to retrieve a given iconset. To apply a particular icon inside an
   * element use the `applyIcon` method. For example:
   *
   *     iconset.applyIcon(iconNode, 'car');
   *
   * @element iron-iconset-svg
   */
  Polymer({

    is: 'iron-iconset-svg',

    properties: {

      /**
       * The name of the iconset.
       *
       * @attribute name
       * @type string
       */
      name: {
        type: String,
        observer: '_nameChanged'
      },

      /**
       * The size of an individual icon. Note that icons must be square.
       *
       * @attribute iconSize
       * @type number
       * @default 24
       */
      size: {
        type: Number,
        value: 24
      }

    },

    /**
     * Construct an array of all icon names in this iconset.
     *
     * @return {!Array} Array of icon names.
     */
    getIconNames: function() {
      this._icons = this._createIconMap();
      return Object.keys(this._icons).map(function(n) {
        return this.name + ':' + n;
      }, this);
    },

    /**
     * Applies an icon to the given element.
     *
     * An svg icon is prepended to the element's shadowRoot if it exists,
     * otherwise to the element itself.
     *
     * @method applyIcon
     * @param {Element} element Element to which the icon is applied.
     * @param {string} iconName Name of the icon to apply.
     * @return {Element} The svg element which renders the icon.
     */
    applyIcon: function(element, iconName) {
      // insert svg element into shadow root, if it exists
      element = element.root || element;
      // Remove old svg element
      this.removeIcon(element);
      // install new svg element
      var svg = this._cloneIcon(iconName);
      if (svg) {
        var pde = Polymer.dom(element);
        pde.insertBefore(svg, pde.childNodes[0]);
        return element._svgIcon = svg;
      }
      return null;
    },

    /**
     * Remove an icon from the given element by undoing the changes effected
     * by `applyIcon`.
     *
     * @param {Element} element The element from which the icon is removed.
     */
    removeIcon: function(element) {
      // Remove old svg element
      if (element._svgIcon) {
        Polymer.dom(element).removeChild(element._svgIcon);
        element._svgIcon = null;
      }
    },

    /**
     *
     * When name is changed, register iconset metadata
     *
     */
    _nameChanged: function() {
      new Polymer.IronMeta({type: 'iconset', key: this.name, value: this});
    },

    /**
     * Create a map of child SVG elements by id.
     *
     * @return {Object} Map of id's to SVG elements.
     */
    _createIconMap: function() {
      // Objects chained to Object.prototype (`{}`) have members. Specifically,
      // on FF there is a `watch` method that confuses the icon map, so we
      // need to use a null-based object here.
      var icons = Object.create(null);
      Polymer.dom(this).querySelectorAll('[id]')
        .forEach(function(icon) {
          icons[icon.id] = icon;
        });
      return icons;
    },

    /**
     * Produce installable clone of the SVG element matching `id` in this
     * iconset, or `undefined` if there is no matching element.
     *
     * @return {Element} Returns an installable clone of the SVG element
     * matching `id`.
     */
    _cloneIcon: function(id) {
      // create the icon map on-demand, since the iconset itself has no discrete
      // signal to know when it's children are fully parsed
      this._icons = this._icons || this._createIconMap();
      return this._prepareSvgClone(this._icons[id], this.size);
    },

    /**
     * @param {Element} sourceSvg
     * @param {number} size
     * @return {Element}
     */
    _prepareSvgClone: function(sourceSvg, size) {
      if (sourceSvg) {
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', ['0', '0', size, size].join(' '));
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
        // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
        svg.style.cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';
        svg.appendChild(sourceSvg.cloneNode(true)).removeAttribute('id');
        return svg;
      }
      return null;
    }

  });
</script>


<script>

  Polymer({

    is: 'iron-iconset',

    properties: {

      /**
       * The URL of the iconset image.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: {
        type: String,
        observer: '_srcChanged'
      },

      /**
       * The name of the iconset.
       *
       * @attribute name
       * @type string
       * @default 'no-name'
       */
      name: {
        type: String,
        observer: '_nameChanged'
      },

      /**
       * The width of the iconset image. This must only be specified if the
       * icons are arranged into separate rows inside the image.
       *
       * @attribute width
       * @type number
       * @default 0
       */
      width: {
        type: Number,
        value: 0
      },

      /**
       * A space separated list of names corresponding to icons in the iconset
       * image file. This list must be ordered the same as the icon images
       * in the image file.
       *
       * @attribute icons
       * @type string
       * @default ''
       */
      icons: {
        type: String
      },

      /**
       * The size of an individual icon. Note that icons must be square.
       *
       * @attribute size
       * @type number
       * @default 24
       */
      size: {
        type: Number,
        value: 24
      },

      /**
       * The horizontal offset of the icon images in the inconset src image.
       * This is typically used if the image resource contains additional images
       * beside those intended for the iconset.
       *
       * @attribute offset-x
       * @type number
       * @default 0
       */
      _offsetX: {
        type: Number,
        value: 0
      },

      /**
       * The vertical offset of the icon images in the inconset src image.
       * This is typically used if the image resource contains additional images
       * beside those intended for the iconset.
       *
       * @attribute offset-y
       * @type number
       * @default 0
       */
      _offsetY: {
        type: Number,
        value: 0
      },

      /**
       * Array of fully-qualified names of icons in this set.
       */
      iconNames: {
        type: Array,
        notify: true
      }

    },

    hostAttributes: {
      // non-visual
      style: 'display: none;'
    },

    ready: function() {
      // theme data must exist at ready-time
      this._themes = this._mapThemes();
    },

    /**
     * Applies an icon to the given element as a css background image. This
     * method does not size the element, and it's usually necessary to set
     * the element's height and width so that the background image is visible.
     *
     * @method applyIcon
     * @param {Element} element The element to which the icon is applied.
     * @param {String|Number} icon The name or index of the icon to apply.
     * @param {String} theme (optional) The name or index of the icon to apply.
     * @param {Number} scale (optional, defaults to 1) Icon scaling factor.
     * @return {Element} The applied icon element.
     */
    applyIcon: function(element, icon, theme, scale) {
      this._validateIconMap();
      var offset = this._getThemedOffset(icon, theme);
      if (element && offset) {
        this._addIconStyles(element, this._srcUrl, offset, scale || 1,
          this.size, this.width);
      }
    },

    /**
     * Remove an icon from the given element by undoing the changes effected
     * by `applyIcon`.
     *
     * @param {Element} element The element from which the icon is removed.
     */
    removeIcon: function(element) {
      this._removeIconStyles(element.style);
    },

    _mapThemes: function() {
      var themes = Object.create(null);
      Polymer.dom(this).querySelectorAll('property[theme]')
        .forEach(function(property) {
          var offsetX = window.parseInt(
            property.getAttribute('offset-x'), 10
          ) || 0;
          var offsetY = window.parseInt(
            property.getAttribute('offset-y'), 10
          ) || 0;
          themes[property.getAttribute('theme')] = {
            offsetX: offsetX,
            offsetY: offsetY
          };
        });
      return themes;
    },

    _srcChanged: function(src) {
      // ensure `srcUrl` is always relative to the main document
      this._srcUrl = this.ownerDocument !== document
        ? this.resolveUrl(src) : src;
      this._prepareIconset();
    },

    _nameChanged: function(name) {
      this._prepareIconset();
    },

    _prepareIconset: function() {
      new Polymer.IronMeta({type: 'iconset', key: this.name, value: this});
    },

    _invalidateIconMap: function() {
      this._iconMapValid = false;
    },

    _validateIconMap: function() {
      if (!this._iconMapValid) {
        this._recomputeIconMap();
        this._iconMapValid = true;
      }
    },

    _recomputeIconMap: function() {
      this.iconNames = this._computeIconNames(this.icons);
      this.iconMap = this._computeIconMap(this._offsetX, this._offsetY,
        this.size, this.width, this.iconNames);
    },

    _computeIconNames: function(icons) {
      return icons.split(/\s+/g);
    },

    _computeIconMap: function(offsetX, offsetY, size, width, iconNames) {
      var iconMap = {};
      if (offsetX !== undefined && offsetY !== undefined) {
        var x0 = offsetX;
        iconNames.forEach(function(iconName) {
          iconMap[iconName] = {
            offsetX: offsetX,
            offsetY: offsetY
          };
          if ((offsetX + size) < width) {
            offsetX += size;
          } else {
            offsetX = x0;
            offsetY += size;
          }
        }, this);
      }
      return iconMap;
    },

    /**
     * Returns an object containing `offsetX` and `offsetY` properties which
     * specify the pixel location in the iconset's src file for the given
     * `icon` and `theme`. It's uncommon to call this method. It is useful,
     * for example, to manually position a css backgroundImage to the proper
     * offset. It's more common to use the `applyIcon` method.
     *
     * @method getThemedOffset
     * @param {String|Number} identifier The name of the icon or the index of
     * the icon within in the icon image.
     * @param {String} theme The name of the theme.
     * @returns {Object} An object specifying the offset of the given icon
     * within the icon resource file; `offsetX` is the horizontal offset and
     * `offsetY` is the vertical offset. Both values are in pixel units.
     */
    _getThemedOffset: function(identifier, theme) {
      var iconOffset = this._getIconOffset(identifier);
      var themeOffset = this._themes[theme];
      if (iconOffset && themeOffset) {
        return {
          offsetX: iconOffset.offsetX + themeOffset.offsetX,
          offsetY: iconOffset.offsetY + themeOffset.offsetY
        };
      }
      return iconOffset;
    },

    _getIconOffset: function(identifier) {
      // TODO(sjmiles): consider creating offsetArray (indexed by Number)
      // and having iconMap map names to indices, then and index is just
      // iconMap[identifier] || identifier (be careful of zero, store indices
      // as 1-based)
      return this.iconMap[identifier] ||
             this.iconMap[this.iconNames[Number(identifier)]];
    },

    _addIconStyles: function(element, url, offset, scale, size, width) {
      var style = element.style;
      style.backgroundImage = 'url(' + url + ')';
      style.backgroundPosition =
        (-offset.offsetX * scale + 'px') + ' ' +
        (-offset.offsetY * scale + 'px');
      style.backgroundSize = (scale === 1) ? 'auto' : width * scale + 'px';
      style.width = size + 'px';
      style.height = size + 'px';
      element.setAttribute('role', 'img');
    },

    _removeIconStyles: function(style) {
      style.background = '';
    }

  });

</script>


<style is="custom-style">

  :root {

    --layout: {
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
    };

    --layout-inline: {
      display: -ms-inline-flexbox;
      display: -webkit-inline-flex;
      display: inline-flex;
    };

    --layout-horizontal: {
      /* @apply(--layout); */
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;

      -ms-flex-direction: row;
      -webkit-flex-direction: row;
      flex-direction: row;
    };

    --layout-horizontal-reverse: {
      -ms-flex-direction: row-reverse;
      -webkit-flex-direction: row-reverse;
      flex-direction: row-reverse;
    };

    --layout-vertical: {
      /* @apply(--layout); */
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;

      -ms-flex-direction: column;
      -webkit-flex-direction: column;
      flex-direction: column;
    };

    --layout-vertical-reverse: {
      -ms-flex-direction: column-reverse;
      -webkit-flex-direction: column-reverse;
      flex-direction: column-reverse;
    };

    --layout-wrap: {
      -ms-flex-wrap: wrap;
      -webkit-flex-wrap: wrap;
      flex-wrap: wrap;
    };

    --layout-wrap-reverse: {
      -ms-flex-wrap: wrap-reverse;
      -webkit-flex-wrap: wrap-reverse;
      flex-wrap: wrap-reverse;
    };

    --layout-flex-auto: {
      -ms-flex: 1 1 auto;
      -webkit-flex: 1 1 auto;
      flex: 1 1 auto;
    };

    --layout-flex-none: {
      -ms-flex: none;
      -webkit-flex: none;
      flex: none;
    };

    --layout-flex: {
      -ms-flex: 1 1 0.000000001px;
      -webkit-flex: 1;
      flex: 1;
      -webkit-flex-basis: 0.000000001px;
      flex-basis: 0.000000001px;
    };

    --layout-flex-2: {
      -ms-flex: 2;
      -webkit-flex: 2;
      flex: 2;
    };

    --layout-flex-3: {
      -ms-flex: 3;
      -webkit-flex: 3;
      flex: 3;
    };

    --layout-flex-4: {
      -ms-flex: 4;
      -webkit-flex: 4;
      flex: 4;
    };

    --layout-flex-5: {
      -ms-flex: 5;
      -webkit-flex: 5;
      flex: 5;
    };

    --layout-flex-6: {
      -ms-flex: 6;
      -webkit-flex: 6;
      flex: 6;
    };

    --layout-flex-7: {
      -ms-flex: 7;
      -webkit-flex: 7;
      flex: 7;
    };

    --layout-flex-8: {
      -ms-flex: 8;
      -webkit-flex: 8;
      flex: 8;
    };

    --layout-flex-9: {
      -ms-flex: 9;
      -webkit-flex: 9;
      flex: 9;
    };

    --layout-flex-10: {
      -ms-flex: 10;
      -webkit-flex: 10;
      flex: 10;
    };

    --layout-flex-11: {
      -ms-flex: 11;
      -webkit-flex: 11;
      flex: 11;
    };

    --layout-flex-12: {
      -ms-flex: 12;
      -webkit-flex: 12;
      flex: 12;
    };

    /* alignment in cross axis */

    --layout-start: {
      -ms-flex-align: start;
      -webkit-align-items: flex-start;
      align-items: flex-start;
    };

    --layout-center: {
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
    };

    --layout-end: {
      -ms-flex-align: end;
      -webkit-align-items: flex-end;
      align-items: flex-end;
    };

    /* alignment in main axis */

    --layout-start-justified: {
      -ms-flex-pack: start;
      -webkit-justify-content: flex-start;
      justify-content: flex-start;
    };

    --layout-center-justified: {
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    --layout-end-justified: {
      -ms-flex-pack: end;
      -webkit-justify-content: flex-end;
      justify-content: flex-end;
    };

    --layout-around-justified: {
      -ms-flex-pack: around;
      -webkit-justify-content: space-around;
      justify-content: space-around;
    };

    --layout-justified: {
      -ms-flex-pack: justify;
      -webkit-justify-content: space-between;
      justify-content: space-between;
    };

    --layout-center-center: {
      /* @apply(--layout-center --layout-center-justified); */
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    /* self alignment */

    --layout-self-start: {
      -ms-align-self: flex-start;
      -webkit-align-self: flex-start;
      align-self: flex-start;
    };

    --layout-self-center: {
      -ms-align-self: center;
      -webkit-align-self: center;
      align-self: center;
    };

    --layout-self-end: {
      -ms-align-self: flex-end;
      -webkit-align-self: flex-end;
      align-self: flex-end;
    };

    --layout-self-stretch: {
      -ms-align-self: stretch;
      -webkit-align-self: stretch;
      align-self: stretch;
    };

    /*******************************
              Other Layout
    *******************************/

    --layout-block: {
      display: block;
    };

    --layout-invisible: {
      visibility: hidden !important;
    };

    --layout-relative: {
      position: relative;
    };

    --layout-fit: {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-scroll: {
      -webkit-overflow-scrolling: touch;
      overflow: auto;
    };

    /* fixed position */

    --layout-fixed-bottom:,
    --layout-fixed-left:,
    --layout-fixed-right:,
    --layout-fixed-top: {
      position: fixed;
    };

    --layout-fixed-top: {
      top: 0;
      left: 0;
      right: 0;
    };

    --layout-fixed-right: {
      top: 0;
      right: 0;
      bottom: 0;
    };

    --layout-fixed-bottom: {
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-fixed-left: {
      top: 0;
      bottom: 0;
      left: 0;
    };

  }

</style>


<style is="custom-style">
  :root {
    --iron-icon-width: 24px;
    --iron-icon-height: 24px;
  }
</style>






<script>

  Polymer({

    is: 'iron-media-query',

    properties: {

      /**
       * The Boolean return value of the media query.
       *
       * @attribute queryMatches
       * @type Boolean
       * @default false
       */
      queryMatches: {
        type: Boolean,
        value: false,
        readOnly: true,
        notify: true
      },

      /**
       * The CSS media query to evaluate.
       *
       * @attribute query
       * @type String
       */
      query: {
        type: String,
        observer: 'queryChanged'
      }

    },

    created: function() {
      this._mqHandler = this.queryHandler.bind(this);
    },

    queryChanged: function(query) {
      if (this._mq) {
        this._mq.removeListener(this._mqHandler);
      }
      if (query[0] !== '(') {
        query = '(' + query + ')';
      }
      this._mq = window.matchMedia(query);
      this._mq.addListener(this._mqHandler);
      this.queryHandler(this._mq);
    },

    queryHandler: function(mq) {
      this._setQueryMatches(mq.matches);
    }

  });

</script>




<style is="custom-style">

  :root {

    --dark-primary-color: #303f9f;

    --default-primary-color: #3f51b5;

    --light-primary-color: #c5cae9;

    --text-primary-color: #ffffff;

    --accent-color: #ff4081;

    --primary-background-color: #ffffff;

    --primary-text-color: #212121;

    --secondary-text-color: #757575;

    --disabled-text-color: #bdbdbd;

    --divider-color: #e0e0e0;

  }

</style>
<script>
  (function() {
    'use strict';

    /**
     * Chrome uses an older version of DOM Level 3 Keyboard Events
     *
     * Most keys are labeled as text, but some are Unicode codepoints.
     * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
     */
    var KEY_IDENTIFIER = {
      'U+0009': 'tab',
      'U+001B': 'esc',
      'U+0020': 'space',
      'U+002A': '*',
      'U+0030': '0',
      'U+0031': '1',
      'U+0032': '2',
      'U+0033': '3',
      'U+0034': '4',
      'U+0035': '5',
      'U+0036': '6',
      'U+0037': '7',
      'U+0038': '8',
      'U+0039': '9',
      'U+0041': 'a',
      'U+0042': 'b',
      'U+0043': 'c',
      'U+0044': 'd',
      'U+0045': 'e',
      'U+0046': 'f',
      'U+0047': 'g',
      'U+0048': 'h',
      'U+0049': 'i',
      'U+004A': 'j',
      'U+004B': 'k',
      'U+004C': 'l',
      'U+004D': 'm',
      'U+004E': 'n',
      'U+004F': 'o',
      'U+0050': 'p',
      'U+0051': 'q',
      'U+0052': 'r',
      'U+0053': 's',
      'U+0054': 't',
      'U+0055': 'u',
      'U+0056': 'v',
      'U+0057': 'w',
      'U+0058': 'x',
      'U+0059': 'y',
      'U+005A': 'z',
      'U+007F': 'del'
    };

    /**
     * Special table for KeyboardEvent.keyCode.
     * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
     * than that.
     *
     * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
     */
    var KEY_CODE = {
      9: 'tab',
      13: 'enter',
      27: 'esc',
      33: 'pageup',
      34: 'pagedown',
      35: 'end',
      36: 'home',
      32: 'space',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down',
      46: 'del',
      106: '*'
    };

    /**
     * MODIFIER_KEYS maps the short name for modifier keys used in a key
     * combo string to the property name that references those same keys
     * in a KeyboardEvent instance.
     */
    var MODIFIER_KEYS = {
      shift: 'shiftKey',
      ctrl: 'ctrlKey',
      alt: 'altKey',
      meta: 'metaKey'
    };

    /**
     * KeyboardEvent.key is mostly represented by printable character made by
     * the keyboard, with unprintable keys labeled nicely.
     *
     * However, on OS X, Alt+char can make a Unicode character that follows an
     * Apple-specific mapping. In this case, we
     * fall back to .keyCode.
     */
    var KEY_CHAR = /[a-z0-9*]/;

    /**
     * Matches a keyIdentifier string.
     */
    var IDENT_CHAR = /U\+/;

    /**
     * Matches arrow keys in Gecko 27.0+
     */
    var ARROW_KEY = /^arrow/;

    /**
     * Matches space keys everywhere (notably including IE10's exceptional name
     * `spacebar`).
     */
    var SPACE_KEY = /^space(bar)?/;

    function transformKey(key) {
      var validKey = '';
      if (key) {
        var lKey = key.toLowerCase();
        if (lKey.length == 1) {
          if (KEY_CHAR.test(lKey)) {
            validKey = lKey;
          }
        } else if (ARROW_KEY.test(lKey)) {
          validKey = lKey.replace('arrow', '');
        } else if (SPACE_KEY.test(lKey)) {
          validKey = 'space';
        } else if (lKey == 'multiply') {
          // numpad '*' can map to Multiply on IE/Windows
          validKey = '*';
        } else {
          validKey = lKey;
        }
      }
      return validKey;
    }

    function transformKeyIdentifier(keyIdent) {
      var validKey = '';
      if (keyIdent) {
        if (IDENT_CHAR.test(keyIdent)) {
          validKey = KEY_IDENTIFIER[keyIdent];
        } else {
          validKey = keyIdent.toLowerCase();
        }
      }
      return validKey;
    }

    function transformKeyCode(keyCode) {
      var validKey = '';
      if (Number(keyCode)) {
        if (keyCode >= 65 && keyCode <= 90) {
          // ascii a-z
          // lowercase is 32 offset from uppercase
          validKey = String.fromCharCode(32 + keyCode);
        } else if (keyCode >= 112 && keyCode <= 123) {
          // function keys f1-f12
          validKey = 'f' + (keyCode - 112);
        } else if (keyCode >= 48 && keyCode <= 57) {
          // top 0-9 keys
          validKey = String(48 - keyCode);
        } else if (keyCode >= 96 && keyCode <= 105) {
          // num pad 0-9
          validKey = String(96 - keyCode);
        } else {
          validKey = KEY_CODE[keyCode];
        }
      }
      return validKey;
    }

    function normalizedKeyForEvent(keyEvent) {
      // fall back from .key, to .keyIdentifier, to .keyCode, and then to
      // .detail.key to support artificial keyboard events
      return transformKey(keyEvent.key) ||
        transformKeyIdentifier(keyEvent.keyIdentifier) ||
        transformKeyCode(keyEvent.keyCode) ||
        transformKey(keyEvent.detail.key) || '';
    }

    function keyComboMatchesEvent(keyCombo, keyEvent) {
      return normalizedKeyForEvent(keyEvent) === keyCombo.key &&
        !!keyEvent.shiftKey === !!keyCombo.shiftKey &&
        !!keyEvent.ctrlKey === !!keyCombo.ctrlKey &&
        !!keyEvent.altKey === !!keyCombo.altKey &&
        !!keyEvent.metaKey === !!keyCombo.metaKey;
    }

    function parseKeyComboString(keyComboString) {
      return keyComboString.split('+').reduce(function(parsedKeyCombo, keyComboPart) {
        var eventParts = keyComboPart.split(':');
        var keyName = eventParts[0];
        var event = eventParts[1];

        if (keyName in MODIFIER_KEYS) {
          parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        } else {
          parsedKeyCombo.key = keyName;
          parsedKeyCombo.event = event || 'keydown';
        }

        return parsedKeyCombo;
      }, {
        combo: keyComboString.split(':').shift()
      });
    }

    function parseEventString(eventString) {
      return eventString.split(' ').map(function(keyComboString) {
        return parseKeyComboString(keyComboString);
      });
    }


    /**
     * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
     * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
     * The element takes care of browser differences with respect to Keyboard events
     * and uses an expressive syntax to filter key presses.
     *
     * Use the `keyBindings` prototype property to express what combination of keys
     * will trigger the event to fire.
     *
     * Use the `key-event-target` attribute to set up event handlers on a specific
     * node.
     * The `keys-pressed` event will fire when one of the key combinations set with the
     * `keys` property is pressed.
     *
     * @polymerBehavior IronA11yKeysBehavior
     */
    Polymer.IronA11yKeysBehavior = {
      properties: {
        /**
         * The HTMLElement that will be firing relevant KeyboardEvents.
         */
        keyEventTarget: {
          type: Object,
          value: function() {
            return this;
          }
        },

        _boundKeyHandlers: {
          value: function() {
            return [];
          }
        },

        // We use this due to a limitation in IE10 where instances will have
        // own properties of everything on the "prototype".
        _imperativeKeyBindings: {
          value: function() {
            return {};
          }
        }
      },

      observers: [
        '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
      ],

      keyBindings: {},

      registered: function() {
        this._prepKeyBindings();
      },

      attached: function() {
        this._listenKeyEventListeners();
      },

      detached: function() {
        this._unlistenKeyEventListeners();
      },

      /**
       * Can be used to imperatively add a key binding to the implementing
       * element. This is the imperative equivalent of declaring a keybinding
       * in the `keyBindings` prototype property.
       */
      addOwnKeyBinding: function(eventString, handlerName) {
        this._imperativeKeyBindings[eventString] = handlerName;
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      /**
       * When called, will remove all imperatively-added key bindings.
       */
      removeOwnKeyBindings: function() {
        this._imperativeKeyBindings = {};
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      keyboardEventMatchesKeys: function(event, eventString) {
        var keyCombos = parseEventString(eventString);
        var index;

        for (index = 0; index < keyCombos.length; ++index) {
          if (keyComboMatchesEvent(keyCombos[index], event)) {
            return true;
          }
        }

        return false;
      },

      _collectKeyBindings: function() {
        var keyBindings = this.behaviors.map(function(behavior) {
          return behavior.keyBindings;
        });

        if (keyBindings.indexOf(this.keyBindings) === -1) {
          keyBindings.push(this.keyBindings);
        }

        return keyBindings;
      },

      _prepKeyBindings: function() {
        this._keyBindings = {};

        this._collectKeyBindings().forEach(function(keyBindings) {
          for (var eventString in keyBindings) {
            this._addKeyBinding(eventString, keyBindings[eventString]);
          }
        }, this);

        for (var eventString in this._imperativeKeyBindings) {
          this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
        }
      },

      _addKeyBinding: function(eventString, handlerName) {
        parseEventString(eventString).forEach(function(keyCombo) {
          this._keyBindings[keyCombo.event] =
            this._keyBindings[keyCombo.event] || [];

          this._keyBindings[keyCombo.event].push([
            keyCombo,
            handlerName
          ]);
        }, this);
      },

      _resetKeyEventListeners: function() {
        this._unlistenKeyEventListeners();

        if (this.isAttached) {
          this._listenKeyEventListeners();
        }
      },

      _listenKeyEventListeners: function() {
        Object.keys(this._keyBindings).forEach(function(eventName) {
          var keyBindings = this._keyBindings[eventName];
          var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

          this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

          this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
        }, this);
      },

      _unlistenKeyEventListeners: function() {
        var keyHandlerTuple;
        var keyEventTarget;
        var eventName;
        var boundKeyHandler;

        while (this._boundKeyHandlers.length) {
          // My kingdom for block-scope binding and destructuring assignment..
          keyHandlerTuple = this._boundKeyHandlers.pop();
          keyEventTarget = keyHandlerTuple[0];
          eventName = keyHandlerTuple[1];
          boundKeyHandler = keyHandlerTuple[2];

          keyEventTarget.removeEventListener(eventName, boundKeyHandler);
        }
      },

      _onKeyBindingEvent: function(keyBindings, event) {
        keyBindings.forEach(function(keyBinding) {
          var keyCombo = keyBinding[0];
          var handlerName = keyBinding[1];

          if (!event.defaultPrevented && keyComboMatchesEvent(keyCombo, event)) {
            this._triggerKeyHandler(keyCombo, handlerName, event);
          }
        }, this);
      },

      _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
        var detail = Object.create(keyCombo);
        detail.keyboardEvent = keyboardEvent;

        this[handlerName].call(this, new CustomEvent(keyCombo.event, {
          detail: detail
        }));
      }
    };
  })();
</script>
<script>

  /** @polymerBehavior */

  Polymer.IronControlState = {

    properties: {

      /**
       * If true, the element currently has focus.
       *
       * @attribute focused
       * @type boolean
       * @default false
       */
      focused: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * If true, the user cannot interact with this element.
       *
       * @attribute disabled
       * @type boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        notify: true,
        observer: '_disabledChanged',
        reflectToAttribute: true
      },

      _oldTabIndex: {
        type: Number
      }
    },

    observers: [
      '_changedControlState(focused, disabled)'
    ],

    listeners: {
      focus: '_focusHandler',
      blur: '_blurHandler'
    },

    ready: function() {
      // TODO(sjmiles): ensure read-only property is valued so the compound
      // observer will fire
      if (this.focused === undefined) {
        this._setFocused(false);
      }
    },

    _focusHandler: function() {
      this._setFocused(true);
    },

    _blurHandler: function() {
      this._setFocused(false);
    },

    _disabledChanged: function(disabled, old) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      this.style.pointerEvents = disabled ? 'none' : '';
      if (disabled) {
        this._oldTabIndex = this.tabIndex;
        this.focused = false;
        this.tabIndex = -1;
      } else if (this._oldTabIndex !== undefined) {
        this.tabIndex = this._oldTabIndex;
      }
    },

    _changedControlState: function() {
      // _controlStateChanged is abstract, follow-on behaviors may implement it
      if (this._controlStateChanged) {
        this._controlStateChanged();
      }
    }

  };

</script>
<script>

  /** @polymerBehavior Polymer.IronButtonState */
  Polymer.IronButtonStateImpl = {

    properties: {

      /**
       * If true, the user is currently holding down the button.
       *
       * @attribute pressed
       * @type boolean
       * @default false
       */
      pressed: {
        type: Boolean,
        readOnly: true,
        value: false,
        reflectToAttribute: true,
        observer: '_pressedChanged'
      },

      /**
       * If true, the button toggles the active state with each tap or press
       * of the spacebar.
       *
       * @attribute toggles
       * @type boolean
       * @default false
       */
      toggles: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * If true, the button is a toggle and is currently in the active state.
       *
       * @attribute active
       * @type boolean
       * @default false
       */
      active: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        observer: '_activeChanged'
      },

      /**
       * True if the element is currently being pressed by a "pointer," which
       * is loosely defined as mouse or touch input (but specifically excluding
       * keyboard input).
       */
      pointerDown: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      /**
       * True if the input device that caused the element to receive focus
       * was a keyboard.
       */
      receivedFocusFromKeyboard: {
        type: Boolean,
        readOnly: true
      }
    },

    listeners: {
      down: '_downHandler',
      up: '_upHandler',
      tap: '_tapHandler'
    },

    observers: [
      '_detectKeyboardFocus(focused)'
    ],

    keyBindings: {
      'enter:keydown': '_asyncClick',
      'space:keydown': '_spaceKeyDownHandler',
      'space:keyup': '_spaceKeyUpHandler',
    },

    _tapHandler: function() {
      if (this.toggles) {
       // a tap is needed to toggle the active state
        this._userActivate(!this.active);
      } else {
        this.active = false;
      }
    },

    _detectKeyboardFocus: function(focused) {
      this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
    },

    // to emulate native checkbox, (de-)activations from a user interaction fire
    // 'change' events
    _userActivate: function(active) {
      this.active = active;
      this.fire('change');
    },

    _downHandler: function() {
      this._setPointerDown(true);
      this._setPressed(true);
      this._setReceivedFocusFromKeyboard(false);
    },

    _upHandler: function() {
      this._setPointerDown(false);
      this._setPressed(false);
    },

    _spaceKeyDownHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      keyboardEvent.preventDefault();
      keyboardEvent.stopImmediatePropagation();
      this._setPressed(true);
    },

    _spaceKeyUpHandler: function() {
      if (this.pressed) {
        this._asyncClick();
      }
      this._setPressed(false);
    },

    // trigger click asynchronously, the asynchrony is useful to allow one
    // event handler to unwind before triggering another event
    _asyncClick: function() {
      this.async(function() {
        this.click();
      }, 1);
    },

    // any of these changes are considered a change to button state

    _pressedChanged: function(pressed) {
      this._changedButtonState();
    },

    _activeChanged: function(active) {
      if (this.toggles) {
        this.setAttribute('aria-pressed', active ? 'true' : 'false');
      } else {
        this.removeAttribute('aria-pressed');
      }
      this._changedButtonState();
    },

    _controlStateChanged: function() {
      if (this.disabled) {
        this._setPressed(false);
      } else {
        this._changedButtonState();
      }
    },

    // provide hook for follow-on behaviors to react to button-state

    _changedButtonState: function() {
      if (this._buttonStateChanged) {
        this._buttonStateChanged(); // abstract
      }
    }

  };

  /** @polymerBehavior Polymer.IronButtonState */
  Polymer.IronButtonState = [
    Polymer.IronA11yKeysBehavior,
    Polymer.IronButtonStateImpl
  ];

</script>
<script>

  /** @polymerBehavior */
  Polymer.PaperButtonBehaviorImpl = {

    properties: {

      _elevation: {
        type: Number
      }

    },

    observers: [
      '_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)'
    ],

    hostAttributes: {
      role: 'button',
      tabindex: '0'
    },

    _calculateElevation: function() {
      var e = 1;
      if (this.disabled) {
        e = 0;
      } else if (this.active || this.pressed) {
        e = 4;
      } else if (this.receivedFocusFromKeyboard) {
        e = 3;
      }
      this._elevation = e;
    }
  };

  Polymer.PaperButtonBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperButtonBehaviorImpl
  ];

</script>
<script>

  /**
   * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
   *
   * @polymerBehavior Polymer.PaperInkyFocusBehavior
   */
  Polymer.PaperInkyFocusBehaviorImpl = {

    observers: [
      '_focusedChanged(receivedFocusFromKeyboard)'
    ],

    _focusedChanged: function(receivedFocusFromKeyboard) {
      if (!this.$.ink) {
        return;
      }

      this.$.ink.holdDown = receivedFocusFromKeyboard;
    }

  };

  /** @polymerBehavior Polymer.PaperInkyFocusBehavior */
  Polymer.PaperInkyFocusBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperInkyFocusBehaviorImpl
  ];

</script>


<style is="custom-style">
  :root {
    --paper-icon-button-disabled-text: var(--disabled-text-color);
  }
</style>



<style is="custom-style">

  :root {

    /* Material Design color palette for Google products */

    --google-red-100: #f4c7c3;
    --google-red-300: #e67c73;
    --google-red-500: #db4437;
    --google-red-700: #c53929;

    --google-blue-100: #c6dafc;
    --google-blue-300: #7baaf7;
    --google-blue-500: #4285f4;
    --google-blue-700: #3367d6;

    --google-green-100: #b7e1cd;
    --google-green-300: #57bb8a;
    --google-green-500: #0f9d58;
    --google-green-700: #0b8043;

    --google-yellow-100: #fce8b2;
    --google-yellow-300: #f7cb4d;
    --google-yellow-500: #f4b400;
    --google-yellow-700: #f09300;

    --google-grey-100: #f5f5f5;
    --google-grey-300: #e0e0e0;
    --google-grey-500: #9e9e9e;
    --google-grey-700: #616161;
    
    /* Material Design color palette from online spec document */

    --paper-red-50: #ffebee;
    --paper-red-100: #ffcdd2;
    --paper-red-200: #ef9a9a;
    --paper-red-300: #e57373;
    --paper-red-400: #ef5350;
    --paper-red-500: #f44336;
    --paper-red-600: #e53935;
    --paper-red-700: #d32f2f;
    --paper-red-800: #c62828;
    --paper-red-900: #b71c1c;
    --paper-red-a100: #ff8a80;
    --paper-red-a200: #ff5252;
    --paper-red-a400: #ff1744;
    --paper-red-a700: #d50000;
 
    --paper-pink-50: #fce4ec;
    --paper-pink-100: #f8bbd0;
    --paper-pink-200: #f48fb1;
    --paper-pink-300: #f06292;
    --paper-pink-400: #ec407a;
    --paper-pink-500: #e91e63;
    --paper-pink-600: #d81b60;
    --paper-pink-700: #c2185b;
    --paper-pink-800: #ad1457;
    --paper-pink-900: #880e4f;
    --paper-pink-a100: #ff80ab;
    --paper-pink-a200: #ff4081;
    --paper-pink-a400: #f50057;
    --paper-pink-a700: #c51162;
 
    --paper-purple-50: #f3e5f5;
    --paper-purple-100: #e1bee7;
    --paper-purple-200: #ce93d8;
    --paper-purple-300: #ba68c8;
    --paper-purple-400: #ab47bc;
    --paper-purple-500: #9c27b0;
    --paper-purple-600: #8e24aa;
    --paper-purple-700: #7b1fa2;
    --paper-purple-800: #6a1b9a;
    --paper-purple-900: #4a148c;
    --paper-purple-a100: #ea80fc;
    --paper-purple-a200: #e040fb;
    --paper-purple-a400: #d500f9;
    --paper-purple-a700: #aa00ff;
 
    --paper-deep-purple-50: #ede7f6;
    --paper-deep-purple-100: #d1c4e9;
    --paper-deep-purple-200: #b39ddb;
    --paper-deep-purple-300: #9575cd;
    --paper-deep-purple-400: #7e57c2;
    --paper-deep-purple-500: #673ab7;
    --paper-deep-purple-600: #5e35b1;
    --paper-deep-purple-700: #512da8;
    --paper-deep-purple-800: #4527a0;
    --paper-deep-purple-900: #311b92;
    --paper-deep-purple-a100: #b388ff;
    --paper-deep-purple-a200: #7c4dff;
    --paper-deep-purple-a400: #651fff;
    --paper-deep-purple-a700: #6200ea;
 
    --paper-indigo-50: #e8eaf6;
    --paper-indigo-100: #c5cae9;
    --paper-indigo-200: #9fa8da;
    --paper-indigo-300: #7986cb;
    --paper-indigo-400: #5c6bc0;
    --paper-indigo-500: #3f51b5;
    --paper-indigo-600: #3949ab;
    --paper-indigo-700: #303f9f;
    --paper-indigo-800: #283593;
    --paper-indigo-900: #1a237e;
    --paper-indigo-a100: #8c9eff;
    --paper-indigo-a200: #536dfe;
    --paper-indigo-a400: #3d5afe;
    --paper-indigo-a700: #304ffe;
 
    --paper-blue-50: #e3f2fd;
    --paper-blue-100: #bbdefb;
    --paper-blue-200: #90caf9;
    --paper-blue-300: #64b5f6;
    --paper-blue-400: #42a5f5;
    --paper-blue-500: #2196f3;
    --paper-blue-600: #1e88e5;
    --paper-blue-700: #1976d2;
    --paper-blue-800: #1565c0;
    --paper-blue-900: #0d47a1;
    --paper-blue-a100: #82b1ff;
    --paper-blue-a200: #448aff;
    --paper-blue-a400: #2979ff;
    --paper-blue-a700: #2962ff;
 
    --paper-light-blue-50: #e1f5fe;
    --paper-light-blue-100: #b3e5fc;
    --paper-light-blue-200: #81d4fa;
    --paper-light-blue-300: #4fc3f7;
    --paper-light-blue-400: #29b6f6;
    --paper-light-blue-500: #03a9f4;
    --paper-light-blue-600: #039be5;
    --paper-light-blue-700: #0288d1;
    --paper-light-blue-800: #0277bd;
    --paper-light-blue-900: #01579b;
    --paper-light-blue-a100: #80d8ff;
    --paper-light-blue-a200: #40c4ff;
    --paper-light-blue-a400: #00b0ff;
    --paper-light-blue-a700: #0091ea;
 
    --paper-cyan-50: #e0f7fa;
    --paper-cyan-100: #b2ebf2;
    --paper-cyan-200: #80deea;
    --paper-cyan-300: #4dd0e1;
    --paper-cyan-400: #26c6da;
    --paper-cyan-500: #00bcd4;
    --paper-cyan-600: #00acc1;
    --paper-cyan-700: #0097a7;
    --paper-cyan-800: #00838f;
    --paper-cyan-900: #006064;
    --paper-cyan-a100: #84ffff;
    --paper-cyan-a200: #18ffff;
    --paper-cyan-a400: #00e5ff;
    --paper-cyan-a700: #00b8d4;
 
    --paper-teal-50: #e0f2f1;
    --paper-teal-100: #b2dfdb;
    --paper-teal-200: #80cbc4;
    --paper-teal-300: #4db6ac;
    --paper-teal-400: #26a69a;
    --paper-teal-500: #009688;
    --paper-teal-600: #00897b;
    --paper-teal-700: #00796b;
    --paper-teal-800: #00695c;
    --paper-teal-900: #004d40;
    --paper-teal-a100: #a7ffeb;
    --paper-teal-a200: #64ffda;
    --paper-teal-a400: #1de9b6;
    --paper-teal-a700: #00bfa5;
 
    --paper-green-50: #e8f5e9;
    --paper-green-100: #c8e6c9;
    --paper-green-200: #a5d6a7;
    --paper-green-300: #81c784;
    --paper-green-400: #66bb6a;
    --paper-green-500: #4caf50;
    --paper-green-600: #43a047;
    --paper-green-700: #388e3c;
    --paper-green-800: #2e7d32;
    --paper-green-900: #1b5e20;
    --paper-green-a100: #b9f6ca;
    --paper-green-a200: #69f0ae;
    --paper-green-a400: #00e676;
    --paper-green-a700: #00c853;
 
    --paper-light-green-50: #f1f8e9;
    --paper-light-green-100: #dcedc8;
    --paper-light-green-200: #c5e1a5;
    --paper-light-green-300: #aed581;
    --paper-light-green-400: #9ccc65;
    --paper-light-green-500: #8bc34a;
    --paper-light-green-600: #7cb342;
    --paper-light-green-700: #689f38;
    --paper-light-green-800: #558b2f;
    --paper-light-green-900: #33691e;
    --paper-light-green-a100: #ccff90;
    --paper-light-green-a200: #b2ff59;
    --paper-light-green-a400: #76ff03;
    --paper-light-green-a700: #64dd17;
 
    --paper-lime-50: #f9fbe7;
    --paper-lime-100: #f0f4c3;
    --paper-lime-200: #e6ee9c;
    --paper-lime-300: #dce775;
    --paper-lime-400: #d4e157;
    --paper-lime-500: #cddc39;
    --paper-lime-600: #c0ca33;
    --paper-lime-700: #afb42b;
    --paper-lime-800: #9e9d24;
    --paper-lime-900: #827717;
    --paper-lime-a100: #f4ff81;
    --paper-lime-a200: #eeff41;
    --paper-lime-a400: #c6ff00;
    --paper-lime-a700: #aeea00;
 
    --paper-yellow-50: #fffde7;
    --paper-yellow-100: #fff9c4;
    --paper-yellow-200: #fff59d;
    --paper-yellow-300: #fff176;
    --paper-yellow-400: #ffee58;
    --paper-yellow-500: #ffeb3b;
    --paper-yellow-600: #fdd835;
    --paper-yellow-700: #fbc02d;
    --paper-yellow-800: #f9a825;
    --paper-yellow-900: #f57f17;
    --paper-yellow-a100: #ffff8d;
    --paper-yellow-a200: #ffff00;
    --paper-yellow-a400: #ffea00;
    --paper-yellow-a700: #ffd600;
 
    --paper-amber-50: #fff8e1;
    --paper-amber-100: #ffecb3;
    --paper-amber-200: #ffe082;
    --paper-amber-300: #ffd54f;
    --paper-amber-400: #ffca28;
    --paper-amber-500: #ffc107;
    --paper-amber-600: #ffb300;
    --paper-amber-700: #ffa000;
    --paper-amber-800: #ff8f00;
    --paper-amber-900: #ff6f00;
    --paper-amber-a100: #ffe57f;
    --paper-amber-a200: #ffd740;
    --paper-amber-a400: #ffc400;
    --paper-amber-a700: #ffab00;
 
    --paper-orange-50: #fff3e0;
    --paper-orange-100: #ffe0b2;
    --paper-orange-200: #ffcc80;
    --paper-orange-300: #ffb74d;
    --paper-orange-400: #ffa726;
    --paper-orange-500: #ff9800;
    --paper-orange-600: #fb8c00;
    --paper-orange-700: #f57c00;
    --paper-orange-800: #ef6c00;
    --paper-orange-900: #e65100;
    --paper-orange-a100: #ffd180;
    --paper-orange-a200: #ffab40;
    --paper-orange-a400: #ff9100;
    --paper-orange-a700: #ff6500;
 
    --paper-deep-orange-50: #ff5722;
    --paper-deep-orange-100: #fbe9e7;
    --paper-deep-orange-200: #ffccbc;
    --paper-deep-orange-300: #ff8a65;
    --paper-deep-orange-400: #ff7043;
    --paper-deep-orange-500: #ff5722;
    --paper-deep-orange-600: #f4511e;
    --paper-deep-orange-700: #e64a19;
    --paper-deep-orange-800: #d84315;
    --paper-deep-orange-900: #bf360c;
    --paper-deep-orange-a100: #ff9e80;
    --paper-deep-orange-a200: #ff6e40;
    --paper-deep-orange-a400: #ff3d00;
    --paper-deep-orange-a700: #dd2c00;
 
    --paper-brown-50: #efebe9;
    --paper-brown-100: #d7ccc8;
    --paper-brown-200: #bcaaa4;
    --paper-brown-300: #a1887f;
    --paper-brown-400: #8d6e63;
    --paper-brown-500: #795548;
    --paper-brown-600: #6d4c41;
    --paper-brown-700: #5d4037;
    --paper-brown-800: #4e342e;
    --paper-brown-900: #3e2723;
 
    --paper-grey-50: #fafafa;
    --paper-grey-100: #f5f5f5;
    --paper-grey-200: #eeeeee;
    --paper-grey-300: #e0e0e0;
    --paper-grey-400: #bdbdbd;
    --paper-grey-500: #9e9e9e;
    --paper-grey-600: #757575;
    --paper-grey-700: #616161;
    --paper-grey-800: #424242;
    --paper-grey-900: #212121;
 
    --paper-blue-grey-50: #eceff1;
    --paper-blue-grey-100: #cfd8dc;
    --paper-blue-grey-200: #b0bec5;
    --paper-blue-grey-300: #90a4ae;
    --paper-blue-grey-400: #78909c;
    --paper-blue-grey-500: #607d8b;
    --paper-blue-grey-600: #546e7a;
    --paper-blue-grey-700: #455a64;
    --paper-blue-grey-800: #37474f;
    --paper-blue-grey-900: #263238;

    /* opacity for dark text on a light background */
    --dark-divider-opacity: 0.12;
    --dark-disabled-opacity: 0.26; /* or hint text */
    --dark-secondary-opacity: 0.54; /* or icon */
    --dark-primary-opacity: 0.87;

    /* opacity for light text on a dark background */
    --light-divider-opacity: 0.12;
    --light-disabled-opacity: 0.3; /* or hint text */
    --light-secondary-opacity: 0.7; /* or icon */
    --light-primary-opacity: 1.0;

  }

</style>
<style is="custom-style">

  :root {

    --shadow-transition: {
      transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
    };

    /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

    --shadow-elevation-2dp: {
      box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                  0 1px 5px 0 rgba(0, 0, 0, 0.12),
                  0 3px 1px -2px rgba(0, 0, 0, 0.2);
    };

    --shadow-elevation-3dp: {
      box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                  0 1px 8px 0 rgba(0, 0, 0, 0.12),
                  0 3px 3px -2px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-4dp: {
      box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                  0 1px 10px 0 rgba(0, 0, 0, 0.12),
                  0 2px 4px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-6dp: {
      box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                  0 1px 18px 0 rgba(0, 0, 0, 0.12),
                  0 3px 5px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-8dp: {
      box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                  0 3px 14px 2px rgba(0, 0, 0, 0.12),
                  0 5px 5px -3px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-16dp: {
      box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                  0  6px 30px 5px rgba(0, 0, 0, 0.12),
                  0  8px 10px -5px rgba(0, 0, 0, 0.4);
    };

  }

</style>
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,500italic,700,700italic">

<style is="custom-style">

  :root {

    /* Shared Styles */

    /*
    Unfortunately, we can't make use of these yet - sibling properties aren't
    evaluated. See https://github.com/Polymer/polymer/issues/1399

    --paper-font-common-base: {
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-code: {
      font-family: 'Inconsolata', 'Consolas', 'Source Code Pro', 'Monaco', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-expensive-kerning: {
      text-rendering: optimizeLegibility;
    };

    --paper-font-common-nowrap: {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    };
    */

    /* Material Font Styles */

    --paper-font-display4: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 112px;
      font-weight: 300;
      letter-spacing: -.044em;
      line-height: 120px;
    };

    --paper-font-display3: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 56px;
      font-weight: 400;
      letter-spacing: -.026em;
      line-height: 60px;
    };

    --paper-font-display2: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 45px;
      font-weight: 400;
      letter-spacing: -.018em;
      line-height: 48px;
    };

    --paper-font-display1: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 34px;
      font-weight: 400;
      letter-spacing: -.01em;
      line-height: 40px;
    };

    --paper-font-headline: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 24px;
      font-weight: 400;
      letter-spacing: -.012em;
      line-height: 32px;
    };

    --paper-font-title: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 20px;
      font-weight: 500;
      line-height: 28px;
    };

    --paper-font-subhead: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 16px;
      font-weight: 400;
      line-height: 24px;
    };

    --paper-font-body2: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-body1: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 400;
      line-height: 20px;
    };

    --paper-font-caption: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 12px;
      font-weight: 400;
      letter-spacing: 0.011em;
      line-height: 20px;
    };

    --paper-font-menu: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 13px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-button: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.018em;
      line-height: 24px;
      text-transform: uppercase;
    };

    --paper-font-code2: {
      /* @apply(--paper-font-common-code); */
      font-family: 'Inconsolata', 'Consolas', 'Source Code Pro', 'Monaco', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 700;
      line-height: 20px;
    };

    --paper-font-code1: {
      /* @apply(--paper-font-common-code); */
      font-family: 'Inconsolata', 'Consolas', 'Source Code Pro', 'Monaco', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 500;
      line-height: 20px;
    };

  }

</style>




<script>

  /**
   * `Polymer.IronMenuBehavior` implements accessible menu behavior.
   *
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronMenuBehavior
   */
  Polymer.IronMenuBehaviorImpl = {

    properties: {

      /**
       * Returns the currently focused item.
       *
       * @attribute focusedItem
       * @type Object
       */
      focusedItem: {
        observer: '_focusedItemChanged',
        readOnly: true,
        type: Object
      },

      /**
       * The attribute to use on menu items to look up the item title. Typing the first
       * letter of an item when the menu is open focuses that item. If unset, `textContent`
       * will be used.
       *
       * @attribute attrForItemTitle
       * @type String
       */
      attrForItemTitle: {
        type: String
      }
    },

    hostAttributes: {
      'role': 'menu',
      'tabindex': '0'
    },

    observers: [
      '_updateMultiselectable(multi)'
    ],

    listeners: {
      'focus': '_onFocus',
      'keydown': '_onKeydown'
    },

    keyBindings: {
      'up': '_onUpKey',
      'down': '_onDownKey',
      'esc': '_onEscKey',
      'enter': '_onEnterKey',
      'shift+tab:keydown': '_onShiftTabDown'
    },

    _updateMultiselectable: function(multi) {
      if (multi) {
        this.setAttribute('aria-multiselectable', 'true');
      } else {
        this.removeAttribute('aria-multiselectable');
      }
    },

    _onShiftTabDown: function() {
      var oldTabIndex;

      Polymer.IronMenuBehaviorImpl._shiftTabPressed = true;

      oldTabIndex = this.getAttribute('tabindex');

      this.setAttribute('tabindex', '-1');

      this.async(function() {
        this.setAttribute('tabindex', oldTabIndex);
        Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;
      // Note: polymer/polymer#1305
      }, 1);
    },

    _applySelection: function(item, isSelected) {
      if (isSelected) {
        item.setAttribute('aria-selected', 'true');
      } else {
        item.removeAttribute('aria-selected');
      }

      Polymer.IronSelectableBehavior._applySelection.apply(this, arguments);
    },

    _focusedItemChanged: function(focusedItem, old) {
      old && old.setAttribute('tabindex', '-1');
      if (focusedItem) {
        focusedItem.setAttribute('tabindex', '0');
        focusedItem.focus();
      }
    },

    select: function(value) {
      if (this._defaultFocusAsync) {
        this.cancelAsync(this._defaultFocusAsync);
        this._defaultFocusAsync = null;
      }
      var item = this._valueToItem(value);
      this._setFocusedItem(item);
      Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments);
    },

    _onFocus: function(event) {
      if (Polymer.IronMenuBehaviorImpl._shiftTabPressed) {
        return;
      }
      // do not focus the menu itself
      this.blur();
      // clear the cached focus item
      this._setFocusedItem(null);
      this._defaultFocusAsync = this.async(function() {
        // focus the selected item when the menu receives focus, or the first item
        // if no item is selected
        var selectedItem = this.multi ? (this.selectedItems && this.selectedItems[0]) : this.selectedItem;
        if (selectedItem) {
          this._setFocusedItem(selectedItem);
        } else {
          this._setFocusedItem(this.items[0]);
        }
      // async 100ms to wait for `select` to get called from `_itemActivate`
      }, 100);
    },

    _onUpKey: function() {
      // up and down arrows moves the focus
      this._focusPrevious();
    },

    _onDownKey: function() {
      this._focusNext();
    },

    _onEscKey: function() {
      // esc blurs the control
      this.focusedItem.blur();
    },

    _onEnterKey: function(event) {
      // enter activates the item unless it is disabled
      this._activateFocused(event.detail.keyboardEvent);
    },

    _onKeydown: function(event) {
      if (this.keyboardEventMatchesKeys(event, 'up down esc enter')) {
        return;
      }

      // all other keys focus the menu item starting with that character
      this._focusWithKeyboardEvent(event);
    },

    _focusWithKeyboardEvent: function(event) {
      for (var i = 0, item; item = this.items[i]; i++) {
        var attr = this.attrForItemTitle || 'textContent';
        var title = item[attr] || item.getAttribute(attr);
        if (title && title.trim().charAt(0).toLowerCase() === String.fromCharCode(event.keyCode).toLowerCase()) {
          this._setFocusedItem(item);
          break;
        }
      }
    },

    _activateFocused: function(event) {
      if (!this.focusedItem.hasAttribute('disabled')) {
        this._activateHandler(event);
      }
    },

    _focusPrevious: function() {
      var length = this.items.length;
      var index = (Number(this.indexOf(this.focusedItem)) - 1 + length) % length;
      this._setFocusedItem(this.items[index]);
    },

    _focusNext: function() {
      var index = (Number(this.indexOf(this.focusedItem)) + 1) % this.items.length;
      this._setFocusedItem(this.items[index]);
    }

  };

  Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;

  /** @polymerBehavior Polymer.IronMenuBehavior */
  Polymer.IronMenuBehavior = [
    Polymer.IronMultiSelectableBehavior,
    Polymer.IronA11yKeysBehavior,
    Polymer.IronMenuBehaviorImpl
  ];

</script>


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,500italic,700,700italic">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Inconsolata:400,700">


<style>

.paper-font-display4,
.paper-font-display3,
.paper-font-display2,
.paper-font-display1,
.paper-font-headline,
.paper-font-title,
.paper-font-subhead,
.paper-font-body2,
.paper-font-body1,
.paper-font-caption,
.paper-font-menu,
.paper-font-button {
  font-family: 'Roboto', 'Noto', sans-serif;
  -webkit-font-smoothing: antialiased;  /* OS X subpixel AA bleed bug */
}

.paper-font-code2,
.paper-font-code1 {
  font-family: 'Inconsolata', 'Consolas', 'Source Code Pro', 'Monaco', 'Menlo', monospace;
  -webkit-font-smoothing: antialiased;  /* OS X subpixel AA bleed bug */
}

/* Opt for better kerning for headers & other short labels. */
.paper-font-display4,
.paper-font-display3,
.paper-font-display2,
.paper-font-display1,
.paper-font-headline,
.paper-font-title,
.paper-font-subhead,
.paper-font-menu,
.paper-font-button {
  text-rendering: optimizeLegibility;
}

/*
"Line wrapping only applies to Body, Subhead, Headline, and the smaller Display
styles. All other styles should exist as single lines."
*/
.paper-font-display4,
.paper-font-display3,
.paper-font-title,
.paper-font-caption,
.paper-font-menu,
.paper-font-button {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.paper-font-display4 {
  font-size: 112px;
  font-weight: 300;
  letter-spacing: -.044em;
  line-height: 120px;
}

.paper-font-display3 {
  font-size: 56px;
  font-weight: 400;
  letter-spacing: -.026em;
  line-height: 60px;
}

.paper-font-display2 {
  font-size: 45px;
  font-weight: 400;
  letter-spacing: -.018em;
  line-height: 48px;
}

.paper-font-display1 {
  font-size: 34px;
  font-weight: 400;
  letter-spacing: -.01em;
  line-height: 40px;
}

.paper-font-headline {
  font-size: 24px;
  font-weight: 400;
  letter-spacing: -.012em;
  line-height: 32px;
}

.paper-font-title {
  font-size: 20px;
  font-weight: 500;
  line-height: 28px;
}

.paper-font-subhead {
  font-size: 16px;
  font-weight: 400;
  line-height: 24px;
}

.paper-font-body2 {
  font-size: 14px;
  font-weight: 500;
  line-height: 24px;
}

.paper-font-body1 {
  font-size: 14px;
  font-weight: 400;
  line-height: 20px;
}

.paper-font-caption {
  font-size: 12px;
  font-weight: 400;
  letter-spacing: 0.011em;
  line-height: 20px;
}

.paper-font-menu {
  font-size: 13px;
  font-weight: 500;
  line-height: 24px;
}

.paper-font-button {
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 0.018em;
  line-height: 24px;
  text-transform: uppercase;
}

.paper-font-code2 {
  font-size: 14px;
  font-weight: 700;
  line-height: 20px;
}

.paper-font-code1 {
  font-size: 14px;
  font-weight: 700;
  line-height: 20px;
}

</style>
<style>
.shadow-transition {
  transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
}

.shadow-elevation-1 {
  box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.37);
}

.shadow-elevation-2 {
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.2),
              0 6px 10px 0 rgba(0, 0, 0, 0.3);
}

.shadow-elevation-3 {
  box-shadow: 0 11px 7px 0 rgba(0, 0, 0, 0.19),
              0 13px 25px 0 rgba(0, 0, 0, 0.3);
}

.shadow-elevation-4 {
  box-shadow: 0 14px 12px 0 rgba(0, 0, 0, 0.17),
              0 20px 40px 0 rgba(0, 0, 0, 0.3);
}

.shadow-elevation-5 {
  box-shadow: 0 17px 17px 0 rgba(0, 0, 0, 0.15),
              0 27px 55px 0 rgba(0, 0, 0, 0.3);
}
</style>











<script>

  /**
   * `Polymer.IronMenubarBehavior` implements accessible menubar behavior.
   *
   * @polymerBehavior Polymer.IronMenubarBehavior
   */
  Polymer.IronMenubarBehaviorImpl = {

    hostAttributes: {
      'role': 'menubar'
    },

    keyBindings: {
      'left': '_onLeftKey',
      'right': '_onRightKey'
    },

    _onUpKey: function(event) {
      this._activateFocused(event.detail.keyboardEvent);
    },

    _onDownKey: function(event) {
      this._activateFocused(event.detail.keyboardEvent);
    },

    _onLeftKey: function() {
      this._focusPrevious();
    },

    _onRightKey: function() {
      this._focusNext();
    },

    _onKeydown: function(event) {
      if (this.keyboardEventMatchesKeys(event, 'up down left right esc enter')) {
        return;
      }

      // all other keys focus the menu item starting with that character
      this._focusWithKeyboardEvent(event);
    }

  };

  /** @polymerBehavior Polymer.IronMenubarBehavior */
  Polymer.IronMenubarBehavior = [
    Polymer.IronMenuBehavior,
    Polymer.IronMenubarBehaviorImpl
  ];

</script>




<script>

  /**
   * Use `Polymer.IronValidatableBehavior` to implement an element that validates user input.
   *
   * ### Accessiblity
   *
   * Changing the `invalid` property, either manually or by calling `validate()` will update the
   * `aria-invalid` attribute.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronValidatableBehavior = {

    properties: {

      /**
       * Namespace for this validator.
       */
      validatorType: {
        type: String,
        value: 'validator'
      },

      /**
       * Name of the validator to use.
       */
      validator: {
        type: String
      },

      /**
       * True if the last call to `validate` is invalid.
       */
      invalid: {
        notify: true,
        reflectToAttribute: true,
        type: Boolean,
        value: false
      },

      _validatorMeta: {
        type: Object
      }

    },

    observers: [
      '_invalidChanged(invalid)'
    ],

    get _validator() {
      return this._validatorMeta && this._validatorMeta.byKey(this.validator);
    },

    ready: function() {
      this._validatorMeta = new Polymer.IronMeta({type: this.validatorType});
    },

    _invalidChanged: function() {
      if (this.invalid) {
        this.setAttribute('aria-invalid', 'true');
      } else {
        this.removeAttribute('aria-invalid');
      }
    },

    /**
     * @return {boolean} True if the validator `validator` exists.
     */
    hasValidator: function() {
      return this._validator != null;
    },

    /**
     * @param {Object} values Passed to the validator's `validate()` function.
     * @return {boolean} True if `values` is valid.
     */
    validate: function(values) {
      var valid = this._validator && this._validator.validate(values);
      this.invalid = !valid;
      return valid;
    }

  };

</script>
<script>

/*
`<iron-input>` adds two-way binding and custom validators using `Polymer.IronValidatorBehavior`
to `<input>`.

### Two-way binding

By default you can only get notified of changes to an `input`'s `value` due to user input:

    <input value="{{myValue::input}}">

`iron-input` adds the `bind-value` property that mirrors the `value` property, and can be used
for two-way data binding. `bind-value` will notify if it is changed either by user input or by script.

    <input is="iron-input" bind-value="{{myValue}}">

### Custom validators

You can use custom validators that implement `Polymer.IronValidatorBehavior` with `<iron-input>`.

    <input is="iron-input" validator="my-custom-validator">

### Stopping invalid input

It may be desirable to only allow users to enter certain characters. You can use the
`prevent-invalid-input` and `allowed-pattern` attributes together to accomplish this. This feature
is separate from validation, and `allowed-pattern` does not affect how the input is validated.

    <!-- only allow characters that match [0-9] -->
    <input is="iron-input" prevent-invaild-input allowed-pattern="[0-9]">

@hero hero.svg
@demo demo/index.html
*/

  Polymer({

    is: 'iron-input',

    extends: 'input',

    behaviors: [
      Polymer.IronValidatableBehavior
    ],

    properties: {

      /**
       * Use this property instead of `value` for two-way data binding.
       */
      bindValue: {
        observer: '_bindValueChanged',
        type: String
      },

      /**
       * Set to true to prevent the user from entering invalid input. The new input characters are
       * matched with `allowedPattern` if it is set, otherwise it will use the `pattern` attribute if
       * set, or the `type` attribute (only supported for `type=number`).
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Regular expression to match valid input characters.
       */
      allowedPattern: {
        type: String
      },

      _previousValidInput: {
        type: String,
        value: ''
      },

      _patternAlreadyChecked: {
        type: Boolean,
        value: false
      }

    },

    listeners: {
      'input': '_onInput',
      'keypress': '_onKeypress'
    },

    get _patternRegExp() {
      var pattern;
      if (this.allowedPattern) {
        pattern = new RegExp(this.allowedPattern);
      } else if (this.pattern) {
        pattern = new RegExp(this.pattern);
      } else {
        switch (this.type) {
          case 'number':
            pattern = /[0-9.,e-]/;
            break;
        }
      }
      return pattern;
    },

    ready: function() {
      this.bindValue = this.value;
    },

    _bindValueChanged: function() {
      if (this.value !== this.bindValue) {
        this.value = !this.bindValue ? '' : this.bindValue;
      }
      // manually notify because we don't want to notify until after setting value
      this.fire('bind-value-changed', {value: this.bindValue});
    },

    _onInput: function() {
      // Need to validate each of the characters pasted if they haven't
      // been validated inside `_onKeypress` already.
      if (this.preventInvalidInput && !this._patternAlreadyChecked) {
        var valid = this._checkPatternValidity();
        if (!valid) {
          this.value = this._previousValidInput;
        }
      }

      this.bindValue = this.value;
      this._previousValidInput = this.value;
      this._patternAlreadyChecked = false;
    },

    _isPrintable: function(event) {
      // What a control/printable character is varies wildly based on the browser.
      // - most control characters (arrows, backspace) do not send a `keypress` event
      //   in Chrome, but the *do* on Firefox
      // - in Firefox, when they do send a `keypress` event, control chars have
      //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
      // - printable characters always send a keypress event.
      // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
      //   always matches the charCode.
      // None of this makes any sense.

      var nonPrintable =
        (event.keyCode == 8)   ||  // backspace
        (event.keyCode == 19)  ||  // pause
        (event.keyCode == 20)  ||  // caps lock
        (event.keyCode == 27)  ||  // escape
        (event.keyCode == 45)  ||  // insert
        (event.keyCode == 46)  ||  // delete
        (event.keyCode == 144) ||  // num lock
        (event.keyCode == 145) ||  // scroll lock
        (event.keyCode > 32 && event.keyCode < 41)   || // page up/down, end, home, arrows
        (event.keyCode > 111 && event.keyCode < 124); // fn keys

      return !(event.charCode == 0 && nonPrintable);
    },

    _onKeypress: function(event) {
      if (!this.preventInvalidInput && this.type !== 'number') {
        return;
      }
      var regexp = this._patternRegExp;
      if (!regexp) {
        return;
      }

      // Handle special keys and backspace
      if (event.metaKey || event.ctrlKey || event.altKey)
        return;

      // Check the pattern either here or in `_onInput`, but not in both.
      this._patternAlreadyChecked = true;

      var thisChar = String.fromCharCode(event.charCode);
      if (this._isPrintable(event) && !regexp.test(thisChar)) {
        event.preventDefault();
      }
    },

    _checkPatternValidity: function() {
      var regexp = this._patternRegExp;
      if (!regexp) {
        return true;
      }
      for (var i = 0; i < this.value.length; i++) {
        if (!regexp.test(this.value[i])) {
          return false;
        }
      }
      return true;
    },

    /**
     * Returns true if `value` is valid. The validator provided in `validator` will be used first,
     * then any constraints.
     * @return {Boolean} True if the value is valid.
     */
    validate: function() {
      // Empty, non-required input is valid.
      if (!this.required && this.value == '')
        return true;

      var valid;
      if (this.hasValidator()) {
        valid = Polymer.IronValidatableBehavior.validate.call(this, this.value);
      } else {
        this.invalid = !this.validity.valid;
        valid = this.validity.valid;
      }
      this.fire('iron-input-validate');
      return valid;
    }

  });

  /*
  The `iron-input-validate` event is fired whenever `validate()` is called.
  @event iron-input-validate
  */

</script>

<script>

  /** 
  
  @demo demo/index.html
  @polymerBehavior 
  
  */
  Polymer.IronFormElementBehavior = {

    properties: {

      /**
       * The name of this element.
       */
      name: {
        type: String
      },

      /**
       * The value for this element.
       */
      value: {
        notify: true,
        type: String
      },
    },

    attached: function() {
      this.fire('iron-form-element-register');
    }

  };

</script>
<script>

  /**
   * Use `Polymer.PaperInputBehavior` to implement inputs with `<paper-input-container>`. This
   * behavior is implemented by `<paper-input>`. It exposes a number of properties from
   * `<paper-input-container>` and `<input is="iron-input">` and they should be bound in your
   * template.
   *
   * The input element can be accessed by the `inputElement` property if you need to access
   * properties or methods that are not exposed.
   * @polymerBehavior
   */
  Polymer.PaperInputBehavior = {

    properties: {

      /**
       * The label for this input. Bind this to `<paper-input-container>`'s `label` property.
       */
      label: {
        type: String
      },

      /**
       * The value for this input. Bind this to the `<input is="iron-input">`'s `bindValue`
       * property, or the value property of your input that is `notify:true`.
       */
      value: {
        notify: true,
        type: String
      },

      /**
       * Set to true to disable this input. Bind this to both the `<paper-input-container>`'s
       * and the input's `disabled` property.
       */
      disabled: {
        type: Boolean,
        value: false
      },

      /**
       * Returns true if the value is invalid. Bind this to both the `<paper-input-container>`'s
       * and the input's `invalid` property.
       */
      invalid: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to prevent the user from entering invalid input. Bind this to the
       * `<input is="iron-input">`'s `preventInvalidInput` property.
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Set this to specify the pattern allowed by `preventInvalidInput`. Bind this to the
       * `<input is="iron-input">`'s `allowedPattern` property.
       */
      allowedPattern: {
        type: String
      },

      /**
       * The type of the input. The supported types are `text`, `number` and `password`. Bind this
       * to the `<input is="iron-input">`'s `type` property.
       */
      type: {
        type: String
      },

      /**
       * A pattern to validate the `input` with. Bind this to the `<input is="iron-input">`'s
       * `pattern` property.
       */
      pattern: {
        type: String
      },

      /**
       * Set to true to mark the input as required. Bind this to the `<input is="iron-input">`'s
       * `required` property.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * The maximum length of the input value. Bind this to the `<input is="iron-input">`'s
       * `maxlength` property.
       */
      maxlength: {
        type: Number
      },

      /**
       * The error message to display when the input is invalid. Bind this to the
       * `<paper-input-error>`'s content, if using.
       */
      errorMessage: {
        type: String
      },

      /**
       * Set to true to show a character counter.
       */
      charCounter: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable the floating label. Bind this to the `<paper-input-container>`'s
       * `noLabelFloat` property.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the label. Bind this to the `<paper-input-container>`'s
       * `alwaysFloatLabel` property.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to auto-validate the input value. Bind this to the `<paper-input-container>`'s
       * `autoValidate` property.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * Name of the validator to use. Bind this to the `<input is="iron-input">`'s `validator`
       * property.
       */
      validator: {
        type: String
      },

      // HTMLInputElement attributes for binding if needed

      /**
       * Bind this to the `<input is="iron-input">`'s `autocomplete` property.
       */
      autocomplete: {
        type: String,
        value: 'off'
      },

      /**
       * Bind this to the `<input is="iron-input">`'s `autofocus` property.
       */
      autofocus: {
        type: Boolean
      },

      /**
       * Bind this to the `<input is="iron-input">`'s `inputmode` property.
       */
      inputmode: {
        type: String
      },

      /**
       * Bind this to the `<input is="iron-input">`'s `minlength` property.
       */
      minlength: {
        type: Number
      },

      /**
       * Bind this to the `<input is="iron-input">`'s `name` property.
       */
      name: {
        type: String
      },

      /**
       * A placeholder string in addition to the label. If this is set, the label will always float.
       */
      placeholder: {
        type: String,
        // need to set a default so _computeAlwaysFloatLabel is run
        value: ''
      },

      /**
       * Bind this to the `<input is="iron-input">`'s `readonly` property.
       */
      readonly: {
        type: Boolean,
        value: false
      },

      /**
       * Bind this to the `<input is="iron-input">`'s `size` property.
       */
      size: {
        type: Number
      },

      _ariaDescribedBy: {
        type: String,
        value: ''
      }

    },

    listeners: {
      'addon-attached': '_onAddonAttached'
    },

    /**
     * Returns a reference to the input element.
     */
    get inputElement() {
      return this.$.input;
    },

    attached: function() {
      this._updateAriaLabelledBy();
    },

    _appendStringWithSpace: function(str, more) {
      if (str) {
        str = str + ' ' + more;
      } else {
        str = more;
      }
      return str;
    },

    _onAddonAttached: function(event) {
      var target = event.path ? event.path[0] : event.target;
      if (target.id) {
        this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
      } else {
        var id = 'paper-input-add-on-' + Math.floor((Math.random() * 100000));
        target.id = id;
        this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
      }
    },

    /**
     * Validates the input element and sets an error style if needed.
     */
     validate: function() {
       return this.inputElement.validate();
     },

    /**
     * Restores the cursor to its original position after updating the value.
     * @param {String} newValue The value that should be saved.
     */
    updateValueAndPreserveCaret: function(newValue) {
      // Not all elements might have selection, and even if they have the
      // right properties, accessing them might throw an exception (like for
      // <input type=number>)
      try {
        var start = this.inputElement.selectionStart;
        this.value = newValue;

        // The cursor automatically jumps to the end after re-setting the value,
        // so restore it to its original position.
        this.inputElement.selectionStart = start;
        this.inputElement.selectionEnd = start;
      } catch (e) {
        // Just set the value and give up on the caret.
        this.value = newValue;
      }
    },

    _computeAlwaysFloatLabel: function(alwaysFloatLabel, placeholder) {
      return placeholder || alwaysFloatLabel;
    },

    _updateAriaLabelledBy: function() {
      var label = Polymer.dom(this.root).querySelector('label');
      if (!label) {
        this._ariaLabelledBy = '';
        return;
      }
      var labelledBy;
      if (label.id) {
        labelledBy = label.id;
      } else {
        labelledBy = 'paper-input-label-' + new Date().getUTCMilliseconds();
        label.id = labelledBy;
      }
      this._ariaLabelledBy = labelledBy;
    }

  };

</script>

<script>

  /**
   * Use `Polymer.PaperInputAddonBehavior` to implement an add-on for `<paper-input-container>`. A
   * add-on appears below the input, and may display information based on the input value and
   * validity such as a character counter or an error message.
   * @polymerBehavior
   */
  Polymer.PaperInputAddonBehavior = {

    hostAttributes: {
      'add-on': ''
    },

    attached: function() {
      this.fire('addon-attached');
    },

    /**
     * The function called by `<paper-input-container>` when the input value or validity changes.
     * @param {{
     *   inputElement: (Node|undefined),
     *   value: (string|undefined),
     *   invalid: (boolean|undefined)
     * }} state All properties are optional -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
    }

  };

</script>





<style is="custom-style">
  :root {
    --paper-toggle-button-unchecked-bar-color: #000000;
    --paper-toggle-button-unchecked-button-color: var(--paper-grey-50);
    --paper-toggle-button-unchecked-ink-color: var(--primary-text-color);

    --paper-toggle-button-checked-bar-color: var(--google-green-500);
    --paper-toggle-button-checked-button-color: var(--google-green-500);
    --paper-toggle-button-checked-ink-color: var(--google-green-500);
  }
</style>

<script>

  /**
   * Use `Polymer.NeonAnimationBehavior` to implement an animation.
   * @polymerBehavior
   */
  Polymer.NeonAnimationBehavior = {

    properties: {

      /**
       * Defines the animation timing.
       */
      animationTiming: {
        type: Object,
        value: function() {
          return {
            duration: 500,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
            fill: 'both'
          }
        }
      }

    },

    registered: function() {
      new Polymer.IronMeta({type: 'animation', key: this.is, value: this.constructor});
    },

    /**
     * Do any animation configuration here.
     */
    // configure: function(config) {
    // },

    /**
     * Returns the animation timing by mixing in properties from `config` to the defaults defined
     * by the animation.
     */
    timingFromConfig: function(config) {
      if (config.timing) {
        for (var property in config.timing) {
          this.animationTiming[property] = config.timing[property];
        }
      }
      return this.animationTiming;
    },

    /**
     * Sets `transform` and `transformOrigin` properties along with the prefixed versions.
     */
    setPrefixedProperty: function(node, property, value) {
      var map = {
        'transform': ['webkitTransform'],
        'transformOrigin': ['mozTransformOrigin', 'webkitTransformOrigin']
      };
      var prefixes = map[property];
      for (var prefix, index = 0; prefix = prefixes[index]; index++) {
        node.style[prefix] = value;
      }
      node.style[property] = value;
    },

    /**
     * Called when the animation finishes.
     */
    complete: function() {
      // FIXME not sure about non-bubbling event
      this.fire(this.animationEndEvent, null, {bubbles: false});
    }

  };

</script>
<script>// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){b["true"]=a;var c={},d={},e={},f=null;!function(a){function b(b,c){var d={delay:0,endDelay:0,fill:c?"both":"none",iterationStart:0,iterations:1,duration:c?"auto":0,playbackRate:1,direction:"normal",easing:"linear"};return"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof d[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&-1==p.indexOf(b[c]))return;if("direction"==c&&-1==q.indexOf(b[c]))return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;d[c]=b[c]}}):d.duration=b,d}function c(a,c){var d=b(a,c);return d.easing=f(d.easing),d}function d(a,b,c,d){return 0>a||a>1||0>c||c>1?y:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}for(var g=0,h=1;;){var i=(g+h)/2,j=f(a,c,i);if(Math.abs(e-j)<.001)return f(b,d,i);e>j?g=i:h=i}}}function e(a,b){return function(c){if(c>=1)return 1;var d=1/a;return c+=b*d,c-c%d}}function f(a){var b=w.exec(a);if(b)return d.apply(this,b.slice(1).map(Number));var c=x.exec(a);if(c)return e(Number(c[1]),{start:r,middle:s,end:t}[c[2]]);var f=u[a];return f?f:y}function g(a){return Math.abs(h(a)/a.playbackRate)}function h(a){return a.duration*a.iterations}function i(a,b,c){return null==b?z:b<c.delay?A:b>=c.delay+a?B:C}function j(a,b,c,d,e){switch(d){case A:return"backwards"==b||"both"==b?0:null;case C:return c-e;case B:return"forwards"==b||"both"==b?a:null;case z:return null}}function k(a,b,c,d){return(d.playbackRate<0?b-a:b)*d.playbackRate+c}function l(a,b,c,d,e){return 1/0===c||c===-1/0||c-d==b&&e.iterations&&(e.iterations+e.iterationStart)%1==0?a:c%a}function m(a,b,c,d){return 0===c?0:b==a?d.iterationStart+d.iterations-1:Math.floor(c/a)}function n(a,b,c,d){var e=a%2>=1,f="normal"==d.direction||d.direction==(e?"alternate-reverse":"alternate"),g=f?c:b-c,h=g/b;return b*d.easing(h)}function o(a,b,c){var d=i(a,b,c),e=j(a,c.fill,b,d,c.delay);if(null===e)return null;if(0===a)return d===A?0:1;var f=c.iterationStart*c.duration,g=k(a,e,f,c),o=l(c.duration,h(c),g,f,c),p=m(c.duration,o,g,c);return n(p,c.duration,o,c)/c.duration}var p="backwards|forwards|both|none".split("|"),q="reverse|alternate|alternate-reverse".split("|"),r=1,s=.5,t=0,u={ease:d(.25,.1,.25,1),"ease-in":d(.42,0,1,1),"ease-out":d(0,0,.58,1),"ease-in-out":d(.42,0,.58,1),"step-start":e(1,r),"step-middle":e(1,s),"step-end":e(1,t)},v="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",w=new RegExp("cubic-bezier\\("+v+","+v+","+v+","+v+"\\)"),x=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,y=function(a){return a},z=0,A=1,B=2,C=3;a.makeTiming=b,a.normalizeTimingInput=c,a.calculateActiveDuration=g,a.calculateTimeFraction=o,a.calculatePhase=i,a.toTimingFunction=f}(c,f),function(a){function b(a,b){return a in h?h[a][b]||b:b}function c(a,c,d){var g=e[a];if(g){f.style[a]=c;for(var h in g){var i=g[h],j=f.style[i];d[i]=b(i,j)}}else d[a]=b(a,c)}function d(b){function d(){var a=e.length;null==e[a-1].offset&&(e[a-1].offset=1),a>1&&null==e[0].offset&&(e[0].offset=0);for(var b=0,c=e[0].offset,d=1;a>d;d++){var f=e[d].offset;if(null!=f){for(var g=1;d-b>g;g++)e[b+g].offset=c+(f-c)*g/(d-b);b=d,c=f}}}if(!Array.isArray(b)&&null!==b)throw new TypeError("Keyframes must be null or an array of keyframes");if(null==b)return[];for(var e=b.map(function(b){var d={};for(var e in b){var f=b[e];if("offset"==e){if(null!=f&&(f=Number(f),!isFinite(f)))throw new TypeError("keyframe offsets must be numbers.")}else{if("composite"==e)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};f="easing"==e?a.toTimingFunction(f):""+f}c(e,f,d)}return void 0==d.offset&&(d.offset=null),void 0==d.easing&&(d.easing=a.toTimingFunction("linear")),d}),f=!0,g=-1/0,h=0;h<e.length;h++){var i=e[h].offset;if(null!=i){if(g>i)throw{code:DOMException.INVALID_MODIFICATION_ERR,name:"InvalidModificationError",message:"Keyframes are not loosely sorted by offset. Sort or specify offsets."};g=i}else f=!1}return e=e.filter(function(a){return a.offset>=0&&a.offset<=1}),f||d(),e}var e={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},f=document.createElementNS("http://www.w3.org/1999/xhtml","div"),g={thin:"1px",medium:"3px",thick:"5px"},h={borderBottomWidth:g,borderLeftWidth:g,borderRightWidth:g,borderTopWidth:g,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:g,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.normalizeKeyframes=d}(c,f),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),h>g?(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,!1):!0},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(c),function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}!function(a,b){function c(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function d(a){var c=[];for(var d in a)for(var e=a[d],f=0;f<e.length-1;f++){var g=e[f].offset,h=e[f+1].offset,i=e[f].value,j=e[f+1].value;g==h&&(1==h?i=j:j=i),c.push({startTime:g,endTime:h,easing:e[f].easing,property:d,interpolation:b.propertyInterpolation(d,i,j)})}return c.sort(function(a,b){return a.startTime-b.startTime}),c}b.convertEffectInput=function(e){var f=a.normalizeKeyframes(e),g=c(f),h=d(g);return function(a,c){if(null!=c)h.filter(function(a){return 0>=c&&0==a.startTime||c>=1&&1==a.endTime||c>=a.startTime&&c<=a.endTime}).forEach(function(d){var e=c-d.startTime,f=d.endTime-d.startTime,g=0==f?0:d.easing(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(c,d,f),function(a){function b(a,b,c){e[c]=e[c]||[],e[c].push([a,b])}function c(a,c,d){for(var e=0;e<d.length;e++){var f=d[e];b(a,c,f),/-/.test(f)&&b(a,c,f.replace(/-(.)/g,function(a,b){return b.toUpperCase()}))}}function d(b,c,d){for(var f=c==d?[]:e[b],g=0;f&&g<f.length;g++){var h=f[g][0](c),i=f[g][0](d);if(void 0!==h&&void 0!==i){var j=f[g][1](h,i);if(j){var k=a.Interpolation.apply(null,j);return function(a){return 0==a?c:1==a?d:k(a)}}}}return a.Interpolation(!1,!0,function(a){return a?d:c})}var e={};a.addPropertiesHandler=c,a.propertyInterpolation=d}(d,f),function(a,b){function c(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateTimeFraction(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d._isCurrent=function(d){var e=a.calculatePhase(c,d,b);return e===PhaseActive||e===PhaseBefore},d}b.KeyframeEffect=function(d,e,f){var g,h=c(a.normalizeTimingInput(f)),i=b.convertEffectInput(e),j=function(){i(d,g)};return j._update=function(a){return g=h(a),null!==g},j._clear=function(){i(d,null)},j._hasSameTarget=function(a){return d===a},j._isCurrent=h._isCurrent,j._totalDuration=h._totalDuration,j},b.NullEffect=function(a){var b=function(){a&&(a(),a=null)};return b._update=function(){return null},b._totalDuration=0,b._isCurrent=function(){return!1},b._hasSameTarget=function(){return!1},b}}(c,d,f),function(a){a.apply=function(b,c,d){b.style[a.propertyName(c)]=d},a.clear=function(b,c){b.style[a.propertyName(c)]=""}}(d,f),function(a){window.Element.prototype.animate=function(b,c){return a.timeline._play(a.KeyframeEffect(this,b,c))}}(d),function(a){function b(a,c,d){if("number"==typeof a&&"number"==typeof c)return a*(1-d)+c*d;if("boolean"==typeof a&&"boolean"==typeof c)return.5>d?a:c;if(a.length==c.length){for(var e=[],f=0;f<a.length;f++)e.push(b(a[f],c[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+c}a.Interpolation=function(a,c,d){return function(e){return d(b(a,c,e))}}}(d,f),function(a){var b=0,c=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};a.Animation=function(a){this._sequenceNumber=b++,this._currentTime=0,this._startTime=null,this.paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!1,this.onfinish=null,this._finishHandlers=[],this._effect=a,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},a.Animation.prototype={_ensureAlive:function(){this._inEffect=this._effect._update(this.playbackRate<0&&0===this.currentTime?-1:this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,a.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this.finished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(b){b=+b,isNaN(b)||(a.restart(),this.paused||null==this._startTime||(this._startTime=this._timeline.currentTime-b/this._playbackRate),this._currentTimePending=!1,this._currentTime!=b&&(this._tickCurrentTime(b,!0),a.invalidateEffects()))},get startTime(){return this._startTime},set startTime(b){b=+b,isNaN(b)||this.paused||this._idle||(this._startTime=b,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),a.invalidateEffects())},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var b=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&this.play(),null!=b&&(this.currentTime=b)}},get finished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this.paused&&0!=this.playbackRate||this._currentTimePending?"pending":this.paused?"paused":this.finished?"finished":"running"},play:function(){this.paused=!1,(this.finished||this._idle)&&(this._currentTime=this._playbackRate>0?0:this._totalDuration,this._startTime=null,a.invalidateEffects()),this._finishedFlag=!1,a.restart(),this._idle=!1,this._ensureAlive()},pause:function(){this.finished||this.paused||this._idle||(this._currentTimePending=!0),this._startTime=null,this.paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1)},cancel:function(){this._inEffect=!1,this._idle=!0,this.currentTime=0,this._startTime=null},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){var b=this.finished;if((b||this._idle)&&!this._finishedFlag){var d=new c(this,this._currentTime,a),e=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){e.forEach(function(a){a.call(d.target,d)})},0)}this._finishedFlag=b},_tick:function(a){return this._idle||this.paused||(null==this._startTime?this.startTime=a-this._currentTime/this.playbackRate:this.finished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),this._currentTimePending=!1,this._fireEvents(a),!this._idle&&(this._inEffect||!this._finishedFlag)}}}(d,f),function(a,b){function c(a){var b=i;i=[],g(a),b.forEach(function(b){b[1](a)}),m&&g(a),f()}function d(a,b){return a._sequenceNumber-b._sequenceNumber}function e(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function f(){n.forEach(function(a){a()}),n.length=0}function g(a){l=!1;var c=b.timeline;c.currentTime=a,c._animations.sort(d),k=!1;var e=c._animations;c._animations=[];var f=[],g=[];e=e.filter(function(b){return b._inTimeline=b._tick(a),b._inEffect?g.push(b._effect):f.push(b._effect),b.finished||b.paused||b._idle||(k=!0),b._inTimeline}),n.push.apply(n,f),n.push.apply(n,g),c._animations.push.apply(c._animations,e),m=!1,k&&requestAnimationFrame(function(){})}var h=window.requestAnimationFrame,i=[],j=0;window.requestAnimationFrame=function(a){var b=j++;return 0==i.length&&h(c),i.push([b,a]),b},window.cancelAnimationFrame=function(a){i.forEach(function(b){b[0]==a&&(b[1]=function(){})})},e.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.invalidateEffects(),d}};var k=!1,l=!1;b.restart=function(){return k||(k=!0,requestAnimationFrame(function(){}),l=!0),l};var m=!1;b.invalidateEffects=function(){m=!0};var n=[],o=window.getComputedStyle;Object.defineProperty(window,"getComputedStyle",{configurable:!0,enumerable:!0,value:function(){return m&&g(p.currentTime),f(),o.apply(this,arguments)}});var p=new e;b.timeline=p}(c,d,f),function(a){function b(a,b){var c=a.exec(b);return c?(c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]):void 0}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);return c?[c[0],c[1].replace(/^\s*/,"")]:void 0}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],g=b(d,e),!g||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,0>=c))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){var d=a(c);return d?d:[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}return""==c?d:void 0}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;j>k;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);return e&&e[0].length?[d,e[1]]:void 0}function c(c){var d=a.consumeRepeated(b,/^,/,c);return d&&""==d[1]?d[0]:void 0}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2]}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a){function b(a){return a.toFixed(3).replace(".000","")}function c(a,b,c){return Math.min(b,Math.max(a,c))}function d(a){return/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a)?Number(a):void 0}function e(a,c){return[a,c,b]}function f(a,b){return 0!=a?h(0,1/0)(a,b):void 0}function g(a,b){return[a,b,function(a){return Math.round(c(1,1/0,a))}]}function h(a,d){return function(e,f){return[e,f,function(e){return b(c(a,d,e))}]}}function i(a,b){return[a,b,Math.round]}a.clamp=c,a.addPropertiesHandler(d,h(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(d,h(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(d,f,["flex-grow","flex-shrink"]),a.addPropertiesHandler(d,g,["orphans","widows"]),a.addPropertiesHandler(d,i,["z-index"]),a.parseNumber=d,a.mergeNumbers=e,a.numberToString=b}(d,f),function(a){function b(a,b){return"visible"==a||"visible"==b?[0,1,function(c){return 0>=c?a:c>=1?b:"visible"}]:void 0}a.addPropertiesHandler(String,b,["visibility"])}(d),function(a){function b(a){a=a.trim(),e.fillStyle="#000",e.fillStyle=a;var b=e.fillStyle;if(e.fillStyle="#fff",e.fillStyle=a,b==e.fillStyle){e.fillRect(0,0,1,1);var c=e.getImageData(0,0,1,1).data;e.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function c(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;3>d;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var d=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");d.width=d.height=1;var e=d.getContext("2d");a.addPropertiesHandler(b,c,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","outline-color","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,b),a.mergeColors=c}(d,f),function(a,b){function c(a,b){if(b=b.trim().toLowerCase(),"0"==b&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(a){return c[a]=null,"U"+a});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(a,b){return e(a,b,!0)}function e(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(a){var b=l(a);return b&&""==b[1]?b[0]:void 0},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","text-indent","top","vertical-align","word-spacing"])}(d,f),function(a){function b(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function c(c){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,b,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],c);return d&&4==d[0].length?d[0]:void 0}function d(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function e(a){return"rect("+a+")"}var f=a.mergeWrappedNestedRepeated.bind(null,e,d,", ");a.parseBox=c,a.mergeBoxes=f,a.addPropertiesHandler(c,f,["clip"])}(d,f),function(a){function b(a){return function(b){var c=0;return a.map(function(a){return a===j?b[c++]:a})}}function c(a){return a}function d(b){if(b=b.toLowerCase().trim(),"none"==b)return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=m[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var n=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(p=q?{A:function(b){return"0"==b.trim()?l:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:l,n:n[0],t:k}[r],void 0===p)return;n.push(p)}if(e.push({t:g,d:n}),d.lastIndex==b.length)return e}}function e(a){return a.toFixed(6).replace(".000000","")}function f(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var f=a.makeMatrixDecomposition(c)}return null==d[0]||null==f[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),f[0].push(1),[d,f,function(b){var c=a.quat(d[0][3],f[0][3],b[5]),g=a.composeMatrix(b[0],b[1],b[2],c,b[4]),h=g.map(e).join(",");return h}])}function g(a){return a.replace(/[xy]/,"")}function h(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function i(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var i=0;i<b.length;i++){var j=b[i].t,k=b[i].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var n=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=f(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var i=0;i<b.length;i++){var j,s=b[i].t,t=c[i].t,u=b[i].d,v=c[i].d,w=m[s],x=m[t];if(n(s,t)){if(!d)return;var r=f([b[i]],[c[i]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&g(s)==g(t))j=g(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||h(s)!=h(t)){if(!d)return;var r=f(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=h(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var j=null,k={px:0},l={deg:0},m={matrix:["NNNNNN",[j,j,0,0,j,j,0,0,0,0,1,0,j,j,0,1],c],matrix3d:["NNNNNNNNNNNNNNNN",c],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",b([j,j,1]),c],scalex:["N",b([j,1,1]),b([j,1])],scaley:["N",b([1,j,1]),b([1,j])],scalez:["N",b([1,1,j])],scale3d:["NNN",c],skew:["Aa",null,c],skewx:["A",null,b([j,l])],skewy:["A",null,b([l,j])],translate:["Tt",b([j,j,k]),c],translatex:["T",b([j,k,k]),b([j,k])],translatey:["T",b([k,j,k]),b([k,j])],translatez:["L",b([k,k,j])],translate3d:["TTL",c]};a.addPropertiesHandler(d,i,["transform"])}(d,f),function(a){function b(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(c[a]=b)})}var c={};b("transform",["webkitTransform","msTransform"]),b("transformOrigin",["webkitTransformOrigin"]),b("perspective",["webkitPerspective"]),b("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return c[a]||a}}(d,f)}(),!function(a,b){function c(a){var b=window.document.timeline;b.currentTime=a,b._discardAnimations(),0==b._animations.length?d=!1:requestAnimationFrame(c)}b.AnimationTimeline=function(){this._animations=[],this.currentTime=void 0},b.AnimationTimeline.prototype={getAnimations:function(){return this._discardAnimations(),this._animations.slice()},getAnimationPlayers:function(){return a.deprecated("AnimationTimeline.getAnimationPlayers","2015-03-23","Use AnimationTimeline.getAnimations instead."),this.getAnimations()},_discardAnimations:function(){this._animations=this._animations.filter(function(a){return"finished"!=a.playState&&"idle"!=a.playState})},play:function(a){var c=new b.Animation(a);return this._animations.push(c),b.restartWebAnimationsNextTick(),c._animation.play(),c}};var d=!1;b.restartWebAnimationsNextTick=function(){d||(d=!0,requestAnimationFrame(c))};var e=new b.AnimationTimeline;b.timeline=e;try{Object.defineProperty(window.document,"timeline",{configurable:!0,get:function(){return e}})}catch(f){}try{window.document.timeline=e}catch(f){}}(c,e,f),function(a,b){b.Animation=function(a){this.effect=a,a&&(a.animation=this),this._isGroup=!1,this._animation=null,this._childAnimations=[],this._callback=null,this._rebuildUnderlyingAnimation(),this._animation.cancel()},b.Animation.prototype={_rebuildUnderlyingAnimation:function(){this._animation&&(this._animation.cancel(),this._animation=null),(!this.effect||this.effect instanceof window.KeyframeEffect)&&(this._animation=b.newUnderlyingAnimationForKeyframeEffect(this.effect),b.bindAnimationForKeyframeEffect(this)),(this.effect instanceof window.SequenceEffect||this.effect instanceof window.GroupEffect)&&(this._animation=b.newUnderlyingAnimationForGroup(this.effect),b.bindAnimationForGroup(this))},_updateChildren:function(){if(this.effect&&"idle"!=this.playState){var a=this.effect._timing.delay;this._childAnimations.forEach(function(c){this._arrangeChildren(c,a),this.effect instanceof window.SequenceEffect&&(a+=b.groupChildDuration(c.effect))}.bind(this))}},_setExternalAnimation:function(a){if(this.effect&&this._isGroup)for(var b=0;b<this.effect.children.length;b++)this.effect.children[b].animation=a,this._childAnimations[b]._setExternalAnimation(a)},_constructChildren:function(){if(this.effect&&this._isGroup){var a=this.effect._timing.delay;this.effect.children.forEach(function(c){var d=window.document.timeline.play(c);this._childAnimations.push(d),d.playbackRate=this.playbackRate,this.paused&&d.pause(),c.animation=this.effect.animation,this._arrangeChildren(d,a),this.effect instanceof window.SequenceEffect&&(a+=b.groupChildDuration(c))}.bind(this))}},_arrangeChildren:function(a,b){null===this.startTime?(a.currentTime=this.currentTime-b/this.playbackRate,a._startTime=null):a.startTime!==this.startTime+b/this.playbackRate&&(a.startTime=this.startTime+b/this.playbackRate)},get paused(){return this._animation.paused},get playState(){return this._animation.playState},get onfinish(){return this._onfinish},set onfinish(a){"function"==typeof a?(this._onfinish=a,this._animation.onfinish=function(b){b.target=this,a.call(this,b)}.bind(this)):(this._animation.onfinish=a,this.onfinish=this._animation.onfinish)},get currentTime(){return this._animation.currentTime},set currentTime(a){this._animation.currentTime=a,this._register(),this._forEachChild(function(b,c){b.currentTime=a-c})},get startTime(){return this._animation.startTime},set startTime(a){this._animation.startTime=a,this._register(),this._forEachChild(function(b,c){b.startTime=a+c})},get playbackRate(){return this._animation.playbackRate},set playbackRate(a){var b=this.currentTime;this._animation.playbackRate=a,this._forEachChild(function(b){b.playbackRate=a}),"paused"!=this.playState&&"idle"!=this.playState&&this.play(),null!==b&&(this.currentTime=b)},get finished(){return this._animation.finished},get source(){return a.deprecated("Animation.source","2015-03-23","Use Animation.effect instead."),this.effect},play:function(){this._animation.play(),this._register(),b.awaitStartTime(this),this._forEachChild(function(a){var b=a.currentTime;a.play(),a.currentTime=b})},pause:function(){this._animation.pause(),this._register(),this._forEachChild(function(a){a.pause()})},finish:function(){this._animation.finish(),this._register()},cancel:function(){this._animation.cancel(),this._register(),this._removeChildren()},reverse:function(){var a=this.currentTime;this._animation.reverse(),this._forEachChild(function(a){a.reverse()}),null!==a&&(this.currentTime=a)},addEventListener:function(a,b){var c=b;"function"==typeof b&&(c=function(a){a.target=this,b.call(this,a)}.bind(this),b._wrapper=c),this._animation.addEventListener(a,c)},removeEventListener:function(a,b){this._animation.removeEventListener(a,b&&b._wrapper||b)},_removeChildren:function(){for(;this._childAnimations.length;)this._childAnimations.pop().cancel()},_forEachChild:function(b){var c=0;if(this.effect.children&&this._childAnimations.length<this.effect.children.length&&this._constructChildren(),this._childAnimations.forEach(function(a){b.call(this,a,c),this.effect instanceof window.SequenceEffect&&(c+=a.effect.activeDuration)}.bind(this)),"pending"!=this._animation.playState){var d=this.effect._timing,e=this._animation.currentTime;null!==e&&(e=a.calculateTimeFraction(a.calculateActiveDuration(d),e,d)),(null==e||isNaN(e))&&this._removeChildren()}}}}(c,e,f),function(a,b){function c(b){this._frames=a.normalizeKeyframes(b)}function d(){for(var a=!1;g.length;)g.shift()._updateChildren(),a=!0;return a}b.KeyframeEffect=function(b,d,e){return this.target=b,this._timingInput=e,this._timing=a.normalizeTimingInput(e),this.timing=a.makeTiming(e),this._normalizedKeyframes="function"==typeof d?d:new c(d),this._keyframes=d,this.activeDuration=a.calculateActiveDuration(this._timing),this
},b.KeyframeEffect.prototype={getFrames:function(){return"function"==typeof this._normalizedKeyframes?this._normalizedKeyframes:this._normalizedKeyframes._frames},get effect(){return a.deprecated("KeyframeEffect.effect","2015-03-23","Use KeyframeEffect.getFrames() instead."),this._normalizedKeyframes}};var e=Element.prototype.animate;Element.prototype.animate=function(a,c){return b.timeline.play(new b.KeyframeEffect(this,a,c))};var f=document.createElementNS("http://www.w3.org/1999/xhtml","div");b.newUnderlyingAnimationForKeyframeEffect=function(a){var b=a.target||f,c=a._keyframes;return"function"==typeof c&&(c=[]),e.apply(b,[c,a._timingInput])},b.bindAnimationForKeyframeEffect=function(a){a.effect&&"function"==typeof a.effect._normalizedKeyframes&&b.bindAnimationForCustomEffect(a)};var g=[];b.awaitStartTime=function(a){null===a.startTime&&a._isGroup&&(0==g.length&&requestAnimationFrame(d),g.push(a))};var h=window.getComputedStyle;Object.defineProperty(window,"getComputedStyle",{configurable:!0,enumerable:!0,value:function(){var a=h.apply(this,arguments);return d()&&(a=h.apply(this,arguments)),a}}),window.KeyframeEffect=b.KeyframeEffect,window.Element.prototype.getAnimations=function(){return document.timeline.getAnimations().filter(function(a){return null!==a.effect&&a.effect.target==this}.bind(this))},window.Element.prototype.getAnimationPlayers=function(){return a.deprecated("Element.getAnimationPlayers","2015-03-23","Use Element.getAnimations instead."),this.getAnimations()},window.Animation=function(){a.deprecated("window.Animation","2015-03-23","Use window.KeyframeEffect instead."),window.KeyframeEffect.apply(this,arguments)},window.Animation.prototype=Object.create(window.KeyframeEffect.prototype),window.Animation.prototype.constructor=window.Animation}(c,e,f),function(a,b){function c(a){a._registered||(a._registered=!0,f.push(a),g||(g=!0,requestAnimationFrame(d)))}function d(){var a=f;f=[],a.sort(function(a,b){return a._sequenceNumber-b._sequenceNumber}),a=a.filter(function(a){a();var b=a._animation?a._animation.playState:"idle";return"running"!=b&&"pending"!=b&&(a._registered=!1),a._registered}),f.push.apply(f,a),f.length?(g=!0,requestAnimationFrame(d)):g=!1}var e=(document.createElementNS("http://www.w3.org/1999/xhtml","div"),0);b.bindAnimationForCustomEffect=function(b){var d=b.effect.target,f=b.effect._normalizedKeyframes,g=b.effect.timing,h=null;g=a.normalizeTimingInput(g);var i=function(){var c=i._animation?i._animation.currentTime:null;null!==c&&(c=a.calculateTimeFraction(a.calculateActiveDuration(g),c,g),isNaN(c)&&(c=null)),c!==h&&f(c,d,b.effect),h=c};i._animation=b,i._registered=!1,i._sequenceNumber=e++,b._callback=i,c(i)};var f=[],g=!1;b.Animation.prototype._register=function(){this._callback&&c(this._callback)}}(c,e,f),function(a,b){function c(a){return a._timing.delay+a.activeDuration+a._timing.endDelay}function d(b,c){this.children=b||[],this._timing=a.normalizeTimingInput(c,!0),this.timing=a.makeTiming(c,!0),"auto"===this._timing.duration&&(this._timing.duration=this.activeDuration)}window.SequenceEffect=function(){d.apply(this,arguments)},window.GroupEffect=function(){d.apply(this,arguments)},window.SequenceEffect.prototype={get activeDuration(){var a=0;return this.children.forEach(function(b){a+=c(b)}),Math.max(a,0)}},window.GroupEffect.prototype={get activeDuration(){var a=0;return this.children.forEach(function(b){a=Math.max(a,c(b))}),a}},b.newUnderlyingAnimationForGroup=function(c){var d,e=null,f=function(b){var c=d._wrapper;return"pending"!=c.playState&&c.effect?null==b?void c._removeChildren():0==b&&c.playbackRate<0&&(e||(e=a.normalizeTimingInput(c.effect.timing)),b=a.calculateTimeFraction(a.calculateActiveDuration(e),-1,e),isNaN(b)||null==b)?(c._forEachChild(function(a){a.currentTime=-1}),void c._removeChildren()):void 0:void 0};return d=b.timeline.play(new b.KeyframeEffect(null,f,c._timing))},b.bindAnimationForGroup=function(a){a._animation._wrapper=a,a._isGroup=!0,b.awaitStartTime(a),a._constructChildren(),a._setExternalAnimation(a)},b.groupChildDuration=c,window.AnimationSequence=function(){a.deprecated("window.AnimationSequence","2015-03-23","Use window.SequenceEffect instead."),window.SequenceEffect.apply(this,arguments)},window.AnimationSequence.prototype=Object.create(window.SequenceEffect.prototype),window.AnimationSequence.prototype.constructor=window.AnimationSequence,window.AnimationGroup=function(){a.deprecated("window.AnimationGroup","2015-03-23","Use window.GroupEffect instead."),window.GroupEffect.apply(this,arguments)},window.AnimationGroup.prototype=Object.create(window.GroupEffect.prototype),window.AnimationGroup.prototype.constructor=window.AnimationGroup}(c,e,f)}({},function(){return this}());
//# sourceMappingURL=web-animations-next-lite.min.js.map</script>


<script>

  Polymer({

    is: 'opaque-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;
      node.style.opacity = '0';
      this._effect = new KeyframeEffect(node, [
        {'opacity': '1'},
        {'opacity': '1'}
      ], this.timingFromConfig(config));
      return this._effect;
    },

    complete: function(config) {
      config.node.style.opacity = '';
    }

  });

</script>
<script>

  /**
   * `Polymer.NeonAnimatableBehavior` is implemented by elements containing animations for use with
   * elements implementing `Polymer.NeonAnimationRunnerBehavior`.
   * @polymerBehavior
   */
  Polymer.NeonAnimatableBehavior = {

    properties: {

      /**
       * Animation configuration. See README for more info.
       */
      animationConfig: {
        type: Object
      },

      /**
       * Convenience property for setting an 'entry' animation. Do not set `animationConfig.entry`
       * manually if using this. The animated node is set to `this` if using this property.
       */
      entryAnimation: {
        observer: '_entryAnimationChanged',
        type: String
      },

      /**
       * Convenience property for setting an 'exit' animation. Do not set `animationConfig.exit`
       * manually if using this. The animated node is set to `this` if using this property.
       */
      exitAnimation: {
        observer: '_exitAnimationChanged',
        type: String
      }

    },

    _entryAnimationChanged: function() {
      this.animationConfig = this.animationConfig || {};
      if (this.entryAnimation !== 'fade-in-animation') {
        // insert polyfill hack
        this.animationConfig['entry'] = [{
          name: 'opaque-animation',
          node: this
        }, {
          name: this.entryAnimation,
          node: this
        }];
      } else {
        this.animationConfig['entry'] = [{
          name: this.entryAnimation,
          node: this
        }];
      }
    },

    _exitAnimationChanged: function() {
      this.animationConfig = this.animationConfig || {};
      this.animationConfig['exit'] = [{
        name: this.exitAnimation,
        node: this
      }];
    },

    _copyProperties: function(config1, config2) {
      // shallowly copy properties from config2 to config1
      for (var property in config2) {
        config1[property] = config2[property];
      }
    },

    _cloneConfig: function(config) {
      var clone = {
        isClone: true
      };
      this._copyProperties(clone, config);
      return clone;
    },

    _getAnimationConfigRecursive: function(type, map, allConfigs) {
      if (!this.animationConfig) {
        return;
      }

      // type is optional
      var thisConfig;
      if (type) {
        thisConfig = this.animationConfig[type];
      } else {
        thisConfig = this.animationConfig;
      }

      if (!Array.isArray(thisConfig)) {
        thisConfig = [thisConfig];
      }

      // iterate animations and recurse to process configurations from child nodes
      if (thisConfig) {
        for (var config, index = 0; config = thisConfig[index]; index++) {
          if (config.animatable) {
            config.animatable._getAnimationConfigRecursive(config.type || type, map, allConfigs);
          } else {
            if (config.id) {
              var cachedConfig = map[config.id];
              if (cachedConfig) {
                // merge configurations with the same id, making a clone lazily
                if (!cachedConfig.isClone) {
                  map[config.id] = this._cloneConfig(cachedConfig)
                  cachedConfig = map[config.id];
                }
                this._copyProperties(cachedConfig, config);
              } else {
                // put any configs with an id into a map
                map[config.id] = config;
              }
            } else {
              allConfigs.push(config);
            }
          }
        }
      }
    },

    /**
     * An element implementing `Polymer.NeonAnimationRunnerBehavior` calls this method to configure
     * an animation with an optional type. Elements implementing `Polymer.NeonAnimatableBehavior`
     * should define the property `animationConfig`, which is either a configuration object
     * or a map of animation type to array of configuration objects.
     */
    getAnimationConfig: function(type) {
      var map = [];
      var allConfigs = [];
      this._getAnimationConfigRecursive(type, map, allConfigs);
      // append the configurations saved in the map to the array
      for (var key in map) {
        allConfigs.push(map[key]);
      }
      return allConfigs;
    }

  };

</script>
<script>

  /**
   * `Polymer.NeonAnimationRunnerBehavior` adds a method to run animations.
   * @polymerBehavior
   */
  Polymer.NeonAnimationRunnerBehavior = [Polymer.NeonAnimatableBehavior, {

    properties: {

      _animationMeta: {
        type: Object,
        value: function() {
          return new Polymer.IronMeta({type: 'animation'});
        }
      },

      _player: {
        type: Object
      }

    },

    _configureAnimationEffects: function(allConfigs) {
      var allAnimations = [];
      if (allConfigs.length > 0) {
        for (var config, index = 0; config = allConfigs[index]; index++) {
          var animationConstructor = this._animationMeta.byKey(config.name);
          if (animationConstructor) {
            var animation = animationConstructor && new animationConstructor();
            var effect = animation.configure(config);
            if (effect) {
              allAnimations.push({
                animation: animation,
                config: config,
                effect: effect
              });
            }
          } else {
            console.warn(this.is + ':', config.name, 'not found!');
          }
        }
      }
      return allAnimations;
    },

    _runAnimationEffects: function(allEffects) {
      return player = document.timeline.play(new GroupEffect(allEffects));
    },

    _completeAnimations: function(allAnimations) {
      for (var animation, index = 0; animation = allAnimations[index]; index++) {
        animation.animation.complete(animation.config);
      }
    },

    /**
     * Plays an animation with an optional `type`.
     */
    playAnimation: function(type, cookie) {
      var allConfigs = this.getAnimationConfig(type);
      if (!allConfigs) {
        return;
      }
      var allAnimations = this._configureAnimationEffects(allConfigs);
      var allEffects = allAnimations.map(function(animation) {
        return animation.effect;
      });

      if (allEffects.length > 0) {
        this._player = this._runAnimationEffects(allEffects);
        this._player.onfinish = function() {
          this._completeAnimations(allAnimations);

          if (this._player) {
            this._player.cancel();
            this._player = null;
          }

          this.fire('neon-animation-finish', cookie, {bubbles: false});
        }.bind(this);

      } else {
        this.fire('neon-animation-finish', cookie, {bubbles: false});
      }
    },

    /**
     * Cancels the currently running animation.
     */
    cancelAnimation: function() {
      if (this._player) {
        this._player.cancel();
      }
    }

  }];
</script>
<script>

/**
Polymer.IronFitBehavior fits an element in another element using `max-height` and `max-width`, and
optionally centers it in the window or another element.

The element will only be sized and/or positioned if it has not already been sized and/or positioned
by CSS.

CSS properties               | Action
-----------------------------|-------------------------------------------
`position` set               | Element is not centered horizontally or vertically
`top` or `bottom` set        | Element is not vertically centered
`left` or `right` set        | Element is not horizontally centered
`max-height` or `height` set | Element respects `max-height` or `height`
`max-width` or `width` set   | Element respects `max-width` or `width`

@demo demo/index.html
@polymerBehavior
*/

  Polymer.IronFitBehavior = {

    properties: {

      /**
       * The element that will receive a `max-height`/`width`. By default it is the same as `this`,
       * but it can be set to a child element. This is useful, for example, for implementing a
       * scrolling region inside the element.
       */
      sizingTarget: {
        type: Object,
        value: function() {
          return this;
        }
      },

      /**
       * The element to fit `this` into.
       */
      fitInto: {
        type: Object,
        value: window
      },

      /**
       * Set to true to auto-fit on attach.
       */
      autoFitOnAttach: {
        type: Boolean,
        value: false
      },

      _fitInfo: {
        type: Object
      }

    },

    get _fitWidth() {
      var fitWidth;
      if (this.fitInto === window) {
        fitWidth = this.fitInto.innerWidth;
      } else {
        fitWidth = this.fitInto.getBoundingClientRect().width;
      }
      return fitWidth;
    },

    get _fitHeight() {
      var fitHeight;
      if (this.fitInto === window) {
        fitHeight = this.fitInto.innerHeight;
      } else {
        fitHeight = this.fitInto.getBoundingClientRect().height;
      }
      return fitHeight;
    },

    attached: function() {
      if (this.autoFitOnAttach) {
        if (window.getComputedStyle(this).display === 'none') {
          setTimeout(function() {
            this.fit();
          }.bind(this));
        } else {
          this.fit();
        }
      }
    },

    /**
     * Fits and optionally centers the element into the window, or `fitInfo` if specified.
     */
    fit: function() {
      this._discoverInfo();
      this.constrain();
      this.center();
    },

    /**
     * Memoize information needed to position and size the target element.
     */
    _discoverInfo: function() {
      if (this._fitInfo) {
        return;
      }
      var target = window.getComputedStyle(this);
      var sizer = window.getComputedStyle(this.sizingTarget);
      this._fitInfo = {
        positionedBy: {
          vertically: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
            'bottom' : null),
          horizontally: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
            'right' : null),
          css: target.position
        },
        sizedBy: {
          height: sizer.maxHeight !== 'none',
          width: sizer.maxWidth !== 'none'
        },
        margin: {
          top: parseInt(target.marginTop, 10) || 0,
          right: parseInt(target.marginRight, 10) || 0,
          bottom: parseInt(target.marginBottom, 10) || 0,
          left: parseInt(target.marginLeft, 10) || 0
        }
      };
    },

    /**
     * Resets the target element's position and size constraints, and clear
     * the memoized data.
     */
    resetFit: function() {
      if (!this._fitInfo || !this._fitInfo.sizedBy.height) {
        this.sizingTarget.style.maxHeight = '';
        this.style.top = '';
      }
      if (!this._fitInfo || !this._fitInfo.sizedBy.width) {
        this.sizingTarget.style.maxWidth = '';
        this.style.left = '';
      }
      if (this._fitInfo) {
        this.style.position = this._fitInfo.positionedBy.css;
      }
      this._fitInfo = null;
    },

    /**
     * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after the element,
     * the window, or the `fitInfo` element has been resized.
     */
    refit: function() {
      this.resetFit();
      this.fit();
    },

    /**
     * Constrains the size of the element to the window or `fitInfo` by setting `max-height`
     * and/or `max-width`.
     */
    constrain: function() {
      var info = this._fitInfo;
      // position at (0px, 0px) if not already positioned, so we can measure the natural size.
      if (!this._fitInfo.positionedBy.vertically) {
        this.style.top = '0px';
      }
      if (!this._fitInfo.positionedBy.horizontally) {
        this.style.left = '0px';
      }
      // need border-box for margin/padding
      this.sizingTarget.style.boxSizing = 'border-box';
      // constrain the width and height if not already set
      var rect = this.getBoundingClientRect();
      if (!info.sizedBy.height) {
        this._sizeDimension(rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
      }
      if (!info.sizedBy.width) {
        this._sizeDimension(rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
      }
    },

    _sizeDimension: function(rect, positionedBy, start, end, extent) {
      var info = this._fitInfo;
      var max = extent === 'Width' ? this._fitWidth : this._fitHeight;
      var flip = (positionedBy === end);
      var offset = flip ? max - rect[end] : rect[start];
      var margin = info.margin[flip ? start : end];
      var offsetExtent = 'offset' + extent;
      var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
      this.sizingTarget.style['max' + extent] = (max - margin - offset - sizingOffset) + 'px';
    },

    /**
     * Centers horizontally and vertically if not already positioned. This also sets
     * `position:fixed`.
     */
    center: function() {
      if (!this._fitInfo.positionedBy.vertically || !this._fitInfo.positionedBy.horizontally) {
        // need position:fixed to center
        this.style.position = 'fixed';
      }
      if (!this._fitInfo.positionedBy.vertically) {
        var top = (this._fitHeight - this.offsetHeight) / 2;
        top -= this._fitInfo.margin.top;
        this.style.top = top + 'px';
      }
      if (!this._fitInfo.positionedBy.horizontally) {
        var left = (this._fitWidth - this.offsetWidth) / 2;
        left -= this._fitInfo.margin.left;
        this.style.left = left + 'px';
      }
    }

  };

</script>
<script>

  Polymer.IronOverlayManager = (function() {

    var overlays = [];
    var DEFAULT_Z = 10;
    var backdrops = [];

    // track overlays for z-index and focus managemant
    function addOverlay(overlay) {
      var z0 = currentOverlayZ();
      overlays.push(overlay);
      var z1 = currentOverlayZ();
      if (z1 <= z0) {
        applyOverlayZ(overlay, z0);
      }
    }

    function removeOverlay(overlay) {
      var i = overlays.indexOf(overlay);
      if (i >= 0) {
        overlays.splice(i, 1);
        setZ(overlay, '');
      }
    }

    function applyOverlayZ(overlay, aboveZ) {
      setZ(overlay, aboveZ + 2);
    }

    function setZ(element, z) {
      element.style.zIndex = z;
    }

    function currentOverlay() {
      return overlays[overlays.length-1];
    }

    function currentOverlayZ() {
      var z;
      var current = currentOverlay();
      if (current) {
        var z1 = window.getComputedStyle(current).zIndex;
        if (!isNaN(z1)) {
          z = Number(z1);
        }
      }
      return z || DEFAULT_Z;
    }

    function focusOverlay() {
      var current = currentOverlay();
      // We have to be careful to focus the next overlay _after_ any current
      // transitions are complete (due to the state being toggled prior to the
      // transition). Otherwise, we risk infinite recursion when a transitioning
      // (closed) overlay becomes the current overlay.
      //
      // NOTE: We make the assumption that any overlay that completes a transition
      // will call into focusOverlay to kick the process back off. Currently:
      // transitionend -> _applyFocus -> focusOverlay.
      if (current && !current.transitioning) {
        current._applyFocus();
      }
    }

    function trackBackdrop(element) {
      // backdrops contains the overlays with a backdrop that are currently
      // visible
      if (element.opened) {
        backdrops.push(element);
      } else {
        var index = backdrops.indexOf(element);
        if (index >= 0) {
          backdrops.splice(index, 1);
        }
      }
    }

    function getBackdrops() {
      return backdrops;
    }

    return {
      addOverlay: addOverlay,
      removeOverlay: removeOverlay,
      currentOverlay: currentOverlay,
      currentOverlayZ: currentOverlayZ,
      focusOverlay: focusOverlay,
      trackBackdrop: trackBackdrop,
      getBackdrops: getBackdrops
    };

  })();

</script>


<script>

/*
Use `Polymer.IronOverlayBehavior` to implement an element that can be hidden or shown, and displays
on top of other content. It includes an optional backdrop, and can be used to implement a variety
of UI controls including dialogs and drop downs. Multiple overlays may be displayed at once.

### Closing and canceling

A dialog may be hidden by closing or canceling. The difference between close and cancel is user
intent. Closing generally implies that the user acknowledged the content on the overlay. By default,
it will cancel whenever the user taps outside it or presses the escape key. This behavior is
configurable with the `no-cancel-on-esc-key` and the `no-cancel-on-outside-click` properties.
`close()` should be called explicitly by the implementer when the user interacts with a control
in the overlay element.

### Positioning

By default the element is sized and positioned to fit and centered inside the window. You can
position and size it manually using CSS. See `Polymer.IronFitBehavior`.

### Backdrop

Set the `with-backdrop` attribute to display a backdrop behind the overlay. The backdrop is
appended to `<body>` and is of type `<iron-overlay-backdrop>`. See its doc page for styling
options.

### Limitations

The element is styled to appear on top of other content by setting its `z-index` property. You
must ensure no element has a stacking context with a higher `z-index` than its parent stacking
context. You should place this element as a child of `<body>` whenever possible.

@demo demo/index.html
@polymerBehavior Polymer.IronOverlayBehavior
*/

  Polymer.IronOverlayBehaviorImpl = {

    properties: {

      /**
       * True if the overlay is currently displayed.
       */
      opened: {
        observer: '_openedChanged',
        type: Boolean,
        value: false
      },

      /**
       * True if the overlay was canceled when it was last closed.
       */
      canceled: {
        observer: '_canceledChanged',
        readOnly: true,
        type: Boolean,
        value: false
      },

      /**
       * Set to true to display a backdrop behind the overlay.
       */
      withBackdrop: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable auto-focusing the overlay or child nodes with
       * the `autofocus` attribute` when the overlay is opened.
       */
      noAutoFocus: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable canceling the overlay with the ESC key.
       */
      noCancelOnEscKey: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable canceling the overlay by clicking outside it.
       */
      noCancelOnOutsideClick: {
        type: Boolean,
        value: false
      },

      /**
       * Returns the reason this dialog was last closed.
       */
      closingReason: {
        // was a getter before, but needs to be a property so other
        // behaviors can override this.
        type: Object
      },

      _manager: {
        type: Object,
        value: Polymer.IronOverlayManager
      },

      _boundOnCaptureClick: {
        type: Function,
        value: function() {
          return this._onCaptureClick.bind(this);
        }
      },

      _boundOnCaptureKeydown: {
        type: Function,
        value: function() {
          return this._onCaptureKeydown.bind(this);
        }
      }

    },

    listeners: {
      'click': '_onClick',
      'iron-resize': '_onIronResize'
    },

    /**
     * The backdrop element.
     * @type Node
     */
    get backdropElement() {
      return this._backdrop;
    },

    get _focusNode() {
      return Polymer.dom(this).querySelector('[autofocus]') || this;
    },

    registered: function() {
      this._backdrop = document.createElement('iron-overlay-backdrop');
    },

    ready: function() {
      this._ensureSetup();
      if (this._callOpenedWhenReady) {
        this._openedChanged();
      }
    },

    detached: function() {
      this.opened = false;
      this._completeBackdrop();
      this._manager.removeOverlay(this);
    },

    /**
     * Toggle the opened state of the overlay.
     */
    toggle: function() {
      this.opened = !this.opened;
    },

    /**
     * Open the overlay.
     */
    open: function() {
      this.opened = true;
      this.closingReason = {canceled: false};
    },

    /**
     * Close the overlay.
     */
    close: function() {
      this.opened = false;
      this._setCanceled(false);
    },

    /**
     * Cancels the overlay.
     */
    cancel: function() {
      this.opened = false,
      this._setCanceled(true);
    },

    _ensureSetup: function() {
      if (this._overlaySetup) {
        return;
      }
      this._overlaySetup = true;
      this.style.outline = 'none';
      this.style.display = 'none';
    },

    _openedChanged: function() {
      if (this.opened) {
        this.removeAttribute('aria-hidden');
      } else {
        this.setAttribute('aria-hidden', 'true');
      }

      // wait to call after ready only if we're initially open
      if (!this._overlaySetup) {
        this._callOpenedWhenReady = this.opened;
        return;
      }
      if (this._openChangedAsync) {
        this.cancelAsync(this._openChangedAsync);
      }

      this._toggleListeners();

      if (this.opened) {
        this._prepareRenderOpened();
      }

      // async here to allow overlay layer to become visible.
      this._openChangedAsync = this.async(function() {
        // overlay becomes visible here
        this.style.display = '';
        // force layout to ensure transitions will go
        this.offsetWidth;
        if (this.opened) {
          this._renderOpened();
        } else {
          this._renderClosed();
        }
        this._openChangedAsync = null;
      });

    },

    _canceledChanged: function() {
      this.closingReason = this.closingReason || {};
      this.closingReason.canceled = this.canceled;
    },

    _toggleListener: function(enable, node, event, boundListener, capture) {
      if (enable) {
        node.addEventListener(event, boundListener, capture);
      } else {
        node.removeEventListener(event, boundListener, capture);
      }
    },

    _toggleListeners: function() {
      if (this._toggleListenersAsync) {
        this.cancelAsync(this._toggleListenersAsync);
      }
      // async so we don't auto-close immediately via a click.
      this._toggleListenersAsync = this.async(function() {
        this._toggleListener(this.opened, document, 'click', this._boundOnCaptureClick, true);
        this._toggleListener(this.opened, document, 'keydown', this._boundOnCaptureKeydown, true);
        this._toggleListenersAsync = null;
      });
    },

    // tasks which must occur before opening; e.g. making the element visible
    _prepareRenderOpened: function() {
      this._manager.addOverlay(this);

      if (this.withBackdrop) {
        this.backdropElement.prepare();
        this._manager.trackBackdrop(this);
      }

      this._preparePositioning();
      this.fit();
      this._finishPositioning();
    },

    // tasks which cause the overlay to actually open; typically play an
    // animation
    _renderOpened: function() {
      if (this.withBackdrop) {
        this.backdropElement.open();
      }
      this._finishRenderOpened();
    },

    _renderClosed: function() {
      if (this.withBackdrop) {
        this.backdropElement.close();
      }
      this._finishRenderClosed();
    },

    _onTransitionend: function(event) {
      // make sure this is our transition event.
      if (event && event.target !== this) {
        return;
      }
      if (this.opened) {
        this._finishRenderOpened();
      } else {
        this._finishRenderClosed();
      }
    },

    _finishRenderOpened: function() {
      // focus the child node with [autofocus]
      if (!this.noAutoFocus) {
        this._focusNode.focus();
      }

      this.fire('iron-overlay-opened');

      this._squelchNextResize = true;
      this.async(this.notifyResize);
    },

    _finishRenderClosed: function() {
      // hide the overlay and remove the backdrop
      this.resetFit();
      this.style.display = 'none';
      this._completeBackdrop();
      this._manager.removeOverlay(this);

      this._focusNode.blur();
      // focus the next overlay, if there is one
      this._manager.focusOverlay();

      this.fire('iron-overlay-closed', this.closingReason);

      this._squelchNextResize = true;
      this.async(this.notifyResize);
    },

    _completeBackdrop: function() {
      if (this.withBackdrop) {
        this._manager.trackBackdrop(this);
        this.backdropElement.complete();
      }
    },

    _preparePositioning: function() {
      this.style.transition = this.style.webkitTransition = 'none';
      this.style.transform = this.style.webkitTransform = 'none';
      this.style.display = '';
    },

    _finishPositioning: function(target) {
      this.style.display = 'none';
      this.style.transform = this.style.webkitTransform = '';
      // force layout to avoid application of transform
      this.offsetWidth;
      this.style.transition = this.style.webkitTransition = '';
    },

    _applyFocus: function() {
      if (this.opened) {
        if (!this.noAutoFocus) {
          this._focusNode.focus();
        }
      } else {
        this._focusNode.blur();
        this._manager.focusOverlay();
      }
    },

    _onCaptureClick: function(event) {
      // attempt to close asynchronously and prevent the close of a tap event is immediately heard
      // on target. This is because in shadow dom due to event retargetting event.target is not
      // useful.
      if (!this.noCancelOnOutsideClick && (this._manager.currentOverlay() == this)) {
        this._cancelJob = this.async(function() {
          this.cancel();
        }, 10);
      }
    },

    _onClick: function(event) {
      if (this._cancelJob) {
        this.cancelAsync(this._cancelJob);
        this._cancelJob = null;
      }
    },

    _onCaptureKeydown: function(event) {
      var ESC = 27;
      if (!this.noCancelOnEscKey && (event.keyCode === ESC)) {
        this.cancel();
        event.stopPropagation();
      }
    },

    _onIronResize: function() {
      if (this._squelchNextResize) {
        this._squelchNextResize = false;
        return;
      }
      if (this.opened) {
        this.refit();
      }
    }

  };

  /** @polymerBehavior */
  Polymer.IronOverlayBehavior = [Polymer.IronFitBehavior, Polymer.IronResizableBehavior, Polymer.IronOverlayBehaviorImpl];

/*
 * Fired after the `iron-overlay` opens.
 * @event iron-overlay-opened
 */

/*
 * Fired after the `iron-overlay` closes.
 * @event iron-overlay-closed {{canceled: boolean}} detail -
 *     canceled: True if the overlay was canceled.
 */

</script>
<script>

/*
Use `Polymer.PaperDialogBehavior` and `paper-dialog-common.css` to implement a Material Design
dialog.

For example, if `<paper-dialog-impl>` implements this behavior:

    <paper-dialog-impl>
        <h2>Header</h2>
        <div>Dialog body</div>
        <div class="buttons">
            <paper-button dialog-dismiss>Cancel</paper-button>
            <paper-button dialog-confirm>Accept</paper-button>
        </div>
    </paper-dialog-impl>

`paper-dialog-common.css` provide styles for a header, content area, and an action area for buttons.
Use the `<h2>` tag for the header and the `buttons` class for the action area. You can use the
`paper-dialog-scrollable` element (in its own repository) if you need a scrolling content area.

Use the `dialog-dismiss` and `dialog-confirm` attributes on interactive controls to close the
dialog. If the user dismisses the dialog with `dialog-confirm`, the `closingReason` will update
to include `confirmed: true`.

### Styling

The following custom properties and mixins are available for styling.

Custom property | Description | Default
----------------|-------------|----------
`--paper-dialog-background-color` | Dialog background color                     | `--primary-background-color`
`--paper-dialog-color`            | Dialog foreground color                     | `--primary-text-color`
`--paper-dialog`                  | Mixin applied to the dialog                 | `{}`
`--paper-dialog-title`            | Mixin applied to the title (`<h2>`) element | `{}`
`--paper-dialog-button-color`     | Button area foreground color                | `--default-primary-color`

### Accessibility

This element has `role="dialog"` by default. Depending on the context, it may be more appropriate
to override this attribute with `role="alertdialog"`. The header (a `<h2>` element) will

If `modal` is set, the element will set `aria-modal` and prevent the focus from exiting the element.
It will also ensure that focus remains in the dialog.

The `aria-labelledby` attribute will be set to the header element, if one exists.

@hero hero.svg
@demo demo/index.html
@polymerBehavior Polymer.PaperDialogBehavior
*/

  Polymer.PaperDialogBehaviorImpl = {

    hostAttributes: {
      'role': 'dialog',
      'tabindex': '-1'
    },

    properties: {

      /**
       * If `modal` is true, this implies `no-cancel-on-outside-click` and `with-backdrop`.
       */
      modal: {
        observer: '_modalChanged',
        type: Boolean,
        value: false
      },

      _lastFocusedElement: {
        type: Node
      },

      _boundOnFocus: {
        type: Function,
        value: function() {
          return this._onFocus.bind(this);
        }
      },

      _boundOnBackdropClick: {
        type: Function,
        value: function() {
          return this._onBackdropClick.bind(this);
        }
      }

    },

    listeners: {
      'click': '_onDialogClick',
      'iron-overlay-opened': '_onIronOverlayOpened',
      'iron-overlay-closed': '_onIronOverlayClosed'
    },

    attached: function() {
      this._observer = this._observe(this);
      this._updateAriaLabelledBy();
    },

    detached: function() {
      if (this._observer) {
        this._observer.disconnect();
      }
    },

    _observe: function(node) {
      var observer = new MutationObserver(function() {
        this._updateAriaLabelledBy();
      }.bind(this));
      observer.observe(node, {
        childList: true,
        subtree: true
      });
      return observer;
    },

    _modalChanged: function() {
      if (this.modal) {
        this.setAttribute('aria-modal', 'true');
      } else {
        this.setAttribute('aria-modal', 'false');
      }
      // modal implies noCancelOnOutsideClick and withBackdrop if true, don't overwrite
      // those properties otherwise.
      if (this.modal) {
        this.noCancelOnOutsideClick = true;
        this.withBackdrop = true;
      }
    },

    _updateAriaLabelledBy: function() {
      var header = Polymer.dom(this).querySelector('h2');
      if (!header) {
        this.removeAttribute('aria-labelledby');
        return;
      }
      var headerId = header.getAttribute('id');
      if (headerId && this.getAttribute('aria-labelledby') === headerId) {
        return;
      }
      // set aria-describedBy to the header element
      var labelledById;
      if (headerId) {
        labelledById = headerId;
      } else {
        labelledById = 'paper-dialog-header-' + new Date().getUTCMilliseconds();
        header.setAttribute('id', labelledById);
      }
      this.setAttribute('aria-labelledby', labelledById);
    },

    _updateClosingReasonConfirmed: function(confirmed) {
      this.closingReason = this.closingReason || {};
      this.closingReason.confirmed = confirmed;
    },

    _onDialogClick: function(event) {
      var target = event.target;
      while (target !== this) {
        if (target.hasAttribute('dialog-dismiss')) {
          this._updateClosingReasonConfirmed(false);
          this.close();
          break;
        } else if (target.hasAttribute('dialog-confirm')) {
          this._updateClosingReasonConfirmed(true);
          this.close();
          break;
        }
        target = target.parentNode;
      }
    },

    _onIronOverlayOpened: function() {
      if (this.modal) {
        document.body.addEventListener('focus', this._boundOnFocus, true);
        this.backdropElement.addEventListener('click', this._boundOnBackdropClick);
      }
    },

    _onIronOverlayClosed: function() {
      document.body.removeEventListener('focus', this._boundOnFocus, true);
      this.backdropElement.removeEventListener('click', this._boundOnBackdropClick);
    },

    _onFocus: function(event) {
      if (this.modal) {
        var target = event.target;
        while (target && target !== this && target !== document.body) {
          target = target.parentNode;
        }
        if (target) {
          if (target === document.body) {
            if (this._lastFocusedElement) {
              this._lastFocusedElement.focus();
            } else {
              this._focusNode.focus();
            }
          } else {
            this._lastFocusedElement = event.target;
          }
        }
      }
    },

    _onBackdropClick: function() {
      if (this.modal) {
        if (this._lastFocusedElement) {
          this._lastFocusedElement.focus();
        } else {
          this._focusNode.focus();
        }
      }
    }

  };

  /** @polymerBehavior */
  Polymer.PaperDialogBehavior = [Polymer.IronOverlayBehavior, Polymer.PaperDialogBehaviorImpl];

</script>




<script>(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.XP = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
function cleanUpNextTick(){draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue()}function drainQueue(){if(!draining){var e=setTimeout(cleanUpNextTick);draining=!0;for(var n=queue.length;n;){for(currentQueue=queue,queue=[];++queueIndex<n;)currentQueue[queueIndex].run();queueIndex=-1,n=queue.length}currentQueue=null,draining=!1,clearTimeout(e)}}function Item(e,n){this.fun=e,this.array=n}function noop(){}var process=module.exports={},queue=[],draining=!1,currentQueue,queueIndex=-1;process.nextTick=function(e){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];queue.push(new Item(e,n)),1!==queue.length||draining||setTimeout(drainQueue,0)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.binding=function(e){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(e){throw new Error("process.chdir is not supported")},process.umask=function(){return 0};
},{}],2:[function(require,module,exports){
(function (global){
!function(e){function o(e){throw RangeError(T[e])}function n(e,o){for(var n=e.length,r=[];n--;)r[n]=o(e[n]);return r}function r(e,o){var r=e.split("@"),t="";r.length>1&&(t=r[0]+"@",e=r[1]),e=e.replace(S,".");var u=e.split("."),i=n(u,o).join(".");return t+i}function t(e){for(var o,n,r=[],t=0,u=e.length;u>t;)o=e.charCodeAt(t++),o>=55296&&56319>=o&&u>t?(n=e.charCodeAt(t++),56320==(64512&n)?r.push(((1023&o)<<10)+(1023&n)+65536):(r.push(o),t--)):r.push(o);return r}function u(e){return n(e,function(e){var o="";return e>65535&&(e-=65536,o+=P(e>>>10&1023|55296),e=56320|1023&e),o+=P(e)}).join("")}function i(e){return 10>e-48?e-22:26>e-65?e-65:26>e-97?e-97:b}function f(e,o){return e+22+75*(26>e)-((0!=o)<<5)}function c(e,o,n){var r=0;for(e=n?M(e/j):e>>1,e+=M(e/o);e>L*C>>1;r+=b)e=M(e/L);return M(r+(L+1)*e/(e+m))}function l(e){var n,r,t,f,l,s,d,a,p,h,v=[],g=e.length,w=0,m=I,j=A;for(r=e.lastIndexOf(E),0>r&&(r=0),t=0;r>t;++t)e.charCodeAt(t)>=128&&o("not-basic"),v.push(e.charCodeAt(t));for(f=r>0?r+1:0;g>f;){for(l=w,s=1,d=b;f>=g&&o("invalid-input"),a=i(e.charCodeAt(f++)),(a>=b||a>M((x-w)/s))&&o("overflow"),w+=a*s,p=j>=d?y:d>=j+C?C:d-j,!(p>a);d+=b)h=b-p,s>M(x/h)&&o("overflow"),s*=h;n=v.length+1,j=c(w-l,n,0==l),M(w/n)>x-m&&o("overflow"),m+=M(w/n),w%=n,v.splice(w++,0,m)}return u(v)}function s(e){var n,r,u,i,l,s,d,a,p,h,v,g,w,m,j,F=[];for(e=t(e),g=e.length,n=I,r=0,l=A,s=0;g>s;++s)v=e[s],128>v&&F.push(P(v));for(u=i=F.length,i&&F.push(E);g>u;){for(d=x,s=0;g>s;++s)v=e[s],v>=n&&d>v&&(d=v);for(w=u+1,d-n>M((x-r)/w)&&o("overflow"),r+=(d-n)*w,n=d,s=0;g>s;++s)if(v=e[s],n>v&&++r>x&&o("overflow"),v==n){for(a=r,p=b;h=l>=p?y:p>=l+C?C:p-l,!(h>a);p+=b)j=a-h,m=b-h,F.push(P(f(h+j%m,0))),a=M(j/m);F.push(P(f(a,0))),l=c(r,w,u==i),r=0,++u}++r,++n}return F.join("")}function d(e){return r(e,function(e){return F.test(e)?l(e.slice(4).toLowerCase()):e})}function a(e){return r(e,function(e){return O.test(e)?"xn--"+s(e):e})}var p="object"==typeof exports&&exports&&!exports.nodeType&&exports,h="object"==typeof module&&module&&!module.nodeType&&module,v="object"==typeof global&&global;(v.global===v||v.window===v||v.self===v)&&(e=v);var g,w,x=2147483647,b=36,y=1,C=26,m=38,j=700,A=72,I=128,E="-",F=/^xn--/,O=/[^\x20-\x7E]/,S=/[\x2E\u3002\uFF0E\uFF61]/g,T={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},L=b-y,M=Math.floor,P=String.fromCharCode;if(g={version:"1.3.2",ucs2:{decode:t,encode:u},decode:l,encode:s,toASCII:a,toUnicode:d},"function"==typeof define&&"object"==typeof define.amd&&define.amd)define("punycode",function(){return g});else if(p&&h)if(module.exports==p)h.exports=g;else for(w in g)g.hasOwnProperty(w)&&(p[w]=g[w]);else e.punycode=g}(this);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
"use strict";function hasOwnProperty(r,e){return Object.prototype.hasOwnProperty.call(r,e)}module.exports=function(r,e,t,n){e=e||"&",t=t||"=";var o={};if("string"!=typeof r||0===r.length)return o;var a=/\+/g;r=r.split(e);var s=1e3;n&&"number"==typeof n.maxKeys&&(s=n.maxKeys);var p=r.length;s>0&&p>s&&(p=s);for(var y=0;p>y;++y){var u,c,i,l,f=r[y].replace(a,"%20"),v=f.indexOf(t);v>=0?(u=f.substr(0,v),c=f.substr(v+1)):(u=f,c=""),i=decodeURIComponent(u),l=decodeURIComponent(c),hasOwnProperty(o,i)?isArray(o[i])?o[i].push(l):o[i]=[o[i],l]:o[i]=l}return o};var isArray=Array.isArray||function(r){return"[object Array]"===Object.prototype.toString.call(r)};
},{}],4:[function(require,module,exports){
"use strict";function map(r,e){if(r.map)return r.map(e);for(var t=[],n=0;n<r.length;n++)t.push(e(r[n],n));return t}var stringifyPrimitive=function(r){switch(typeof r){case"string":return r;case"boolean":return r?"true":"false";case"number":return isFinite(r)?r:"";default:return""}};module.exports=function(r,e,t,n){return e=e||"&",t=t||"=",null===r&&(r=void 0),"object"==typeof r?map(objectKeys(r),function(n){var i=encodeURIComponent(stringifyPrimitive(n))+t;return isArray(r[n])?map(r[n],function(r){return i+encodeURIComponent(stringifyPrimitive(r))}).join(e):i+encodeURIComponent(stringifyPrimitive(r[n]))}).join(e):n?encodeURIComponent(stringifyPrimitive(n))+t+encodeURIComponent(stringifyPrimitive(r)):""};var isArray=Array.isArray||function(r){return"[object Array]"===Object.prototype.toString.call(r)},objectKeys=Object.keys||function(r){var e=[];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&e.push(t);return e};
},{}],5:[function(require,module,exports){
"use strict";exports.decode=exports.parse=require("./decode"),exports.encode=exports.stringify=require("./encode");
},{"./decode":3,"./encode":4}],6:[function(require,module,exports){
function Url(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function urlParse(t,s,e){if(t&&isObject(t)&&t instanceof Url)return t;var h=new Url;return h.parse(t,s,e),h}function urlFormat(t){return isString(t)&&(t=urlParse(t)),t instanceof Url?t.format():Url.prototype.format.call(t)}function urlResolve(t,s){return urlParse(t,!1,!0).resolve(s)}function urlResolveObject(t,s){return t?urlParse(t,!1,!0).resolveObject(s):s}function isString(t){return"string"==typeof t}function isObject(t){return"object"==typeof t&&null!==t}function isNull(t){return null===t}function isNullOrUndefined(t){return null==t}var punycode=require("punycode");exports.parse=urlParse,exports.resolve=urlResolve,exports.resolveObject=urlResolveObject,exports.format=urlFormat,exports.Url=Url;var protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,delims=["<",">",'"',"`"," ","\r","\n","	"],unwise=["{","}","|","\\","^","`"].concat(delims),autoEscape=["'"].concat(unwise),nonHostChars=["%","/","?",";","#"].concat(autoEscape),hostEndingChars=["/","?","#"],hostnameMaxLen=255,hostnamePartPattern=/^[a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([a-z0-9A-Z_-]{0,63})(.*)$/,unsafeProtocol={javascript:!0,"javascript:":!0},hostlessProtocol={javascript:!0,"javascript:":!0},slashedProtocol={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},querystring=require("querystring");Url.prototype.parse=function(t,s,e){if(!isString(t))throw new TypeError("Parameter 'url' must be a string, not "+typeof t);var h=t;h=h.trim();var r=protocolPattern.exec(h);if(r){r=r[0];var o=r.toLowerCase();this.protocol=o,h=h.substr(r.length)}if(e||r||h.match(/^\/\/[^@\/]+@[^@\/]+/)){var a="//"===h.substr(0,2);!a||r&&hostlessProtocol[r]||(h=h.substr(2),this.slashes=!0)}if(!hostlessProtocol[r]&&(a||r&&!slashedProtocol[r])){for(var n=-1,i=0;i<hostEndingChars.length;i++){var l=h.indexOf(hostEndingChars[i]);-1!==l&&(-1===n||n>l)&&(n=l)}var c,u;u=-1===n?h.lastIndexOf("@"):h.lastIndexOf("@",n),-1!==u&&(c=h.slice(0,u),h=h.slice(u+1),this.auth=decodeURIComponent(c)),n=-1;for(var i=0;i<nonHostChars.length;i++){var l=h.indexOf(nonHostChars[i]);-1!==l&&(-1===n||n>l)&&(n=l)}-1===n&&(n=h.length),this.host=h.slice(0,n),h=h.slice(n),this.parseHost(),this.hostname=this.hostname||"";var p="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!p)for(var f=this.hostname.split(/\./),i=0,m=f.length;m>i;i++){var v=f[i];if(v&&!v.match(hostnamePartPattern)){for(var g="",y=0,d=v.length;d>y;y++)g+=v.charCodeAt(y)>127?"x":v[y];if(!g.match(hostnamePartPattern)){var P=f.slice(0,i),b=f.slice(i+1),j=v.match(hostnamePartStart);j&&(P.push(j[1]),b.unshift(j[2])),b.length&&(h="/"+b.join(".")+h),this.hostname=P.join(".");break}}}if(this.hostname.length>hostnameMaxLen?this.hostname="":this.hostname=this.hostname.toLowerCase(),!p){for(var O=this.hostname.split("."),q=[],i=0;i<O.length;++i){var x=O[i];q.push(x.match(/[^A-Za-z0-9_-]/)?"xn--"+punycode.encode(x):x)}this.hostname=q.join(".")}var U=this.port?":"+this.port:"",C=this.hostname||"";this.host=C+U,this.href+=this.host,p&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==h[0]&&(h="/"+h))}if(!unsafeProtocol[o])for(var i=0,m=autoEscape.length;m>i;i++){var A=autoEscape[i],E=encodeURIComponent(A);E===A&&(E=escape(A)),h=h.split(A).join(E)}var w=h.indexOf("#");-1!==w&&(this.hash=h.substr(w),h=h.slice(0,w));var R=h.indexOf("?");if(-1!==R?(this.search=h.substr(R),this.query=h.substr(R+1),s&&(this.query=querystring.parse(this.query)),h=h.slice(0,R)):s&&(this.search="",this.query={}),h&&(this.pathname=h),slashedProtocol[o]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var U=this.pathname||"",x=this.search||"";this.path=U+x}return this.href=this.format(),this},Url.prototype.format=function(){var t=this.auth||"";t&&(t=encodeURIComponent(t),t=t.replace(/%3A/i,":"),t+="@");var s=this.protocol||"",e=this.pathname||"",h=this.hash||"",r=!1,o="";this.host?r=t+this.host:this.hostname&&(r=t+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(r+=":"+this.port)),this.query&&isObject(this.query)&&Object.keys(this.query).length&&(o=querystring.stringify(this.query));var a=this.search||o&&"?"+o||"";return s&&":"!==s.substr(-1)&&(s+=":"),this.slashes||(!s||slashedProtocol[s])&&r!==!1?(r="//"+(r||""),e&&"/"!==e.charAt(0)&&(e="/"+e)):r||(r=""),h&&"#"!==h.charAt(0)&&(h="#"+h),a&&"?"!==a.charAt(0)&&(a="?"+a),e=e.replace(/[?#]/g,function(t){return encodeURIComponent(t)}),a=a.replace("#","%23"),s+r+e+a+h},Url.prototype.resolve=function(t){return this.resolveObject(urlParse(t,!1,!0)).format()},Url.prototype.resolveObject=function(t){if(isString(t)){var s=new Url;s.parse(t,!1,!0),t=s}var e=new Url;if(Object.keys(this).forEach(function(t){e[t]=this[t]},this),e.hash=t.hash,""===t.href)return e.href=e.format(),e;if(t.slashes&&!t.protocol)return Object.keys(t).forEach(function(s){"protocol"!==s&&(e[s]=t[s])}),slashedProtocol[e.protocol]&&e.hostname&&!e.pathname&&(e.path=e.pathname="/"),e.href=e.format(),e;if(t.protocol&&t.protocol!==e.protocol){if(!slashedProtocol[t.protocol])return Object.keys(t).forEach(function(s){e[s]=t[s]}),e.href=e.format(),e;if(e.protocol=t.protocol,t.host||hostlessProtocol[t.protocol])e.pathname=t.pathname;else{for(var h=(t.pathname||"").split("/");h.length&&!(t.host=h.shift()););t.host||(t.host=""),t.hostname||(t.hostname=""),""!==h[0]&&h.unshift(""),h.length<2&&h.unshift(""),e.pathname=h.join("/")}if(e.search=t.search,e.query=t.query,e.host=t.host||"",e.auth=t.auth,e.hostname=t.hostname||t.host,e.port=t.port,e.pathname||e.search){var r=e.pathname||"",o=e.search||"";e.path=r+o}return e.slashes=e.slashes||t.slashes,e.href=e.format(),e}var a=e.pathname&&"/"===e.pathname.charAt(0),n=t.host||t.pathname&&"/"===t.pathname.charAt(0),i=n||a||e.host&&t.pathname,l=i,c=e.pathname&&e.pathname.split("/")||[],h=t.pathname&&t.pathname.split("/")||[],u=e.protocol&&!slashedProtocol[e.protocol];if(u&&(e.hostname="",e.port=null,e.host&&(""===c[0]?c[0]=e.host:c.unshift(e.host)),e.host="",t.protocol&&(t.hostname=null,t.port=null,t.host&&(""===h[0]?h[0]=t.host:h.unshift(t.host)),t.host=null),i=i&&(""===h[0]||""===c[0])),n)e.host=t.host||""===t.host?t.host:e.host,e.hostname=t.hostname||""===t.hostname?t.hostname:e.hostname,e.search=t.search,e.query=t.query,c=h;else if(h.length)c||(c=[]),c.pop(),c=c.concat(h),e.search=t.search,e.query=t.query;else if(!isNullOrUndefined(t.search)){if(u){e.hostname=e.host=c.shift();var p=e.host&&e.host.indexOf("@")>0?e.host.split("@"):!1;p&&(e.auth=p.shift(),e.host=e.hostname=p.shift())}return e.search=t.search,e.query=t.query,isNull(e.pathname)&&isNull(e.search)||(e.path=(e.pathname?e.pathname:"")+(e.search?e.search:"")),e.href=e.format(),e}if(!c.length)return e.pathname=null,e.search?e.path="/"+e.search:e.path=null,e.href=e.format(),e;for(var f=c.slice(-1)[0],m=(e.host||t.host)&&("."===f||".."===f)||""===f,v=0,g=c.length;g>=0;g--)f=c[g],"."==f?c.splice(g,1):".."===f?(c.splice(g,1),v++):v&&(c.splice(g,1),v--);if(!i&&!l)for(;v--;v)c.unshift("..");!i||""===c[0]||c[0]&&"/"===c[0].charAt(0)||c.unshift(""),m&&"/"!==c.join("/").substr(-1)&&c.push("");var y=""===c[0]||c[0]&&"/"===c[0].charAt(0);if(u){e.hostname=e.host=y?"":c.length?c.shift():"";var p=e.host&&e.host.indexOf("@")>0?e.host.split("@"):!1;p&&(e.auth=p.shift(),e.host=e.hostname=p.shift())}return i=i||e.host&&c.length,i&&!y&&c.unshift(""),c.length?e.pathname=c.join("/"):(e.pathname=null,e.path=null),isNull(e.pathname)&&isNull(e.search)||(e.path=(e.pathname?e.pathname:"")+(e.search?e.search:"")),e.auth=t.auth||e.auth,e.slashes=e.slashes||t.slashes,e.href=e.format(),e},Url.prototype.parseHost=function(){var t=this.host,s=portPattern.exec(t);s&&(s=s[0],":"!==s&&(this.port=s.substr(1)),t=t.substr(0,t.length-s.length)),t&&(this.hostname=t)};
},{"punycode":2,"querystring":5}],7:[function(require,module,exports){
(function (global){
!function(global,browser){"use strict";var AbstractError,AlreadyDefinedError,AlreadyUsedError,ArgumentError,Class,CustomError,Deferred,DeniedError,InvalidError,NotFoundError,Promise,RejectedError,RequiredError,UnavailableError,UndefinedError,ValidationError,addAttribute,addAttributes,addClass,after,alignElement,and,append,appendChild,apply,ary,assert,assertArgument,assertOption,assign,at,attempt,before,call,camelCase,capitalize,capture,chunk,clean,clone,cloneDeep,compact,concat,countBy,createElement,createElementNS,debounce,deburr,defaults,defineProperties,defineProperty,delay,difference,drop,dropRight,dropRightWhile,dropWhile,endsWith,escape,escapeRegExp,every,fileExtension,fileName,filter,filterElements,find,findDeep,findElement,findElements,findIndex,findKey,findLast,findLastElement,findLastIndex,findLastKey,findNextElement,findNextElements,findParentElement,findPreviousElement,findPreviousElements,findSiblingElement,findSiblingElements,first,fit,fixed,flatten,flattenDeep,flush,forEach,forEachRight,forIn,forInRight,forOwn,forOwnRight,freeze,functions,getAllNext,getAllNextElements,getAllPrevious,getAllPreviousElements,getAllSiblingElements,getAllSiblings,getAttribute,getAttributes,getBoundings,getChildren,getDistributedElement,getDistributedElements,getElement,getElementById,getElements,getHTML,getHeight,getMargin,getNext,getNextElement,getNode,getNodes,getPadding,getParentElement,getPrevious,getPreviousElement,getSiblingElements,getSiblings,getStyle,getStyles,getTag,getText,getWidth,groupBy,has,hasAttribute,hasChild,hasClass,includes,includesDeep,indexBy,indexOf,initial,intersection,invert,invoke,isAny,isArguments,isArray,isArrayable,isBase62,isBindable,isBoolean,isBrowser,isCamelCase,isCapitalize,isClean,isCollection,isContent,isCustomEvent,isDate,isDefined,isElement,isEmpty,isEnumerable,isEqual,isEquivalent,isError,isEscape,isEscapeRegExp,isEven,isEvent,isExotic,isFalse,isFinite,isFloat,isFunction,isHex,isIndex,isInfinite,isInput,isInstance,isInt,isKebabCase,isKeyCase,isLast,isLastIndex,isLowerCase,isNaN,isNative,isNegative,isNode,isNull,isNullable,isNumber,isNumeric,isObject,isObservable,isOdd,isPlainObject,isPolyfilled,isPositive,isPredicate,isPrevented,isPrimitive,isRegExp,isSelector,isShady,isStartCase,isString,isTemplate,isTrue,isUniq,isUpperCase,isVoid,isWithin,iterate,kebabCase,keyCase,keys,keysIn,last,lastIndexOf,listen,localize,lowerCase,map,mapOne,mapValues,match,matches,max,memoize,merge,min,mock,moveFirst,moveLast,nand,negate,nor,not,omit,onMutation,once,or,overwrite,pad,padLeft,padRight,pairs,parallel,parseBase62,parseHex,parseJSON,parseURL,partition,pick,pluck,prefix,prependChild,preventDefault,pull,pullAt,push,random,range,readable,redirect,reduce,reduceRight,reject,remove,removeAttribute,removeAttributes,removeChild,removeClass,removeStyle,removeStyles,renameElement,repeat,replaceNode,requestAnimationFrame,rest,round,sample,seal,setAttribute,setAttributes,setChildren,setHTML,setStyle,setStyles,setText,shrink,shuffle,size,slice,snakeCase,some,sortBy,split,startCase,startsWith,stop,stopPropagation,stretch,strip,suffix,take,takeRight,takeRightWhile,takeWhile,throttle,toArray,toBase62,toBoolean,toDOMIdentity,toDOMPredicate,toElapsedTime,toHex,toIndex,toInfinite,toInput,toInt,toJSON,toNumber,toObject,toPosition,toQueryString,toRegExp,toString,toTemplate,toURL,toUseful,toValue,toggleAttribute,toggleClass,trim,trimLeft,trimRight,trunc,unescape,union,uniq,unlisten,unzip,updateElement,upperCase,value,valueIn,values,valuesIn,waterfall,where,willBleedBottom,willBleedHorizontally,willBleedLeft,willBleedRight,willBleedTop,willBleedVertically,withdraw,within,without,words,wrap,xnor,xor,zip,zipObject,exp=module.exports,lodash=require("lodash"),q=require("q"),url=require("url");exp.AbstractError=AbstractError=function(e){CustomError.call(this,"AbstractError",e,"is abstract and should be implemented first")},exp.AlreadyDefinedError=AlreadyDefinedError=function(e){CustomError.call(this,"AlreadyDefinedError",e,"is already defined")},exp.AlreadyUsedError=AlreadyUsedError=function(e){CustomError.call(this,"AlreadyUsedError",e,"is already used")},exp.ArgumentError=ArgumentError=function(e,t){CustomError.call(this,"ArgumentError",(toPosition(e)||"Unknown")+" argument","must be "+t)},exp.Class=Class=function Class(name,opt){assertArgument(isString(name,!0),1,"string"),assertArgument(isVoid(opt)||isObject(opt),2,"Object"),opt=opt||{};var Constructor=null,Super=withdraw(opt,"extends")||Function,initialize=withdraw(opt,"initialize")||Super,options=withdraw(opt,"options");return eval("Constructor = function "+name+"() {    var self = this, promised = self.promise;    self.options = self.options || Constructor.options;    self.plugins = self.plugins || {};    self.promise = self.promise || (initialize.promise ? new Promise(arguments, initialize.value, self) : null);    return initialize !== Function && (promised || !initialize.promise) ? initialize.apply(self, arguments) : self;};"),Constructor.prototype=Object.create(Super.prototype,{constructor:{configurable:!0,value:Constructor,writable:!0}}),defineProperties(Constructor,{options:{"static":!0,value:assign({},Super.options,options)}}),defineProperties(Constructor,{addPlugin:function(e,t){assertArgument(isString(e,!0),1,"string"),assertArgument(isFunction(t),2,"Function");var r=this;return push(r.plugins[e]=r.plugins[e]||[],t),r},getPlugins:function(e){return assertArgument(isString(e,!0),1,"string"),this.plugins?this.plugins[e]||[]:[]},invokePlugins:function(e,t,r){assertArgument(isString(e,!0),1,"string"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable"),assertArgument(isVoid(r)||isFunction(r),3,"Function");var n=this,i=function(e){e.apply(void 0,concat([null],t,[n]))};return waterfall(concat([i],n.getPlugins(e)),r),n},removePlugin:function(e,t){assertArgument(isString(e,!0),1,"string"),assertArgument(isFunction(t),2,"Function");var r=this;return pull(r.getPlugins(e),t),r},removePlugins:function(e){assertArgument(isString(e,!0),1,"string");var t=this;return flush(t.getPlugins(e)),t},rejected:function(e){return assertArgument(isFunction(e),1,"Function"),assign(this,this.promise?{promise:this.promise["catch"](function(t){throw e(t),t})}:{})},resolved:function(e){return assertArgument(isFunction(e),1,"Function"),assign(this,this.promise?{promise:this.promise.then(function(t){return e(t),t})}:{})},options:{set:function(e){return assign(this.options||{},e)},then:function(e){var t=this;forOwn(e.plugins||{},function(r,n){t.addPlugin(n,r),delete e.plugins[n]})}},plugins:{set:function(e){return assign(this.plugins||{},e)}},promise:{enumerable:!1,validate:function(e){return isObject(e)||isVoid(e)}},resolver:{validate:function(e){return isFunction(e)||isVoid(e)}}}),defineProperties(Constructor,opt),Constructor},exp.CustomError=CustomError=function(e,t,r){var n=Error.call(this,t+(r?" "+r:""));n.name=e,this.message=n.message,this.stack=n.stack},exp.Deferred=Deferred=function(){return q.defer()},exp.DeniedError=DeniedError=function(e){CustomError.call(this,"DeniedError",e,"is denied")},exp.InvalidError=InvalidError=function(e){CustomError.call(this,"InvalidError",e,"is not valid")},exp.NotFoundError=NotFoundError=function(e){CustomError.call(this,"NotFoundError",e,"is not found")},exp.Promise=Promise=function(e,t,r){assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isFunction(t),2,"Function"),assertArgument(isBindable(r),3,"Array, Function or Object");var n,i,s,o=new Deferred,a=o.promise;if(isArray(e=fit(e,t.length),!0)){for(s=e.length-1,i=s;i>=0;i-=1)if(isFunction(e[i])){for(n=e[i];s>i;i+=1)e[i]=void 0;break}e[s]=function(e,t){o[e?"reject":"resolve"](e||t)}}return t.apply(r,e),n&&(a=a.then(function(e){return n(null,e),e})),n&&(a=a["catch"](function(e){throw n(e,null),e})),a},exp.RejectedError=RejectedError=function(e){CustomError.call(this,"RejectedError",e,"is rejected")},exp.RequiredError=RequiredError=function(e){CustomError.call(this,"RequiredError",e,"is required")},exp.UnavailableError=UnavailableError=function(e){CustomError.call(this,"UnavailableError",e,"is not available")},exp.UndefinedError=UndefinedError=function(e){CustomError.call(this,"UndefinedError",e,"is not defined")},exp.ValidationError=ValidationError=function(e,t){CustomError.call(this,"ValidationError",e,"must be "+t)},exp.addAttribute=addAttribute=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e.setAttribute(t,""),e},exp.addAttributes=addAttributes=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||!isArrayable(t),2,"Arrayable"),e&&t&&forEach(t,function(t){addAttribute(e,t)}),e},exp.addClass=addClass=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e.classList.add(t),e},exp.after=after=function(e,t){return assertArgument(isIndex(e),1,"number"),assertArgument(isFunction(t),2,"Function"),lodash.after(e,t)},exp.alignElement=alignElement=function(e,t,r,n){if(assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isElement(t),2,"Element"),assertArgument(isVoid(r)||isString(r),3,"string"),e){setStyles(e,{position:"fixed",bottom:null,left:0,right:null,top:0});var i,s=getHeight(),o=getWidth(),a=getMargin(e),u=getBoundings(e),l=getBoundings(t||global.document.documentElement);return u.left=l.left+("aside"===r?l.width:n||!t?l.width/2-u.width/2:0)-a.left,u.top=l.top+("baseline"===r?l.height:t?0:l.height/2-u.height/2)-a.top,willBleedRight(u,a)&&(u.left="aside"===r?u.left-(l.width+u.width):o-(a.left+u.width+a.right)),willBleedLeft(u,a)&&(u.left="aside"!==r||willBleedHorizontally(u,a)?0:o-(a.left+u.width+a.right)),willBleedBottom(u,a)&&(u.top=s-(a.top+u.height+a.bottom)),willBleedTop(u,a)&&(u.top=0),setStyles(e,{left:u.left+"px",right:willBleedRight(u,a)?"0px":null}),setStyles(e,{top:u.top+"px",bottom:willBleedBottom(u,a)?"0px":null}),i=getBoundings(e),(i.left-=a.left)!==u.left&&setStyles(e,{left:2*u.left-i.left+"px",right:willBleedRight(u,a)?u.left-i.left+"px":null}),(i.top-=a.top)!==u.top&&setStyles(e,{top:2*u.top-i.top+"px",bottom:willBleedBottom(u,a)?u.top-i.top+"px":null}),e}},exp.and=and=function(e,t){return Boolean(e&&t)},exp.append=append=function(e,t){return assertArgument(isString(e)||isArray(e),1,"Array or string"),includes(e,t)?isString(e)?e:t:push(e,t)},exp.appendChild=appendChild=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isNode(t),2,"Node"),e&&t?e.appendChild(t):void 0},exp.apply=apply=function(e,t,r){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),assertArgument(isString(t,!0),2,"string"),assertArgument(isVoid(r)||isArrayable(r),3,"Arrayable"),isFunction(e[t])?e[t].apply(e,toArray(r)||[]):void 0},exp.ary=ary=function(e,t){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.ary(e,t)},exp.assert=assert=function(e,t){return!e&&isFunction(t)?t():void 0},exp.assertArgument=assertArgument=function(e,t,r){assert(e,function(){throw new ArgumentError(t,r)})},exp.assertOption=assertOption=function(e,t,r){assert(e,function(){throw new ValidationError(t,r)})},exp.assign=assign=function(e,t){return assertArgument(isObject(e),1,"Object"),lodash.assign.apply(lodash,filter(arguments,ary(isObject,1)))},exp.at=at=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(t=toArray(t),2,"Arrayable"),lodash.at(e,t)},exp.attempt=attempt=function(e,t){function r(){var e=slice(arguments);delay(function(){n.apply(void 0,e)})}assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isFunction(t),2,"Function");var n=t||mock();try{e(r)}catch(i){n(i,null)}},exp.before=before=function(e,t){return assertArgument(isIndex(e),1,"number"),assertArgument(isFunction(t),2,"Function"),lodash.before(e,t)},exp.call=call=function(e,t,r){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),assertArgument(isString(t,!0),2,"string"),isFunction(e[t])?e[t].apply(e,slice(arguments,2)):void 0},exp.camelCase=camelCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.camelCase(e):""},exp.capitalize=capitalize=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.capitalize(e):""},exp.capture=capture=function(e,t){return assertArgument(isFunction(e),1,"Function"),function(){try{return e.apply(t,arguments)}catch(r){}}},exp.chunk=chunk=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.chunk(e,t)},exp.clean=clean=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?trim(e.replace(/[ ]+/g," ")):""},exp.clone=clone=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isFunction(t),2,"Function"),lodash.clone(e,t,r)},exp.cloneDeep=cloneDeep=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isFunction(t),2,"Function"),lodash.cloneDeep(e,t,r)},exp.compact=compact=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.compact(e)},exp.concat=concat=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),slice(arguments,1).forEach(function(t){isDefined(t=toArray(t))&&t.forEach(function(t){e.push(t)})}),e},exp.countBy=countBy=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.countBy(e,t,r)},exp.createElement=createElement=function(e,t){return assertArgument(isString(e,!0),1,"string"),assertArgument(isVoid(t)||isObject(t),2,"Object"),updateElement(global.document.createElement(e),t)},exp.createElementNS=createElementNS=function(e,t,r){return assertArgument(isString(e,!0),1,"string"),assertArgument(isString(t,!0),2,"string"),assertArgument(isVoid(r)||isObject(r),3,"Object"),updateElement(global.document.createElementNS(e,t),r)},exp.debounce=debounce=function(e,t,r){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isObject(r),3,"Object"),lodash.debounce(e,t,r)},exp.deburr=deburr=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.deburr(e):""},exp.defaults=defaults=function(e,t){return assertArgument(isObject(e),1,"Object"),lodash.defaults.apply(lodash,filter(arguments,ary(isObject,1)))},exp.defineProperties=defineProperties=function(e,t){return assertArgument(isFunction(e)||isObject(e),1,"Function or Object"),assertArgument(isObject(t),2,"Object"),forOwn(t,function(t,r){defineProperty(e,r,t)}),e},exp.defineProperty=defineProperty=function(e,t,r){assertArgument(isFunction(e)||isObject(e),1,"Function or Object"),assertArgument(isString(t,!0),2,"string"),assertArgument(isFunction(r)||isObject(r),3,"Function or Object"),r=isFunction(r)?{value:r}:r,r.enumerable=value(r,"enumerable",!0);var n=r.value,i=isFunction(r.get),s=isFunction(r.set),o=isFunction(r.validate),a=!i&&!s;return a&&r.promise&&(r.value=function(){return new Promise(arguments,n,this)}),i&&!s&&(r.set=function(e){return e}),!s||i||o||(r.validate=function(){return!0}),isFunction(e)&&!r["static"]&&(e=e.prototype),Object.defineProperty(e,t,assign({configurable:!0,enumerable:r.enumerable},a?{value:value(r,"value"),writable:value(r,"writable",!0)}:{get:i?r.get:function(){return value(this,t+"_")},set:i?r.set:function(e){var n=this,i=t+"_",s=n[i],o=r.set.call(n,e);if(!r.validate.call(n,o))throw new InvalidError(t);has(n,i)?n[i]=o:Object.defineProperty(n,i,{configurable:!0,enumerable:r.enumerable,writable:!0,value:o}),r.sealed&&seal(o),r.frozen&&freeze(o),r.then&&r.then.call(n,o,s)}})),a&&r.sealed&&seal(e[t]),a&&r.frozen&&freeze(e[t]),e},exp.delay=delay=function(e,t){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isIndex(t),2,"number"),t>0?lodash.delay(e,t):lodash.defer(e)},exp.difference=difference=function(e,t){return lodash.difference.apply(lodash,map(filter(arguments,ary(isArrayable,1)),ary(toArray,1)))},exp.drop=drop=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.drop(e,t)},exp.dropRight=dropRight=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.dropRight(e,t)},exp.dropRightWhile=dropRightWhile=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function | Object | string"),lodash.dropRightWhile(e,t,r)},exp.dropWhile=dropWhile=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function | Object | string"),lodash.dropWhile(e,t,r)},exp.endsWith=endsWith=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.endsWith(e,(r||"")+(t||""))},exp.escape=escape=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.escape(e):""},exp.escapeRegExp=escapeRegExp=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.escapeRegExp(e):""},exp.every=every=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.every(e,t,r)},exp.fileExtension=fileExtension=function(e){assertArgument(isVoid(e)||isString(e),1,"string");var t=e?e.lastIndexOf("."):-1;return t>0?e.slice(t+1):""},exp.fileName=fileName=function(e){assertArgument(isVoid(e)||isString(e),1,"string");var t=e?e.lastIndexOf("."):-1;return t>0?e.slice(0,t):""},exp.filter=filter=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.filter(e,t,r)},exp.filterElements=filterElements=function(e,t){var r=toDOMPredicate(t);return assertArgument(isArrayable(e),1,"Arrayable"),assertArgument(r,2,"Function or string"),filter(e,r)},exp.find=find=function(e,t,r){var n=toIndex(t);return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t)||isIndex(n),2,"Function, number, Object or string"),isIndex(n)?e[n]:isPredicate(t)?lodash.find(e,t,r):void 0},exp.findDeep=findDeep=function e(t,r,n){return assertArgument(isCollection(t),1,"Arrayable or Object"),assertArgument(isPredicate(r),2,"Function, Object or string"),assertArgument(isVoid(n)||isString(n),3,"string"),n&&(t=value(t,n)),n&&!isCollection(t)?void 0:find(t,r)||mapOne(t,function(t){return isCollection(t)?e(t,r,n):void 0})},exp.findElement=findElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function, Object or string"),find(filterElements(e.children,r),n)},exp.findElements=findElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function, Object or string"),filter(filterElements(e.children,r),n)},exp.findIndex=findIndex=function(e,t,r){assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function | Object | string");var n=lodash.findIndex(e,t,r);return isIndex(n)?n:void 0},exp.findKey=findKey=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isPredicate(t),2,"Function | Object | string"),lodash.findKey(e,t,r)},exp.findLast=findLast=function(e,t,r){var n=toIndex(t);return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t)||isIndex(n),2,"Function, number, Object or string"),isIndex(n)?e[n]:isPredicate(t)?lodash.findLast(e,t,r):void 0},exp.findLastElement=findLastElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function, Object or string"),findLast(filterElements(e.children,r),n)},exp.findLastIndex=findLastIndex=function(e,t,r){assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function | Object | string");var n=lodash.findLastIndex(e,t,r);return isIndex(n)?n:void 0},exp.findLastKey=findLastKey=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isPredicate(t),2,"Function | Object | string"),lodash.findLastKey(e,t,r)},exp.findNextElement=findNextElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function or string"),find(filterElements(getAllNextElements(e),r),n)},exp.findNextElements=findNextElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function, Object or string"),filter(filterElements(getAllNextElements(e),r),n)},exp.findParentElement=findParentElement=function(e,t,r){if(assertArgument(isNode(e),1,"Node"),assertArgument(isVoid(t)||isSelector(t),2,"string"),assertArgument(isVoid(r)||isNode(r),3,"Node"),e!==r){do e=e.parentNode||e.host;while(e&&(1!==e.nodeType||t&&!matches(e,t))&&e!==r);return!isNode(e,1)||t&&!matches(e,t)?void 0:e}},exp.findPreviousElement=findPreviousElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function or string"),findLast(filterElements(getAllPreviousElements(e),r),n)},exp.findPreviousElements=findPreviousElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function or string"),filter(filterElements(getAllPreviousElements(e),r),n)},exp.findSiblingElement=findSiblingElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function or string"),findPreviousElement(e,t,r)||findNextElement(e,t,r)},exp.findSiblingElements=findSiblingElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function, Object or string"),filter(filterElements(getAllSiblingElements(e),r),n)},exp.first=first=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.first(e)},exp.fit=fit=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"number"),e.length<t?stretch(e,t,r):shrink(e,t,r)},exp.fixed=fixed=function(e,t){assertArgument(isFinite(e),1,"number"),assertArgument(isVoid(t)||isIndex(t),2,"number");var r=round(e,t).toString();return t&&(r=append(r,".")),t&&(r+=repeat("0",t+r.indexOf(".")+1-r.length)),r},exp.flatten=flatten=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.flatten(e)},exp.flattenDeep=flattenDeep=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.flattenDeep(e)},exp.flush=flush=function(e){if(assertArgument(isCollection(e=toArray(e)||e)||isElement(e),1,"Arrayable, Element or Object"),isArray(e)){for(;e.length;)e.pop();return e}return isElement(e)?(e.innerHTML="",e):(isObject(e)&&forOwn(e,function(t,r){delete e[r]}),e)},exp.forEach=forEach=function(e,t,r){return assertArgument(isCollection(e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),lodash.forEach(e,t,r)},exp.forEachRight=forEachRight=function(e,t,r){return assertArgument(isCollection(e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),lodash.forEachRight(e,t,r)},exp.forIn=forIn=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t),2,"Function"),lodash.forIn(e,t,r)},exp.forInRight=forInRight=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t),2,"Function"),lodash.forInRight(e,t,r)},exp.forOwn=forOwn=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t),2,"Function"),lodash.forOwn(e,t,r)},exp.forOwnRight=forOwnRight=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t),2,"Function"),lodash.forOwn(e,t,r)},exp.freeze=freeze=function(e){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),Object.freeze(e)},exp.functions=functions=function(e){return assertArgument(isObject(e),1,"Object"),lodash.functions(e)},exp.getAllNext=getAllNext=function(e,t){assertArgument(e=toArray(e),1,"Arrayable");var r=indexOf(e,t);return isIndex(r)?slice(e,r+1):[]},exp.getAllNextElements=getAllNextElements=function(e){return assertArgument(isElement(e),1,"Element"),getAllNext(getChildren(getParentElement(e)),e)},exp.getAllPrevious=getAllPrevious=function(e,t){assertArgument(e=toArray(e),1,"Arrayable");var r=indexOf(e,t);return isIndex(r)?slice(e,0,r):[]},exp.getAllPreviousElements=getAllPreviousElements=function(e){return assertArgument(isElement(e),1,"Element"),getAllPrevious(getChildren(getParentElement(e)),e)},exp.getAllSiblingElements=getAllSiblingElements=function(e){return assertArgument(isElement(e),1,"Element"),getAllSiblings(getChildren(getParentElement(e)),e)},exp.getAllSiblings=getAllSiblings=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),concat(getAllPrevious(e,t),getAllNext(e,t))},exp.getAttribute=getAttribute=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isString(t,!0),2,"string"),e.getAttribute(t)},exp.getAttributes=getAttributes=function(e,t){assertArgument(isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable");var r={};return forEach(t||[],function(t){r[t]=getAttribute(e,t)}),forEach(t?[]:e.attributes,function(e){r[e.name]=e.value}),r},exp.getBoundings=getBoundings=function(e){assertArgument(isElement(e),1,"Element");var t=e.getBoundingClientRect();return{bottom:t.bottom,height:t.height,left:t.left,right:t.right,top:t.top,width:t.width}},exp.getChildren=getChildren=function(e){return assertArgument(isElement(e),1,"Element"),toArray(e.children)},exp.getDistributedElement=getDistributedElement=function(e,t,r){var n=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Element, Function or string"),find(filterElements(e.getDistributedNodes(),r),n)},exp.getDistributedElements=getDistributedElements=function(e,t,r){var n=toDOMPredicate(t);return assertArgument(isElement(e),1,"Element"),assertArgument(n,2,"Function or string"),filter(filterElements(e.getDistributedNodes(),r),n)},exp.getElement=getElement=function(e,t){return isSelector(e)&&(t=e,e=global.document),assertArgument(isElement(e)||isNode(e,9),1,"Element or HTMLDocument"),assertArgument(isVoid(t)||isSelector(t),2,"string"),isSelector(t)?e.querySelector(t)||void 0:isElement(e)?findElement(e,t):findElement(e.body,t)},exp.getElementById=getElementById=function(e,t){return isSelector(e)&&(t=e,e=global.document),assertArgument(isNode(e,9),1,"HTMLDocument"),assertArgument(isString(t,!0),2,"string"),e.getElementById(t)||void 0},exp.getElements=getElements=function(e,t){return isSelector(e)&&(t=e,e=document),assertArgument(isElement(e)||isNode(e,9),1,"Element or HTMLDocument"),assertArgument(isVoid(t)||isSelector(t),2,"string"),isSelector(t)?toArray(e.querySelectorAll(t)):isElement(e)?findElements(e,t):findElements(e.body,t)},exp.getHTML=getHTML=function(e){return assertArgument(isElement(e),1,"Element"),(isTemplate(e)?e.instanceRef_:e).innerHTML},exp.getHeight=getHeight=function(e){return assertArgument(isVoid(e)||isElement(e),1,"Element"),Math.floor(e?getBoundings(e).height:global.innerHeight)},exp.getMargin=getMargin=function(e){assertArgument(isElement(e),1,"Element");var t=["bottom","left","right","top"],r="margin-";return zipObject(t,map(getStyles(e,map(t,function(e){return r+e})),ary(toNumber,1)))},exp.getNext=getNext=function(e,t){assertArgument(e=toArray(e),1,"Arrayable");var r=indexOf(e,t);return isIndex(r)?e[r+1]:void 0},exp.getNextElement=getNextElement=function(e){return assertArgument(isElement(e),1,"Element"),getNext(getChildren(getParentElement(e)),e)},exp.getNode=getNode=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isIndex(t),2,"number"),(isContent(e)?e.getDistributedNodes():e.childNodes)[t]},exp.getNodes=getNodes=function(e){return assertArgument(isElement(e),1,"Element"),toArray(isContent(e)?e.getDistributedNodes():e.childNodes)},exp.getPadding=getPadding=function(e){assertArgument(isElement(e),1,"Element");var t=["bottom","left","right","top"],r="padding-";return zipObject(t,map(getStyles(e,map(t,function(e){return r+e})),ary(toNumber,1)))},exp.getParentElement=getParentElement=function(e){return assertArgument(isNode(e),1,"Node"),e.parentNode},exp.getPrevious=getPrevious=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),e[indexOf(e,t)-1]},exp.getPreviousElement=getPreviousElement=function(e){return assertArgument(isElement(e),1,"Element"),getPrevious(getChildren(getParentElement(e)),e)},exp.getSiblingElements=getSiblingElements=function(e){return assertArgument(isElement(e),1,"Element"),getSiblings(getChildren(getParentElement(e)),e)},exp.getSiblings=getSiblings=function(e,t){assertArgument(e=toArray(e),1,"Arrayable");var r=getPrevious(e,t),n=getNext(e,t);return concat(r?[r]:[],n?[n]:[])},exp.getStyle=getStyle=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isString(t,!0),2,"string"),global.getComputedStyle(e)[t]},exp.getStyles=getStyles=function(e,t){assertArgument(isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable");var r=global.getComputedStyle(e);return t?pick(r,t):assign({},r)},exp.getTag=getTag=function(e){return assertArgument(isElement(e),1,"Element"),e.tagName.toLowerCase()},exp.getText=getText=function(e){return assertArgument(isNode(e),1,"Node"),isTemplate(e)?"":e.textContent},exp.getWidth=getWidth=function(e){return assertArgument(isVoid(e)||isElement(e),1,"Element"),Math.floor(e?getBoundings(e).width:global.innerWidth)},exp.groupBy=groupBy=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.groupBy(e,t,r)},exp.has=has=function(e,t){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),assertArgument(isString(t),2,"string"),lodash.has(e,t)},exp.hasAttribute=hasAttribute=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isString(t,!0),2,"string"),e.hasAttribute(t)},exp.hasChild=hasChild=function(e,t){var r=toDOMIdentity(t);return assertArgument(isElement(e),1,"Element"),assertArgument(r,2,"Element, Function or string"),!!findElement(e,t)},exp.hasClass=hasClass=function(e,t){return assertArgument(isElement(e),1,"Element"),assertArgument(isString(t,!0),2,"string"),e.classList.contains(t)},exp.includes=includes=function(e,t,r){return assertArgument(isString(e)||isCollection(e=toArray(e)||e),1,"Arrayable, Object or string"),assertArgument(isVoid(r)||isFinite(r),3,"number"),lodash.includes(e,t,r)},exp.includesDeep=includesDeep=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),!!findDeep(e,function(e){return e===t})},exp.indexBy=indexBy=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.indexBy(e,t,r)},exp.indexOf=indexOf=function(e,t,r){assertArgument(isString(e)||isDefined(e=toArray(e)),1,"Arrayable or string"),assertArgument(isVoid(r)||isFinite(r),3,"number");var n=isArray(e)?lodash.indexOf(e,t,r):isString(t)?e.indexOf(t):-1;return isIndex(n)?n:void 0},exp.initial=initial=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.initial(e)},exp.intersection=intersection=function(e){return lodash.intersection.apply(lodash,map(filter(arguments,ary(isArrayable,1)),ary(toArray,1)))},exp.invert=invert=function(e,t){return assertArgument(isObject(e),1,"Object"),lodash.invert(e,!!t)},exp.invoke=invoke=function(e,t,r){
return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isString(t,!0),2,"Function or string"),lodash.invoke.apply(lodash,concat([e,t],slice(arguments,2)))},exp.isAny=isAny=function(e){return!isNullable(e)},exp.isArguments=isArguments=function(e,t){return lodash.isArguments(e)&&(isVoid(t)||xnor(e.length,t))},exp.isArray=isArray=function(e,t){return lodash.isArray(e)&&(isVoid(t)||xnor(e.length,t))},exp.isArrayable=isArrayable=function(e,t){return!!e&&"object"==typeof e&&isIndex(e.length)&&(isVoid(t)||xnor(e.length,t))},exp.isBase62=isBase62=function(e){return isString(e)&&/^[0-9A-Za-z]+$/.test(e)},exp.isBindable=isBindable=function(e,t){return isArray(e)||isFunction(e)||isObject(e)||!t&&isVoid(e)},exp.isBoolean=isBoolean=function(e){return lodash.isBoolean(e)},exp.isBrowser=isBrowser=function(){return browser},exp.isCamelCase=isCamelCase=function(e,t){return isString(e)&&e===camelCase(e)&&(isVoid(t)||xnor(e.length,t))},exp.isCapitalize=isCapitalize=function(e,t){return isString(e)&&e===capitalize(e)&&(isVoid(t)||xnor(e.length,t))},exp.isClean=isClean=function(e,t){return isString(e)&&e===clean(e)&&(isVoid(t)||xnor(e.length,t))},exp.isCollection=isCollection=function(e,t){return isArrayable(e,t)||isObject(e,t)},exp.isContent=isContent=function(e,t){return isElement(e)&&"content"===(e.node||e).tagName.toLowerCase()?!isVoid(t)&&xor(t,find(e.getDistributedNodes(),function(e){return 1===e.nodeType&&"template"!==e.tagName.toLowerCase()||3!==e.nodeType||trim(e.textContent,"\r\n ")}))?!1:!0:!1},exp.isCustomEvent=isCustomEvent=function(e,t){return isEvent(e,t)&&!!e.detail},exp.isDate=isDate=function(e){return lodash.isDate(e)},exp.isDefined=isDefined=function(e){return void 0!==e},exp.isElement=isElement=function(e,t){return lodash.isElement(e)||isPolyfilled(e)||isShady(e)&&1===e.node.nodeType?!isVoid(t)&&xor(t,find(e.childNodes,function(e){return 1!==e.nodeType||"template"!==e.tagName.toLowerCase()}))?!1:!0:!1},exp.isEmpty=isEmpty=function(e){return isNullable(e)||isArrayable(e,!1)||isElement(e,!1)||isObject(e,!1)},exp.isEnumerable=isEnumerable=function(e,t){return assertArgument(isBindable(t),2,"Array, Function or Object"),isString(e,!0)&&has(t,e)&&t.propertyIsEnumerable(e)},exp.isEqual=isEqual=function(e,t,r,n){return assertArgument(isVoid(r)||isFunction(r),3,"Function"),lodash.isEqual(e,t,r,n)},exp.isEquivalent=isEquivalent=function(e,t){return toJSON(e,!0)===toJSON(t,!0)},exp.isError=isError=function(e){return lodash.isError(e)},exp.isEscape=isEscape=function(e,t){return isString(e)&&e===escape(e)&&(isVoid(t)||xnor(e.length,t))},exp.isEscapeRegExp=isEscapeRegExp=function(e,t){return isString(e)&&e===escapeRegExp(e)&&(isVoid(t)||xnor(e.length,t))},exp.isEven=isEven=function(e,t){return isFinite(e)&&e%2===0&&(isVoid(t)||xnor(e>=0,t))},exp.isEvent=isEvent=function(e,t){return e&&e.type&&e.preventDefault&&e.stopPropagation&&(isVoid(t)||e.type===t)?!0:!1},exp.isExotic=isExotic=function(e){return!isDefined(e)||isNaN(e)||isInfinite(e)},exp.isFalse=isFalse=function(e){return e===!1},exp.isFinite=isFinite=function(e,t){return lodash.isFinite(e)&&(isVoid(t)||xnor(e>=0,t))},exp.isFloat=isFloat=function(e,t){return isFinite(e)&&e%1!==0&&(isVoid(t)||xnor(e>=0,t))},exp.isFunction=isFunction=function(e){return lodash.isFunction(e)},exp.isHex=isHex=function(e){return isString(e)&&/^[0-9A-Fa-f]+$/.test(e)},exp.isIndex=isIndex=function(e){return isInt(e,!0)},exp.isInfinite=isInfinite=function(e){return e===1/0||e===-(1/0)},exp.isInput=isInput=function(e,t){return isString(e,t)||isFinite(e)},exp.isInstance=isInstance=function(e,t){return assertArgument(isFunction(t),2,"Function"),e instanceof t},exp.isInt=isInt=function(e,t){return isFinite(e)&&e%1===0&&(isVoid(t)||xnor(e>=0,t))},exp.isKebabCase=isKebabCase=function(e,t){return isString(e)&&e===kebabCase(e)&&(isVoid(t)||xnor(e.length,t))},exp.isKeyCase=isKeyCase=function(e,t){return isString(e)&&e===keyCase(e)&&(isVoid(t)||xnor(e.length,t))},exp.isLast=isLast=function(e,t){return assertArgument(isArrayable(t),2,"Arrayable"),!!t.length&&e===t[t.length-1]},exp.isLastIndex=isLastIndex=function(e,t){return assertArgument(isArrayable(t),2,"Arrayable"),!!t.length&&e===t.length-1},exp.isLowerCase=isLowerCase=function(e,t){return isString(e)&&e===lowerCase(e)&&(isVoid(t)||xnor(e.length,t))},exp.isNaN=isNaN=function(e){return lodash.isNaN(e)},exp.isNative=isNative=function(e){return lodash.isNative(e)},exp.isNegative=isNegative=function(e){return isNumber(e)&&0>e},exp.isNode=isNode=function(e,t){return e=isShady(e)?e.node:e,e&&(isDefined(e.nodeType)&&isDefined(e.ownerDocument)||isPolyfilled(e))&&(isVoid(t)||e.nodeType===t)?!0:!1},exp.isNull=isNull=function(e){return lodash.isNull(e)},exp.isNullable=isNullable=function(e){return isVoid(e)||isString(e,!1)},exp.isNumber=isNumber=function(e,t){return lodash.isNumber(e)&&!isNaN(e)&&(isVoid(t)||xnor(e>=0,t))},exp.isNumeric=isNumeric=function(e,t){var r=toNumber(e);return isDefined(r)&&(isNumber(e)||e===r.toString())&&(isVoid(t)||xnor(r>=0,t))},exp.isObject=isObject=function(e,t){return lodash.isObject(e)&&!isArray(e)&&!isFunction(e)&&(isVoid(t)||xnor(lodash.values(e).length,t))},exp.isObservable=isObservable=function(e){return isBindable(e,!0)},exp.isOdd=isOdd=function(e,t){return isFinite(e)&&e%2!==0&&(isVoid(t)||xnor(e>=0,t))},exp.isPlainObject=isPlainObject=function(e,t){return lodash.isPlainObject(e)&&(isVoid(t)||xnor(lodash.values(e).length,t))},exp.isPolyfilled=isPolyfilled=function(e){return!(!e||!e.__impl4cf1e782hg__&&!e.__wrapper8e3dd93a60__)},exp.isPositive=isPositive=function(e,t){return isFinite(e)&&e>=0&&(!t||e)},exp.isPredicate=isPredicate=function(e){return isFunction(e)||isObject(e)||isString(e)},exp.isPrevented=isPrevented=function(e){return isEvent(e)&&e.defaultPrevented},exp.isPrimitive=isPrimitive=function(e){return isBoolean(e)||isFinite(e)||isString(e)},exp.isRegExp=isRegExp=function(e){return lodash.isRegExp(e)},exp.isSelector=isSelector=function(e){return isString(e,!0)},exp.isShady=isShady=function(e){return!!e&&lodash.has(e,"node")&&lodash.has(Object.getPrototypeOf(e),"_queryElement")},exp.isStartCase=isStartCase=function(e,t){return isString(e)&&e===startCase(e)&&(isVoid(t)||xnor(e.length,t))},exp.isString=isString=function(e,t){return lodash.isString(e)&&(isVoid(t)||xnor(e.length,t))},exp.isTemplate=isTemplate=function(e){return isElement(e)&&"template"===(e.node||e).tagName.toLowerCase()},exp.isTrue=isTrue=function(e){return e===!0},exp.isUniq=isUniq=function(e,t){return isArrayable(e)&&e.length===uniq(e).length&&(isVoid(t)||xnor(e.length,t))},exp.isUpperCase=isUpperCase=function(e,t){return isString(e)&&e===upperCase(e)&&(isVoid(t)||xnor(e.length,t))},exp.isVoid=isVoid=function(e){return isNull(e)||!isDefined(e)},exp.isWithin=isWithin=function(e,t,r){return assertArgument(isNumber(t),2,"number"),assertArgument(isVoid(r)||isNumber(r),3,"number"),isNumber(e)&&e>=(isVoid(r)?0:t)&&e<=(isVoid(r)?t:r)},exp.iterate=iterate=function(e,t,r){function n(r){return!r&&(s+=1)<size(o||e)?t(n,e[o?o[s]:s],o?o[s]:s,e):i(r,r?null:e)}assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),assertArgument(isVoid(r)||isFunction(r),3,"Function");var i=r||mock(),s=-1,o=isArrayable(e)?null:keys(e);n(null)},exp.kebabCase=kebabCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.kebabCase(e):""},exp.keyCase=keyCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?camelCase(e).replace(/^(\d+)/,""):""},exp.keys=keys=function(e){return assertArgument(isObject(e),1,"Object"),lodash.keys(e)},exp.keysIn=keysIn=function(e){return assertArgument(isObject(e),1,"Object"),lodash.keysIn(e)},exp.last=last=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.last(e)},exp.lastIndexOf=lastIndexOf=function(e,t,r){assertArgument(isString(e)||isDefined(e=toArray(e)),1,"Arrayable or string"),assertArgument(isVoid(r)||isFinite(r),3,"number");var n=isArray(e)?lodash.lastIndexOf(e,t,r):isString(t)?e.lastIndexOf(t):-1;return isIndex(n)?n:void 0},exp.listen=listen=function(e,t,r){return isNode(e)||!isObject(e)&&!isString(e)||(r=t,t=e,e=global),assertArgument(isVoid(e)||isNode(e)||e===global,1,"Element or Window"),assertArgument(isVoid(t)||isObject(t)||isString(t),2,"Object or string"),assertArgument(isVoid(r)||isFunction(r),3,"Function"),isVoid(e)?e:(isObject(t)&&forOwn(t,function(t,r){e.addEventListener(r,t)}),isString(t,!0)&&isFunction(r)&&e.addEventListener(t,r),e)},exp.localize=localize=function t(e,r){return assertArgument(isVoid(e)||isString(e)||isCollection(e),1,"Array, Object or string"),assertArgument(isVoid(r)||isObject(r),2,"Object"),e&&r?isString(e)?value(r,e,e):isArrayable(e)?map(e,function(e){return t(r,e)}):isObject(e)?mapValues(e,function(e,n){return t(r,n)}):void 0:e||""},exp.lowerCase=lowerCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?e.toLowerCase():""},exp.map=map=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.map(e,t,r)},exp.mapOne=mapOne=function(e,t){assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string");var r;return forEach(e,function(e,n,i){return!isDefined(r=t(e,n,i))}),r},exp.mapValues=mapValues=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isFunction(t)||isString(t),2,"Function or string"),lodash.mapValues(e,t,r)},exp.match=match=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isRegExp(t),2,"RegExp"),e&&t?e.match(t)||[]:[]},exp.matches=matches=function(e,t){assertArgument(isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string");var r=e.node||e,n=r.matches||r.webkitMatchesSelector||r.mozMatchesSelector||r.msMatchesSelector||r.oMatchesSelector;return!t||n.call(r,t)},exp.max=max=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.max(e,t,r)},exp.memoize=memoize=function(e,t){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isFunction(t),2,"Function"),lodash.memoize(e,t)},exp.merge=merge=function(e,t){return assertArgument(isObject(e),1,"Object"),lodash.merge.apply(lodash,filter(arguments,ary(isObject,1)))},exp.min=min=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.min(e,t,r)},exp.mock=mock=function(){return function(){}},exp.moveFirst=moveFirst=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"a positive number"),assertArgument(isVoid(r)||isIndex(r),3,"void or a positive number"),e.unshift.apply(e,e.splice(t,r)),e},exp.moveLast=moveLast=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"a positive number"),assertArgument(isVoid(r)||isIndex(r),3,"void or a positive number"),e.push.apply(e,e.splice(t,r)),e},exp.nand=nand=function(e,t){return!and(e,t)},exp.negate=negate=function(e){return assertArgument(isFunction(e),1,"Function"),lodash.negate(e)},exp.nor=nor=function(e,t){return!or(e,t)},exp.not=not=function(e){return!e},exp.omit=omit=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isArrayable(t)||isFunction(t),2,"Arrayable or Function"),lodash.omit(e,t,r)},exp.onMutation=onMutation=function(e,t,r){assertArgument(isNode(e),1,"Node"),assertArgument(isFunction(t),2,"Function"),assertArgument(isVoid(r)||isObject(r),3,"Object");var n=new global.MutationObserver(function(e){delay(function(){t(e)}),n.disconnect()});return n.observe(e,r||{attributes:!1,characterData:!1,childList:!0,subtree:!0}),n},exp.once=once=function(e){return assertArgument(isFunction(e),1,"Function"),lodash.once(e)},exp.or=or=function(e,t){return Boolean(e||t)},exp.overwrite=overwrite=function(e,t,r){assertArgument(isArray(e),1,"Array"),assertArgument(isArrayable(t),2,"Arrayable");var n=e.length!==t.length||mapOne(e,function(e,r){return e!==t[r]?!0:void 0});return n&&Array.prototype.splice.apply(e,concat([0,e.length],t)),e},exp.pad=pad=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.pad(e,t,r)},exp.padLeft=padLeft=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.padLeft(e,t,r)},exp.padRight=padRight=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.padRight(e,t,r)},exp.pairs=pairs=function(e){return assertArgument(isObject(e),1,"Object"),lodash.pairs(e)},exp.parallel=parallel=function(e,t){assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isFunction(t),2,"Function");var r=t||mock(),n=size(e),i=isArray(e)?[]:{},s=!1;forEach(e,function(e,t){isFunction(e)&&!s?e(function(e,o){return n-=1,i[t]=o,s?void 0:e?r(s=e,null):n?void 0:r(null,i)}):(n-=1,i[t]=void 0)})},exp.parseBase62=parseBase62=function(e){if(assertArgument(isVoid(e)||isString(e),1,"string"),isBase62(e)){var t=0,r="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",n=e.split("").reverse();return n.forEach(function(e,n){t+=r.indexOf(e)*Math.pow(62,n)}),t}},exp.parseHex=parseHex=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),isHex(e)?parseInt(e,16):void 0},exp.parseJSON=parseJSON=function(e){assertArgument(isVoid(e)||isString(e),1,"string");try{return JSON.parse(e||"")}catch(t){}},exp.parseURL=parseURL=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),e?url.parse(e,!!t,!!r):void 0},exp.partition=partition=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.partition(e,t,r)},exp.pick=pick=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isArrayable(t)||isFunction(t),2,"Arrayable or Function"),lodash.pick(e,t,r)},exp.pluck=pluck=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isString(t),2,"string"),lodash.pluck(e,t)},exp.prefix=prefix=function(e,t,r){assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),assertArgument(isVoid(r)||isString(r),3,"string");var n=startsWith(e?e.toLowerCase():"",t?t.toLowerCase():"",r?r.toLowerCase():"");return(t||"")+(r||"")+(e||"").slice(n?(t||"").length+(r||"").length:0)},exp.prependChild=prependChild=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isNode(t),2,"Node"),e&&t&&e.insertBefore(t,e.firstChild),t},exp.preventDefault=preventDefault=function(e){return assertArgument(isVoid(e)||isEvent(e),1,"Event"),e.preventDefault(),e},exp.pull=pull=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.pull(e,t)},exp.pullAt=pullAt=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"number"),lodash.pullAt(e,t)[0]},exp.push=push=function(e,t){return assertArgument(isString(e)||isArray(e),1,"Array or string"),isArray(e)?e[e.push(t)-1]:isInput(t)?e+t:e},exp.random=random=function(e,t,r){return assertArgument(isVoid(e)||isFinite(e),1,"number"),assertArgument(isVoid(t)||isFinite(t),2,"number"),lodash.random(e,t,!!r)},exp.range=range=function(e,t,r){return assertArgument(isFinite(e),1,"number"),assertArgument(isVoid(t)||isFinite(t),2,"number"),assertArgument(isVoid(r)||isFinite(r),3,"number"),lodash.range(e,t,r)},exp.readable=readable=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?capitalize(snakeCase(e).replace(/_/g," ")):""},exp.redirect=redirect=function(e,t){assertArgument(isString(e),1,"string"),isBrowser()&&(global.location[t?"hash":"href"]=e)},exp.reduce=reduce=function(e,t,r,n){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),lodash.reduce(e,t,r,n)},exp.reduceRight=reduceRight=function(e,t,r,n){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t),2,"Function"),lodash.reduceRight(e,t,r,n)},exp.reject=reject=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.reject(e,t,r)},exp.remove=remove=function(e,t,r){return assertArgument(isArray(e),1,"Array"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.remove(e,t,r)},exp.removeAttribute=removeAttribute=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e.removeAttribute(t),e},exp.removeAttributes=removeAttributes=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable"),e&&t&&forEach(t,function(t){removeAttribute(e,t)}),e},exp.removeChild=removeChild=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isNode(t),2,"Node"),e&&t&&e.removeChild(t),t},exp.removeClass=removeClass=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e.classList.remove(t),e},exp.removeStyle=removeStyle=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t,!0),2,"string"),e&&t&&(e.style[t]=""),e},exp.removeStyles=removeStyles=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable"),e&&t&&forEach(t,function(t){removeStyle(e,t)}),e},exp.renameElement=renameElement=function(e,t){assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string");var r=e&&t?createElement(t,{attributes:getAttributes(e),children:getChildren(e)}):void 0;return r&&replaceNode(e,r),r||e},exp.repeat=repeat=function(e,t,r){assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isString(r),3,"string");var n,i="";if(e)for(n=0;t>n;n+=1)i+=(n?r||"":"")+e;return i},exp.replaceNode=replaceNode=function(e,t){return assertArgument(isVoid(e)||isNode(e),1,"Node"),assertArgument(isVoid(t)||isNode(t),2,"Node"),e&&t?e.parentNode.replaceChild(t,e):void 0},exp.requestAnimationFrame=requestAnimationFrame=function(e){assertArgument(isFunction(e),1,"Function"),global.requestAnimationFrame(e)},exp.rest=rest=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.rest(e)},exp.round=round=function(e,t){return assertArgument(isFinite(e),1,"number"),assertArgument(isVoid(t)||isIndex(t),2,"number"),Math.round(e*(t=Math.pow(10,t||0)))/t},exp.sample=sample=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.sample(e,t)},exp.seal=seal=function(e){return assertArgument(isBindable(e,!0),1,"Array, Function or Object"),Object.seal(e)},exp.setAttribute=setAttribute=function(e,t,r){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),isVoid(r)||isFalse(r)?removeAttribute(e,t):(e&&t&&e.setAttribute(t,toString(r)),e)},exp.setAttributes=setAttributes=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isObject(t),2,"Object"),e&&t&&forOwn(t,function(t,r){setAttribute(e,r,t)}),e},exp.setChildren=setChildren=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isArrayable(t),2,"Arrayable"),e&&t&&(flush(e),forEach(t,function(t){appendChild(e,t)})),e},exp.setHTML=setHTML=function(e,t){assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string");var r=isTemplate(e)?e.instanceRef_:e;return r&&(r.innerHTML=t||""),e},exp.setStyle=setStyle=function(e,t,r){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),isVoid(r)||isBoolean(r)?removeStyle(e,t):(e&&t&&(e.style[t]=toString(r)),e)},exp.setStyles=setStyles=function(e,t){assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isObject(t)||isString(t),2,"Object or string");var r=e?createElement("div"):null;return e&&isObject(t)&&forOwn(t,function(t,r){setStyle(e,r,t)}),e&&isString(t)&&forEach(setAttribute(r,"style",t).style,function(t){e.style[t]=r.style[t]}),e},exp.setText=setText=function(e,t){return assertArgument(isVoid(e)||isNode(e),1,"Node"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&!isTemplate(e)&&(e.textContent=t||""),e},exp.shrink=shrink=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"number"),e.length>t&&e.splice(t,e.length-t),e},exp.shuffle=shuffle=function(e){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),lodash.shuffle(e)},exp.size=size=function(e){return assertArgument(isString(e)||isCollection(e=toArray(e)||e),1,"Arrayable, Object or string"),lodash.size(e)},exp.slice=slice=function(e,t,r){return assertArgument(isVoid(t)||isIndex(t),2,"a positive number"),assertArgument(isVoid(r)||isIndex(r),3,"a positive number"),lodash.slice(e,t,r)},exp.snakeCase=snakeCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.snakeCase(e):""},exp.some=some=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.some(e,t,r)},exp.sortBy=sortBy=function(e,t,r){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.sortBy(e,t,r)},exp.split=split=function(e,t,r){assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string");var n=e&&t?e.indexOf(t):-1;return 0>n?[e||""]:r?[e.slice(0,n),e.slice(n+1)]:e.split(t)},exp.startCase=startCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.startCase(e):""},exp.startsWith=startsWith=function(e,t,r){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),assertArgument(isVoid(r)||isString(r),3,"string"),lodash.startsWith(e,(r||"")+(t||""))},exp.stop=stop=function(e){return stopPropagation(preventDefault(e))},exp.stopPropagation=stopPropagation=function(e){return assertArgument(isVoid(e)||isEvent(e),1,"Event"),e.stopPropagation(),e},exp.stretch=stretch=function(e,t,r){for(assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isIndex(t),2,"number");e.length<t;)e.push(r);return e},exp.strip=strip=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isRegExp(t)||isString(t),2,"RegExp or string"),e&&t?e.replace(t,""):e||""},exp.suffix=suffix=function(e,t,r){assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),assertArgument(isVoid(r)||isString(r),3,"string");var n=endsWith(e?e.toLowerCase():"",t?t.toLowerCase():"",r?r.toLowerCase():"");return e.slice(0,n?e.length-(r||"").length-(t||"").length:void 0)+(r||"")+t},exp.take=take=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.take(e,t)},exp.takeRight=takeRight=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isVoid(t)||isIndex(t),2,"number"),lodash.takeRight(e,t)},exp.takeRightWhile=takeRightWhile=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.takeRightWhile(e,t,r)},exp.takeWhile=takeWhile=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isPredicate(t),2,"Function, Object or string"),lodash.takeWhile(e,t,r)},exp.throttle=throttle=function(e,t,r){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isIndex(t),2,"number"),assertArgument(isVoid(r)||isObject(r),3,"Object"),lodash.throttle(e,t,r)},exp.toArray=toArray=function(e,t){return isArray(e)?e:isArrayable(e)?slice(e):t?isNullable(e)?[]:[e]:void 0},exp.toBase62=toBase62=function(e){if(isInt(e)){for(var t="",r="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";e>0;)t=r[e%62]+t,e=Math.floor(e/62);return t||"0"}},exp.toBoolean=toBoolean=function(e,t){return isDefined(e)?!!e&&"false"!==e:t?!1:void 0},exp.toDOMIdentity=toDOMIdentity=function(e){if(isElement(e))return function(t){return t===e};if(isFunction(e)||isString(e,!0))return toDOMPredicate(e);if(isNullable(e))return mock();throw new ArgumentError(1,"Element, Function or string")},exp.toDOMPredicate=toDOMPredicate=function(e){if(isFunction(e))return function(t){return isElement(t)&&e.apply(null,arguments)};if(isString(e))return function(t){return isElement(t)&&matches(t,e)};if(isVoid(e))return function(e){return isElement(e)};throw new ArgumentError(1,"Function or string")},exp.toElapsedTime=toElapsedTime=function(e){if(isFinite(e)){var t=Math.floor((Date.now()-e)/1e3),r=[{label:"year",value:31536e3},{label:"month",value:2592e3},{label:"day",value:86400},{label:"hour",value:3600},{label:"minute",value:60},{label:"second",value:1}];return 0>t?"":t?mapOne(r,function(e){var r=Math.floor(t/e.value);return r?r+" "+e.label+(r>1?"s":"")+" ago":void 0}):"now"}},exp.toHex=toHex=function(e){return isInt(e)?e.toString(16).toUpperCase():void 0},exp.toIndex=toIndex=function(e,t){return isIndex(e=toInt(e))?e:t?0:void 0},exp.toInfinite=toInfinite=function(e,t){return isInfinite(e)?e:"-Infinity"===e?-(1/0):"Infinity"===e||t?1/0:void 0},exp.toInput=toInput=function(e,t){return isNumber(e)?e.toString():isString(e)?e:t?"":void 0},exp.toInt=toInt=function(e,t){return isFinite(e=parseInt(e,10))?e:t?0:void 0},exp.toJSON=toJSON=function(e,t,r){return isNullable(e)?"null":JSON.stringify(e,function(e,r){var n=r&&r.toJSON?r.toJSON():r;return isFunction(n)?n.toString():isAny(n)?r:t?void 0:null},r?"  ":void 0)},exp.toNumber=toNumber=function(e,t){return isFinite(e=parseFloat(e))?e:t?0:void 0},exp.toObject=toObject=function(e,t){return isObject(e)?e:t?{}:void 0},exp.toPosition=toPosition=function(e){if(isIndex(e)){var t=e.toString(),r=t[t.length-1];return"1"===r&&11!==e?t+"st":"2"===r&&12!==e?t+"nd":"3"===r&&13!==e?t+"rd":t+"th"}},exp.toQueryString=toQueryString=function(e,t){if(!isVoid(e=isObject(e)?e:t?{}:null)){var r=map(e,function(e,t){return isBoolean(e)||isFinite(e)||isString(e,!0)?t+"="+encodeURIComponent(e.toString()):void 0});return filter(r,ary(isDefined,1)).join("&")}},exp.toRegExp=toRegExp=function(e){var t,r,n,i;if(!isString(e))return isRegExp(e)?e:void 0;if("/"!==e[0])return e?new RegExp(e):null;for(t=r=!1,n=1,i="";n<e.length&&(t=!r&&"/"===e[n],r=!r&&"\\"===e[n],!t);n+=1)i+=e[n];try{return t&&i?new RegExp(i,e.slice(n+1)):null}catch(s){return null}},exp.toString=toString=function(e){return isVoid(e)||isBoolean(e)?"":isNumber(e)?e.toString():isString(e)?e:JSON.stringify(e,function(e,t){var r=t&&t.toJSON?t.toJSON():t;return isNullable(t)?null:isError(r)||isFunction(r)||isRegExp(r)?r.toString():t})},exp.toTemplate=toTemplate=function(e,t){if(!isVoid(e=isElement(e)?e:t?createElement("div"):null)){for(var r=e.firstChild,n=createElement("template");r;)n.content.appendChild(r.cloneNode(!0)),r=r.nextSibling;return n}},exp.toURL=toURL=function(e,t){if(isString(e,!0)){var r=toQueryString(t);return e+(r?"?"+r:"")}},exp.toUseful=toUseful=function(e){return isAny(e)?e:void 0},exp.toValue=toValue=function(e,t){return isNumeric(e)?toNumber(e):includes(["false","true"],e)?toBoolean(e):isString(e)?e:t?null:void 0},exp.toggleAttribute=toggleAttribute=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t),2,"string"),e&&t&&e[e.hasAttribute(t)?"removeAttribute":"setAttribute"](t,""),e},exp.toggleClass=toggleClass=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isString(t,!0),2,"string"),e&&t&&e.classList.toggle(t),e},exp.trim=trim=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),e?lodash.trim(e,t):""},exp.trimLeft=trimLeft=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),e?lodash.trimLeft(e,t):""},exp.trimRight=trimRight=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isString(t),2,"string"),e?lodash.trimRight(e,t):""},exp.trunc=trunc=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isObject(t),2,"Object"),e?lodash.trunc(e,t):""},exp.unescape=unescape=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?lodash.unescape(e):""},exp.union=union=function(e){return lodash.union.apply(lodash,map(filter(arguments,ary(isArrayable,1)),ary(toArray,1)))},exp.uniq=uniq=function(e,t,r){return assertArgument(e=toArray(e),1,"Arrayable"),assertArgument(isFunction(t)||isObject(t)||isString(t),2,"Function, Object or string"),lodash.uniq(e,t,r)},exp.unlisten=unlisten=function(e,t,r){return isNode(e)||!isObject(e)&&!isString(e)||(r=t,t=e,e=global),assertArgument(isVoid(e)||isNode(e)||e===global,1,"Element or Window"),assertArgument(isVoid(t)||isObject(t)||isString(t),2,"Object or string"),assertArgument(isVoid(r)||isFunction(r),3,"Function"),isVoid(e)?e:(isObject(t)&&forOwn(t,function(t,r){e.removeEventListener(r,t)}),isString(t,!0)&&isFunction(r)&&e.removeEventListener(t,r),e)},exp.unzip=unzip=function(e){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.unzip(e)},exp.updateElement=updateElement=function(e,t){return assertArgument(isVoid(e)||isElement(e),1,"Element"),assertArgument(isVoid(t)||isObject(t),2,"Object"),e&&t&&t.attributes&&setAttributes(e,t.attributes),e&&t&&t.properties&&assign(e,t.properties),e&&t&&t.children&&setChildren(e,t.children),e},exp.upperCase=upperCase=function(e){return assertArgument(isVoid(e)||isString(e),1,"string"),e?e.toUpperCase():""},exp.value=value=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isString(t,!0),2,"string"),has(e,t)?e[t]:r},exp.valueIn=valueIn=function(e,t,r){return assertArgument(isObject(e),1,"Object"),assertArgument(isString(t,!0),2,"string"),isDefined(e[t])?e[t]:r},exp.values=values=function(e){return assertArgument(isObject(e),1,"Object"),lodash.values(e)},exp.valuesIn=valuesIn=function(e){return assertArgument(isObject(e),1,"Object"),lodash.valuesIn(e)},exp.waterfall=waterfall=function(e,t){function r(){var e,t,o=slice(arguments);for(s+=1;s<i.length&&!isFunction(i[s]);s+=1);for(t=s+1;t<i.length&&!isFunction(i[t]);t+=1);e=o.splice(0,1,i[t]?r:n)[0],(!e&&i[s]?i[s]:n).apply(void 0,e?[e]:o)}assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isVoid(t)||isFunction(t),2,"Function");var n=t||mock(),i=isArray(e)?e:values(e),s=-1;r()},exp.where=where=function(e,t){return assertArgument(isCollection(e=toArray(e)||e),1,"Arrayable or Object"),assertArgument(isObject(t),2,"Object"),lodash.where(e,t)},exp.willBleedBottom=willBleedBottom=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),e.top+t.top+e.height+t.bottom>getHeight()},exp.willBleedHorizontally=willBleedHorizontally=function(e,t){
return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),t.left+e.width+t.right>getWidth()},exp.willBleedLeft=willBleedLeft=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),e.left<0},exp.willBleedRight=willBleedRight=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),e.left+t.left+e.width+t.right>getWidth()},exp.willBleedTop=willBleedTop=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),e.top<0},exp.willBleedVertically=willBleedVertically=function(e,t){return assertArgument(isObject(e),1,"Object"),assertArgument(isObject(t),2,"Object"),t.top+e.height+t.bottom>getHeight()},exp.withdraw=withdraw=function(e,t){var r;return assertArgument(isObject(e),1,"Object"),assertArgument(isString(t,!0),2,"string"),has(e,t)&&(r=e[t],delete e[t]),r},exp.within=within=function(e,t,r){return assertArgument(isNumber(e),1,"number"),assertArgument(isNumber(t),2,"number"),assertArgument(isNumber(r),3,"number"),t>e?t:e>r?r:e},exp.without=without=function(e,t){return assertArgument(e=toArray(e),1,"Arrayable"),lodash.without.apply(lodash,concat([e],slice(arguments,1)))},exp.words=words=function(e,t){return assertArgument(isVoid(e)||isString(e),1,"string"),assertArgument(isVoid(t)||isRegExp(t)||isString(t),2,"RegExp or string"),e?lodash.words(e,t):[]},exp.wrap=wrap=function(e,t){return assertArgument(isFunction(e),1,"Function"),assertArgument(isVoid(t)||isFunction(t),2,"Function"),lodash.wrap(e,t)},exp.xnor=xnor=function(e,t){return!xor(e,t)},exp.xor=xor=function(e,t){return Boolean(e)!==Boolean(t)},exp.zip=zip=function(e){return lodash.union.apply(lodash,map(filter(arguments,ary(isArrayable,1)),ary(toArray,1)))},exp.zipObject=zipObject=function(e,t){assertArgument(isString(e,!0)||isDefined(e=toArray(e)),1,"Arrayable or string");var r={},n=isArrayable(t);return isString(e)?r[e]=t:e.forEach(function(e,i){r[e]=n?t[i]:t}),r},browser&&(global._=lodash,global.XPClass=exp.Class,global.XPDeferred=exp.Deferred,global.XPPromise=exp.Promise)}("undefined"!=typeof window?window:global,"undefined"!=typeof window);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash":8,"q":9,"url":6}],8:[function(require,module,exports){
(function (global){
(function(){function n(n,t){if(n!==t){var r=n===n,e=t===t;if(n>t||!r||"undefined"==typeof n&&e)return 1;if(t>n||!e||"undefined"==typeof t&&r)return-1}return 0}function t(n,t,r){if(t!==t)return p(n,r);for(var e=r-1,u=n.length;++e<u;)if(n[e]===t)return e;return-1}function r(n){return"function"==typeof n||!1}function e(n){return"string"==typeof n?n:null==n?"":n+""}function u(n){return n.charCodeAt(0)}function i(n,t){for(var r=-1,e=n.length;++r<e&&t.indexOf(n.charAt(r))>-1;);return r}function o(n,t){for(var r=n.length;r--&&t.indexOf(n.charAt(r))>-1;);return r}function f(t,r){return n(t.criteria,r.criteria)||t.index-r.index}function a(t,r,e){for(var u=-1,i=t.criteria,o=r.criteria,f=i.length,a=e.length;++u<f;){var c=n(i[u],o[u]);if(c)return u>=a?c:c*(e[u]?1:-1)}return t.index-r.index}function c(n){return Bn[n]}function l(n){return Dn[n]}function s(n){return"\\"+qn[n]}function p(n,t,r){for(var e=n.length,u=t+(r?0:-1);r?u--:++u<e;){var i=n[u];if(i!==i)return u}return-1}function h(n){return n&&"object"==typeof n||!1}function v(n){return 160>=n&&n>=9&&13>=n||32==n||160==n||5760==n||6158==n||n>=8192&&(8202>=n||8232==n||8233==n||8239==n||8287==n||12288==n||65279==n)}function _(n,t){for(var r=-1,e=n.length,u=-1,i=[];++r<e;)n[r]===t&&(n[r]=D,i[++u]=r);return i}function g(n,t){for(var r,e=-1,u=n.length,i=-1,o=[];++e<u;){var f=n[e],a=t?t(f,e,n):f;e&&r===a||(r=a,o[++i]=f)}return o}function y(n){for(var t=-1,r=n.length;++t<r&&v(n.charCodeAt(t)););return t}function d(n){for(var t=n.length;t--&&v(n.charCodeAt(t)););return t}function m(n){return zn[n]}function w(v){function Y(n){if(h(n)&&!rf(n)&&!(n instanceof Bn)){if(n instanceof Q)return n;if(io.call(n,"__chain__")&&io.call(n,"__wrapped__"))return Br(n)}return new Q(n)}function Z(){}function Q(n,t,r){this.__wrapped__=n,this.__actions__=r||[],this.__chain__=!!t}function Bn(n){this.__wrapped__=n,this.__actions__=null,this.__dir__=1,this.__dropCount__=0,this.__filtered__=!1,this.__iteratees__=null,this.__takeCount__=Fo,this.__views__=null}function Dn(){var n=this.__actions__,t=this.__iteratees__,r=this.__views__,e=new Bn(this.__wrapped__);return e.__actions__=n?Qn(n):null,e.__dir__=this.__dir__,e.__filtered__=this.__filtered__,e.__iteratees__=t?Qn(t):null,e.__takeCount__=this.__takeCount__,e.__views__=r?Qn(r):null,e}function zn(){if(this.__filtered__){var n=new Bn(this);n.__dir__=-1,n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Mn(){var n=this.__wrapped__.value();if(!rf(n))return Ht(n,this.__actions__);var t=this.__dir__,r=0>t,e=xr(0,n.length,this.__views__),u=e.start,i=e.end,o=i-u,f=r?i:u-1,a=Co(o,this.__takeCount__),c=this.__iteratees__,l=c?c.length:0,s=0,p=[];n:for(;o--&&a>s;){f+=t;for(var h=-1,v=n[f];++h<l;){var _=c[h],g=_.iteratee,y=_.type;if(y==F){if(_.done&&(r?f>_.index:f<_.index)&&(_.count=0,_.done=!1),_.index=f,!_.done){var d=_.limit;if(!(_.done=d>-1?_.count++>=d:!g(v)))continue n}}else{var m=g(v);if(y==L)v=m;else if(!m){if(y==$)continue n;break n}}}p[s++]=v}return p}function qn(){this.__data__={}}function Pn(n){return this.has(n)&&delete this.__data__[n]}function Kn(n){return"__proto__"==n?b:this.__data__[n]}function Vn(n){return"__proto__"!=n&&io.call(this.__data__,n)}function Yn(n,t){return"__proto__"!=n&&(this.__data__[n]=t),this}function Gn(n){var t=n?n.length:0;for(this.data={hash:Ro(null),set:new mo};t--;)this.push(n[t])}function Zn(n,t){var r=n.data,e="string"==typeof t||Ou(t)?r.set.has(t):r.hash[t];return e?0:-1}function Hn(n){var t=this.data;"string"==typeof n||Ou(n)?t.set.add(n):t.hash[n]=!0}function Qn(n,t){var r=-1,e=n.length;for(t||(t=qi(e));++r<e;)t[r]=n[r];return t}function nt(n,t){for(var r=-1,e=n.length;++r<e&&t(n[r],r,n)!==!1;);return n}function tt(n,t){for(var r=n.length;r--&&t(n[r],r,n)!==!1;);return n}function rt(n,t){for(var r=-1,e=n.length;++r<e;)if(!t(n[r],r,n))return!1;return!0}function et(n,t){for(var r=-1,e=n.length,u=-1,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[++u]=o)}return i}function ut(n,t){for(var r=-1,e=n.length,u=qi(e);++r<e;)u[r]=t(n[r],r,n);return u}function it(n){for(var t=-1,r=n.length,e=Uo;++t<r;){var u=n[t];u>e&&(e=u)}return e}function ot(n){for(var t=-1,r=n.length,e=Fo;++t<r;){var u=n[t];e>u&&(e=u)}return e}function ft(n,t,r,e){var u=-1,i=n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function at(n,t,r,e){var u=n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function ct(n,t){for(var r=-1,e=n.length;++r<e;)if(t(n[r],r,n))return!0;return!1}function lt(n,t){return"undefined"==typeof n?t:n}function st(n,t,r,e){return"undefined"!=typeof n&&io.call(e,r)?n:t}function pt(n,t,r){var e=af(t);if(!r)return vt(t,n,e);for(var u=-1,i=e.length;++u<i;){var o=e[u],f=n[o],a=r(f,t[o],o,n,t);(a===a?a===f:f!==f)&&("undefined"!=typeof f||o in n)||(n[o]=a)}return n}function ht(n,t){for(var r=-1,e=n.length,u=Or(e),i=t.length,o=qi(i);++r<i;){var f=t[r];u?(f=parseFloat(f),o[r]=kr(f,e)?n[f]:b):o[r]=n[f]}return o}function vt(n,t,r){r||(r=t,t={});for(var e=-1,u=r.length;++e<u;){var i=r[e];t[i]=n[i]}return t}function _t(n,t){for(var r=-1,e=t.length;++r<e;){var u=t[r];n[u]=_r(n[u],A,n)}return n}function gt(n,t,r){var e=typeof n;return"function"==e?"undefined"!=typeof t&&Rr(n)?tr(n,t,r):n:null==n?Ci:"object"==e?Lt(n):"undefined"==typeof t?Mt(n+""):Bt(n+"",t)}function yt(n,t,r,e,u,i,o){var f;if(r&&(f=u?r(n,e,u):r(n)),"undefined"!=typeof f)return f;if(!Ou(n))return n;var a=rf(n);if(a){if(f=Ar(n),!t)return Qn(n,f)}else{var c=fo.call(n),l=c==V;if(c!=J&&c!=z&&(!l||u))return $n[c]?Er(n,c,t):u?n:{};if(f=jr(l?{}:n),!t)return vt(n,f,af(n))}i||(i=[]),o||(o=[]);for(var s=i.length;s--;)if(i[s]==n)return o[s];return i.push(n),o.push(f),(a?nt:Ct)(n,function(e,u){f[u]=yt(e,t,r,u,n,i,o)}),f}function dt(n,t,r,e){if("function"!=typeof n)throw new Hi(B);return wo(function(){n.apply(b,Vt(r,e))},t)}function mt(n,r){var e=n?n.length:0,u=[];if(!e)return u;var i=-1,o=br(),f=o==t,a=f&&r.length>=200?Vo(r):null,c=r.length;a&&(o=Zn,f=!1,r=a);n:for(;++i<e;){var l=n[i];if(f&&l===l){for(var s=c;s--;)if(r[s]===l)continue n;u.push(l)}else o(r,l,0)<0&&u.push(l)}return u}function wt(n,t){var r=n?n.length:0;if(!Or(r))return Ct(n,t);for(var e=-1,u=Lr(n);++e<r&&t(u[e],e,u)!==!1;);return n}function bt(n,t){var r=n?n.length:0;if(!Or(r))return Tt(n,t);for(var e=Lr(n);r--&&t(e[r],r,e)!==!1;);return n}function xt(n,t){var r=!0;return wt(n,function(n,e,u){return r=!!t(n,e,u)}),r}function At(n,t,r,e){var u=n.length;for(r=null==r?0:+r||0,0>r&&(r=-r>u?0:u+r),e="undefined"==typeof e||e>u?u:+e||0,0>e&&(e+=u),u=r>e?0:e>>>0,r>>>=0;u>r;)n[r++]=t;return n}function jt(n,t){var r=[];return wt(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function Et(n,t,r,e){var u;return r(n,function(n,r,i){return t(n,r,i)?(u=e?r:n,!1):void 0}),u}function Rt(n,t,r,e){for(var u=e-1,i=n.length,o=-1,f=[];++u<i;){var a=n[u];if(h(a)&&Or(a.length)&&(rf(a)||xu(a))){t&&(a=Rt(a,t,r,0));var c=-1,l=a.length;for(f.length+=l;++c<l;)f[++o]=a[c]}else r||(f[++o]=a)}return f}function kt(n,t,r){for(var e=-1,u=Lr(n),i=r(n),o=i.length;++e<o;){var f=i[e];if(t(u[f],f,u)===!1)break}return n}function It(n,t,r){for(var e=Lr(n),u=r(n),i=u.length;i--;){var o=u[i];if(t(e[o],o,e)===!1)break}return n}function Ot(n,t){return kt(n,t,Hu)}function Ct(n,t){return kt(n,t,af)}function Tt(n,t){return It(n,t,af)}function Wt(n,t){for(var r=-1,e=t.length,u=-1,i=[];++r<e;){var o=t[r];uf(n[o])&&(i[++u]=o)}return i}function St(n,t,r){var e=-1,u="function"==typeof t,i=n?n.length:0,o=Or(i)?qi(i):[];return wt(n,function(n){var i=u?t:null!=n&&n[t];o[++e]=i?i.apply(n,r):b}),o}function Nt(n,t,r,e,u,i){if(n===t)return 0!==n||1/n==1/t;var o=typeof n,f=typeof t;return"function"!=o&&"object"!=o&&"function"!=f&&"object"!=f||null==n||null==t?n!==n&&t!==t:Ut(n,t,Nt,r,e,u,i)}function Ut(n,t,r,e,u,i,o){var f=rf(n),a=rf(t),c=M,l=M;f||(c=fo.call(n),c==z?c=J:c!=J&&(f=$u(n))),a||(l=fo.call(t),l==z?l=J:l!=J&&(a=$u(t)));var s=c==J,p=l==J,h=c==l;if(h&&!f&&!s)return yr(n,t,c);var v=s&&io.call(n,"__wrapped__"),_=p&&io.call(t,"__wrapped__");if(v||_)return r(v?n.value():n,_?t.value():t,e,u,i,o);if(!h)return!1;i||(i=[]),o||(o=[]);for(var g=i.length;g--;)if(i[g]==n)return o[g]==t;i.push(n),o.push(t);var y=(f?gr:dr)(n,t,r,e,u,i,o);return i.pop(),o.pop(),y}function Ft(n,t,r,e,u){var i=t.length;if(null==n)return!i;for(var o=-1,f=!u;++o<i;)if(f&&e[o]?r[o]!==n[t[o]]:!io.call(n,t[o]))return!1;for(o=-1;++o<i;){var a=t[o];if(f&&e[o])var c=io.call(n,a);else{var l=n[a],s=r[o];c=u?u(l,s,a):b,"undefined"==typeof c&&(c=Nt(s,l,u,!0))}if(!c)return!1}return!0}function $t(n,t){var r=[];return wt(n,function(n,e,u){r.push(t(n,e,u))}),r}function Lt(n){var t=af(n),r=t.length;if(1==r){var e=t[0],u=n[e];if(Cr(u))return function(n){return null!=n&&n[e]===u&&io.call(n,e)}}for(var i=qi(r),o=qi(r);r--;)u=n[t[r]],i[r]=u,o[r]=Cr(u);return function(n){return Ft(n,t,i,o)}}function Bt(n,t){return Cr(t)?function(r){return null!=r&&r[n]===t}:function(r){return null!=r&&Nt(t,r[n],null,!0)}}function Dt(n,t,r,e,u){if(!Ou(n))return n;var i=Or(t.length)&&(rf(t)||$u(t));return(i?nt:Ct)(t,function(t,o,f){if(h(t))return e||(e=[]),u||(u=[]),zt(n,f,o,Dt,r,e,u);var a=n[o],c=r?r(a,t,o,n,f):b,l="undefined"==typeof c;l&&(c=t),!i&&"undefined"==typeof c||!l&&(c===c?c===a:a!==a)||(n[o]=c)}),n}function zt(n,t,r,e,u,i,o){for(var f=i.length,a=t[r];f--;)if(i[f]==a)return void(n[r]=o[f]);var c=n[r],l=u?u(c,a,r,n,t):b,s="undefined"==typeof l;s&&(l=a,Or(a.length)&&(rf(a)||$u(a))?l=rf(c)?c:c?Qn(c):[]:of(a)||xu(a)?l=xu(c)?Du(c):of(c)?c:{}:s=!1),i.push(a),o.push(l),s?n[r]=e(l,a,u,i,o):(l===l?l!==c:c===c)&&(n[r]=l)}function Mt(n){return function(t){return null==t?b:t[n]}}function qt(t,r){var e=r.length,u=ht(t,r);for(r.sort(n);e--;){var i=parseFloat(r[e]);if(i!=o&&kr(i)){var o=i;bo.call(t,i,1)}}return u}function Pt(n,t){return n+vo(No()*(t-n+1))}function Kt(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=!1,n):t(r,n,u,i)}),r}function Vt(n,t,r){var e=-1,u=n.length;t=null==t?0:+t||0,0>t&&(t=-t>u?0:u+t),r="undefined"==typeof r||r>u?u:+r||0,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0;for(var i=qi(u);++e<u;)i[e]=n[e+t];return i}function Yt(n,t){var r;return wt(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function Gt(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].value;return n}function Jt(n,t,r){var e=-1,u=n.length,i=Or(u)?qi(u):[];return wt(n,function(n){for(var r=t.length,u=qi(r);r--;)u[r]=null==n?b:n[t[r]];i[++e]={criteria:u,index:e,value:n}}),Gt(i,function(n,t){return a(n,t,r)})}function Xt(n,r){var e=-1,u=br(),i=n.length,o=u==t,f=o&&i>=200,a=f?Vo():null,c=[];a?(u=Zn,o=!1):(f=!1,a=r?[]:c);n:for(;++e<i;){var l=n[e],s=r?r(l,e,n):l;if(o&&l===l){for(var p=a.length;p--;)if(a[p]===s)continue n;r&&a.push(s),c.push(l)}else u(a,s,0)<0&&((r||f)&&a.push(s),c.push(l))}return c}function Zt(n,t){for(var r=-1,e=t.length,u=qi(e);++r<e;)u[r]=n[t[r]];return u}function Ht(n,t){var r=n;r instanceof Bn&&(r=r.value());for(var e=-1,u=t.length;++e<u;){var i=[r],o=t[e];go.apply(i,o.args),r=o.func.apply(o.thisArg,i)}return r}function Qt(n,t,r){var e=0,u=n?n.length:e;if("number"==typeof t&&t===t&&Bo>=u){for(;u>e;){var i=e+u>>>1,o=n[i];(r?t>=o:t>o)?e=i+1:u=i}return u}return nr(n,t,Ci,r)}function nr(n,t,r,e){t=r(t);for(var u=0,i=n?n.length:0,o=t!==t,f="undefined"==typeof t;i>u;){var a=vo((u+i)/2),c=r(n[a]),l=c===c;if(o)var s=l||e;else s=f?l&&(e||"undefined"!=typeof c):e?t>=c:t>c;s?u=a+1:i=a}return Co(i,Lo)}function tr(n,t,r){if("function"!=typeof n)return Ci;if("undefined"==typeof t)return n;switch(r){case 1:return function(r){return n.call(t,r)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,i){return n.call(t,r,e,u,i)};case 5:return function(r,e,u,i,o){return n.call(t,r,e,u,i,o)}}return function(){return n.apply(t,arguments)}}function rr(n){return so.call(n,0)}function er(n,t,r){for(var e=r.length,u=-1,i=Oo(n.length-e,0),o=-1,f=t.length,a=qi(i+f);++o<f;)a[o]=t[o];for(;++u<e;)a[r[u]]=n[u];for(;i--;)a[o++]=n[u++];return a}function ur(n,t,r){for(var e=-1,u=r.length,i=-1,o=Oo(n.length-u,0),f=-1,a=t.length,c=qi(o+a);++i<o;)c[i]=n[i];for(var l=i;++f<a;)c[l+f]=t[f];for(;++e<u;)c[l+r[e]]=n[i++];return c}function ir(n,t){return function(r,e,u){var i=t?t():{};if(e=wr(e,u,3),rf(r))for(var o=-1,f=r.length;++o<f;){var a=r[o];n(i,a,e(a,o,r),r)}else wt(r,function(t,r,u){n(i,t,e(t,r,u),u)});return i}}function or(n){return function(){var t=arguments,r=t.length,e=t[0];if(2>r||null==e)return e;var u=t[r-2],i=t[r-1],o=t[3];r>3&&"function"==typeof u?(u=tr(u,i,5),r-=2):(u=r>2&&"function"==typeof i?i:null,r-=u?1:0),o&&Ir(t[1],t[2],o)&&(u=3==r?null:u,r=2);for(var f=0;++f<r;){var a=t[f];a&&n(e,a,u)}return e}}function fr(n,t){function r(){var u=this&&this!==Jn&&this instanceof r?e:n;return u.apply(t,arguments)}var e=lr(n);return r}function ar(n){return function(){var t=arguments.length,r=t,e=n?t-1:0;if(!t)return function(){return arguments[0]};for(var u=qi(t);r--;)if(u[r]=arguments[r],"function"!=typeof u[r])throw new Hi(B);return function(){for(var r=e,i=u[r].apply(this,arguments);n?r--:++r<t;)i=u[r].call(this,i);return i}}}function cr(n){return function(t){for(var r=-1,e=Ri(li(t)),u=e.length,i="";++r<u;)i=n(i,e[r],r);return i}}function lr(n){return function(){var t=Po(n.prototype),r=n.apply(t,arguments);return Ou(r)?r:t}}function sr(n,t){return function(r,e,i){i&&Ir(r,e,i)&&(e=null);var o=wr(),f=null==e;if(o===gt&&f||(f=!1,e=o(e,i,3)),f){var a=rf(r);if(a||!Fu(r))return n(a?r:$r(r));e=u}return mr(r,e,t)}}function pr(n,t,r,e,u,i,o,f,a,c){function l(){for(var w=arguments.length,b=w,x=qi(w);b--;)x[b]=arguments[b];if(e&&(x=er(x,e,u)),i&&(x=ur(x,i,o)),v||y){var E=l.placeholder,R=_(x,E);if(w-=R.length,c>w){var k=f?Qn(f):null,C=Oo(c-w,0),T=v?R:null,W=v?null:R,S=v?x:null,N=v?null:x;t|=v?I:O,t&=~(v?O:I),g||(t&=~(A|j));var U=pr(n,t,r,S,T,N,W,k,a,C);return U.placeholder=E,U}}var F=p?r:this;h&&(n=F[m]),f&&(x=Nr(x,f)),s&&a<x.length&&(x.length=a);var $=this&&this!==Jn&&this instanceof l?d||lr(n):n;return $.apply(F,x)}var s=t&T,p=t&A,h=t&j,v=t&R,g=t&E,y=t&k,d=!h&&lr(n),m=n;return l}function hr(n,t,r){var e=n.length;if(t=+t,e>=t||!ko(t))return"";var u=t-e;return r=null==r?" ":r+"",di(r,po(u/r.length)).slice(0,u)}function vr(n,t,r,e){function u(){for(var t=-1,f=arguments.length,a=-1,c=e.length,l=qi(f+c);++a<c;)l[a]=e[a];for(;f--;)l[a++]=arguments[++t];var s=this&&this!==Jn&&this instanceof u?o:n;return s.apply(i?r:this,l)}var i=t&A,o=lr(n);return u}function _r(n,t,r,e,u,i,o,f){var a=t&j;if(!a&&"function"!=typeof n)throw new Hi(B);var c=e?e.length:0;if(c||(t&=~(I|O),e=u=null),c-=u?u.length:0,t&O){var l=e,s=u;e=u=null}var p=!a&&Yo(n),h=[n,t,r,e,u,l,s,i,o,f];if(p&&p!==!0&&(Tr(h,p),t=h[1],f=h[9]),h[9]=null==f?a?0:n.length:Oo(f-c,0)||0,t==A)var v=fr(h[0],h[2]);else v=t!=I&&t!=(A|I)||h[4].length?pr.apply(b,h):vr.apply(b,h);var _=p?Ko:Go;return _(v,h)}function gr(n,t,r,e,u,i,o){var f=-1,a=n.length,c=t.length,l=!0;if(a!=c&&!(u&&c>a))return!1;for(;l&&++f<a;){var s=n[f],p=t[f];if(l=b,e&&(l=u?e(p,s,f):e(s,p,f)),"undefined"==typeof l)if(u)for(var h=c;h--&&(p=t[h],!(l=s&&s===p||r(s,p,e,u,i,o))););else l=s&&s===p||r(s,p,e,u,i,o)}return!!l}function yr(n,t,r){switch(r){case q:case P:return+n==+t;case K:return n.name==t.name&&n.message==t.message;case G:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case X:case H:return n==t+""}return!1}function dr(n,t,r,e,u,i,o){var f=af(n),a=f.length,c=af(t),l=c.length;if(a!=l&&!u)return!1;for(var s,p=-1;++p<a;){var h=f[p],v=io.call(t,h);if(v){var _=n[h],g=t[h];v=b,e&&(v=u?e(g,_,h):e(_,g,h)),"undefined"==typeof v&&(v=_&&_===g||r(_,g,e,u,i,o))}if(!v)return!1;s||(s="constructor"==h)}if(!s){var y=n.constructor,d=t.constructor;if(y!=d&&"constructor"in n&&"constructor"in t&&!("function"==typeof y&&y instanceof y&&"function"==typeof d&&d instanceof d))return!1}return!0}function mr(n,t,r){var e=r?Fo:Uo,u=e,i=u;return wt(n,function(n,o,f){var a=t(n,o,f);((r?u>a:a>u)||a===e&&a===i)&&(u=a,i=n)}),i}function wr(n,t,r){var e=Y.callback||Ii;return e=e===Ii?gt:e,r?e(n,t,r):e}function br(n,r,e){var u=Y.indexOf||Qr;return u=u===Qr?t:u,n?u(n,r,e):u}function xr(n,t,r){for(var e=-1,u=r?r.length:0;++e<u;){var i=r[e],o=i.size;switch(i.type){case"drop":n+=o;break;case"dropRight":t-=o;break;case"take":t=Co(t,n+o);break;case"takeRight":n=Oo(n,t-o)}}return{start:n,end:t}}function Ar(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&io.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function jr(n){var t=n.constructor;return"function"==typeof t&&t instanceof t||(t=Ji),new t}function Er(n,t,r){var e=n.constructor;switch(t){case nn:return rr(n);case q:case P:return new e(+n);case tn:case rn:case en:case un:case on:case fn:case an:case cn:case ln:var u=n.buffer;return new e(r?rr(u):u,n.byteOffset,n.length);case G:case H:return new e(n);case X:var i=new e(n.source,xn.exec(n));i.lastIndex=n.lastIndex}return i}function Rr(n){var t=Y.support,r=!(t.funcNames?n.name:t.funcDecomp);if(!r){var e=eo.call(n);t.funcNames||(r=!An.test(e)),r||(r=Cn.test(e)||Wu(n),Ko(n,r))}return r}function kr(n,t){return n=+n,t=null==t?zo:t,n>-1&&n%1==0&&t>n}function Ir(n,t,r){if(!Ou(r))return!1;var e=typeof t;if("number"==e)var u=r.length,i=Or(u)&&kr(t,u);else i="string"==e&&t in r;if(i){var o=r[t];return n===n?n===o:o!==o}return!1}function Or(n){return"number"==typeof n&&n>-1&&n%1==0&&zo>=n}function Cr(n){return n===n&&(0===n?1/n>0:!Ou(n))}function Tr(n,t){var r=n[1],e=t[1],u=r|e,i=T|C,o=A|j,f=i|o|E|k,a=r&T&&!(e&T),c=r&C&&!(e&C),l=(c?n:t)[7],s=(a?n:t)[8],p=!(r>=C&&e>o||r>o&&e>=C),h=u>=i&&f>=u&&(C>r||(c||a)&&l.length<=s);if(!p&&!h)return n;e&A&&(n[2]=t[2],u|=r&A?0:E);var v=t[3];if(v){var g=n[3];n[3]=g?er(g,v,t[4]):Qn(v),n[4]=g?_(n[3],D):Qn(t[4])}return v=t[5],v&&(g=n[5],n[5]=g?ur(g,v,t[6]):Qn(v),n[6]=g?_(n[5],D):Qn(t[6])),v=t[7],v&&(n[7]=Qn(v)),e&T&&(n[8]=null==n[8]?t[8]:Co(n[8],t[8])),null==n[9]&&(n[9]=t[9]),n[0]=t[0],n[1]=u,n}function Wr(n,t){n=Lr(n);for(var r=-1,e=t.length,u={};++r<e;){var i=t[r];i in n&&(u[i]=n[i])}return u}function Sr(n,t){var r={};return Ot(n,function(n,e,u){t(n,e,u)&&(r[e]=n)}),r}function Nr(n,t){for(var r=n.length,e=Co(t.length,r),u=Qn(n);e--;){var i=t[e];n[e]=kr(i,r)?u[i]:b}return n}function Ur(n){var t;Y.support;if(!h(n)||fo.call(n)!=J||!io.call(n,"constructor")&&(t=n.constructor,"function"==typeof t&&!(t instanceof t)))return!1;var r;return Ot(n,function(n,t){r=t}),"undefined"==typeof r||io.call(n,r)}function Fr(n){for(var t=Hu(n),r=t.length,e=r&&n.length,u=Y.support,i=e&&Or(e)&&(rf(n)||u.nonEnumArgs&&xu(n)),o=-1,f=[];++o<r;){var a=t[o];(i&&kr(a,e)||io.call(n,a))&&f.push(a)}return f}function $r(n){return null==n?[]:Or(n.length)?Ou(n)?n:Ji(n):ii(n)}function Lr(n){return Ou(n)?n:Ji(n)}function Br(n){return n instanceof Bn?n.clone():new Q(n.__wrapped__,n.__chain__,Qn(n.__actions__))}function Dr(n,t,r){t=(r?Ir(n,t,r):null==t)?1:Oo(+t||1,1);for(var e=0,u=n?n.length:0,i=-1,o=qi(po(u/t));u>e;)o[++i]=Vt(n,e,e+=t);return o}function zr(n){for(var t=-1,r=n?n.length:0,e=-1,u=[];++t<r;){var i=n[t];i&&(u[++e]=i)}return u}function Mr(){for(var n=arguments,t=-1,r=n.length;++t<r;){var e=n[t];if(rf(e)||xu(e))break}return mt(e,Rt(n,!1,!0,++t))}function qr(n,t,r){var e=n?n.length:0;return e?((r?Ir(n,t,r):null==t)&&(t=1),Vt(n,0>t?0:t)):[]}function Pr(n,t,r){var e=n?n.length:0;return e?((r?Ir(n,t,r):null==t)&&(t=1),t=e-(+t||0),Vt(n,0,0>t?0:t)):[]}function Kr(n,t,r){var e=n?n.length:0;if(!e)return[];for(t=wr(t,r,3);e--&&t(n[e],e,n););return Vt(n,0,e+1)}function Vr(n,t,r){var e=n?n.length:0;if(!e)return[];var u=-1;for(t=wr(t,r,3);++u<e&&t(n[u],u,n););return Vt(n,u)}function Yr(n,t,r,e){var u=n?n.length:0;return u?(r&&"number"!=typeof r&&Ir(n,t,r)&&(r=0,e=u),At(n,t,r,e)):[]}function Gr(n,t,r){var e=-1,u=n?n.length:0;for(t=wr(t,r,3);++e<u;)if(t(n[e],e,n))return e;return-1}function Jr(n,t,r){var e=n?n.length:0;for(t=wr(t,r,3);e--;)if(t(n[e],e,n))return e;return-1}function Xr(n){return n?n[0]:b}function Zr(n,t,r){var e=n?n.length:0;return r&&Ir(n,t,r)&&(t=!1),e?Rt(n,t,!1,0):[]}function Hr(n){var t=n?n.length:0;return t?Rt(n,!0,!1,0):[]}function Qr(n,r,e){var u=n?n.length:0;if(!u)return-1;if("number"==typeof e)e=0>e?Oo(u+e,0):e;else if(e){var i=Qt(n,r),o=n[i];return(r===r?r===o:o!==o)?i:-1}return t(n,r,e||0)}function ne(n){return Pr(n,1)}function te(){for(var n=[],r=-1,e=arguments.length,u=[],i=br(),o=i==t;++r<e;){var f=arguments[r];(rf(f)||xu(f))&&(n.push(f),u.push(o&&f.length>=120?Vo(r&&f):null))}e=n.length;var a=n[0],c=-1,l=a?a.length:0,s=[],p=u[0];n:for(;++c<l;)if(f=a[c],(p?Zn(p,f):i(s,f,0))<0){for(r=e;--r;){var h=u[r];if((h?Zn(h,f):i(n[r],f,0))<0)continue n}p&&p.push(f),s.push(f)}return s}function re(n){var t=n?n.length:0;return t?n[t-1]:b}function ee(n,t,r){var e=n?n.length:0;if(!e)return-1;var u=e;if("number"==typeof r)u=(0>r?Oo(e+r,0):Co(r||0,e-1))+1;else if(r){u=Qt(n,t,!0)-1;var i=n[u];return(t===t?t===i:i!==i)?u:-1}if(t!==t)return p(n,u,!0);for(;u--;)if(n[u]===t)return u;return-1}function ue(){var n=arguments,t=n[0];if(!t||!t.length)return t;for(var r=0,e=br(),u=n.length;++r<u;)for(var i=0,o=n[r];(i=e(t,o,i))>-1;)bo.call(t,i,1);return t}function ie(n){return qt(n||[],Rt(arguments,!1,!1,1))}function oe(n,t,r){var e=-1,u=n?n.length:0,i=[];for(t=wr(t,r,3);++e<u;){var o=n[e];t(o,e,n)&&(i.push(o),bo.call(n,e--,1),u--)}return i}function fe(n){return qr(n,1)}function ae(n,t,r){var e=n?n.length:0;return e?(r&&"number"!=typeof r&&Ir(n,t,r)&&(t=0,r=e),Vt(n,t,r)):[]}function ce(n,t,r,e){var u=wr(r);return u===gt&&null==r?Qt(n,t):nr(n,t,u(r,e,1))}function le(n,t,r,e){var u=wr(r);return u===gt&&null==r?Qt(n,t,!0):nr(n,t,u(r,e,1),!0)}function se(n,t,r){var e=n?n.length:0;return e?((r?Ir(n,t,r):null==t)&&(t=1),Vt(n,0,0>t?0:t)):[]}function pe(n,t,r){var e=n?n.length:0;return e?((r?Ir(n,t,r):null==t)&&(t=1),t=e-(+t||0),Vt(n,0>t?0:t)):[]}function he(n,t,r){var e=n?n.length:0;if(!e)return[];for(t=wr(t,r,3);e--&&t(n[e],e,n););return Vt(n,e+1)}function ve(n,t,r){var e=n?n.length:0;if(!e)return[];var u=-1;for(t=wr(t,r,3);++u<e&&t(n[u],u,n););return Vt(n,0,u)}function _e(){return Xt(Rt(arguments,!1,!0,0))}function ge(n,r,e,u){var i=n?n.length:0;if(!i)return[];null!=r&&"boolean"!=typeof r&&(u=e,e=Ir(n,r,u)?null:r,r=!1);var o=wr();return(o!==gt||null!=e)&&(e=o(e,u,3)),r&&br()==t?g(n,e):Xt(n,e)}function ye(n){for(var t=-1,r=(n&&n.length&&it(ut(n,uo)))>>>0,e=qi(r);++t<r;)e[t]=ut(n,Mt(t));return e}function de(n){return mt(n,Vt(arguments,1))}function me(){for(var n=-1,t=arguments.length;++n<t;){var r=arguments[n];if(rf(r)||xu(r))var e=e?mt(e,r).concat(mt(r,e)):r}return e?Xt(e):[]}function we(){for(var n=arguments.length,t=qi(n);n--;)t[n]=arguments[n];return ye(t)}function be(n,t){var r=-1,e=n?n.length:0,u={};for(!e||t||rf(n[0])||(t=[]);++r<e;){var i=n[r];t?u[i]=t[r]:i&&(u[i[0]]=i[1])}return u}function xe(n){var t=Y(n);return t.__chain__=!0,t}function Ae(n,t,r){return t.call(r,n),n}function je(n,t,r){return t.call(r,n)}function Ee(){return xe(this)}function Re(){return new Q(this.value(),this.__chain__)}function ke(n){for(var t,r=this;r instanceof Z;){var e=Br(r);t?u.__wrapped__=e:t=e;var u=e;r=r.__wrapped__}return u.__wrapped__=n,t}function Ie(){var n=this.__wrapped__;return n instanceof Bn?(this.__actions__.length&&(n=new Bn(this)),new Q(n.reverse(),this.__chain__)):this.thru(function(n){return n.reverse()})}function Oe(){return this.value()+""}function Ce(){return Ht(this.__wrapped__,this.__actions__)}function Te(n){var t=n?n.length:0;return Or(t)&&(n=$r(n)),ht(n,Rt(arguments,!1,!1,1))}function We(n,t,r){var e=rf(n)?rt:xt;return("function"!=typeof t||"undefined"!=typeof r)&&(t=wr(t,r,3)),e(n,t)}function Se(n,t,r){var e=rf(n)?et:jt;return t=wr(t,r,3),e(n,t)}function Ne(n,t,r){if(rf(n)){var e=Gr(n,t,r);return e>-1?n[e]:b}return t=wr(t,r,3),Et(n,t,wt)}function Ue(n,t,r){return t=wr(t,r,3),Et(n,t,bt)}function Fe(n,t){return Ne(n,Lt(t))}function $e(n,t,r){return"function"==typeof t&&"undefined"==typeof r&&rf(n)?nt(n,t):wt(n,tr(t,r,3))}function Le(n,t,r){return"function"==typeof t&&"undefined"==typeof r&&rf(n)?tt(n,t):bt(n,tr(t,r,3))}function Be(n,t,r){var e=n?n.length:0;return Or(e)||(n=ii(n),e=n.length),e?(r="number"==typeof r?0>r?Oo(e+r,0):r||0:0,"string"==typeof n||!rf(n)&&Fu(n)?e>r&&n.indexOf(t,r)>-1:br(n,t,r)>-1):!1}function De(n,t){return St(n,t,Vt(arguments,2))}function ze(n,t,r){var e=rf(n)?ut:$t;return t=wr(t,r,3),e(n,t)}function Me(n,t){return ze(n,Mt(t))}function qe(n,t,r,e){var u=rf(n)?ft:Kt;return u(n,wr(t,e,4),r,arguments.length<3,wt)}function Pe(n,t,r,e){var u=rf(n)?at:Kt;return u(n,wr(t,e,4),r,arguments.length<3,bt)}function Ke(n,t,r){var e=rf(n)?et:jt;return t=wr(t,r,3),e(n,function(n,r,e){return!t(n,r,e)})}function Ve(n,t,r){if(r?Ir(n,t,r):null==t){n=$r(n);var e=n.length;return e>0?n[Pt(0,e-1)]:b}var u=Ye(n);return u.length=Co(0>t?0:+t||0,u.length),u}function Ye(n){n=$r(n);for(var t=-1,r=n.length,e=qi(r);++t<r;){var u=Pt(0,t);t!=u&&(e[t]=e[u]),e[u]=n[t]}return e}function Ge(n){var t=n?n.length:0;return Or(t)?t:af(n).length}function Je(n,t,r){var e=rf(n)?ct:Yt;return("function"!=typeof t||"undefined"!=typeof r)&&(t=wr(t,r,3)),e(n,t)}function Xe(n,t,r){if(null==n)return[];var e=-1,u=n.length,i=Or(u)?qi(u):[];return r&&Ir(n,t,r)&&(t=null),t=wr(t,r,3),wt(n,function(n,r,u){i[++e]={criteria:t(n,r,u),index:e,value:n}}),Gt(i,f)}function Ze(n){if(null==n)return[];var t=arguments,r=t[3];return r&&Ir(t[1],t[2],r)&&(t=[n,t[1]]),Jt(n,Rt(t,!1,!1,1),[])}function He(n,t,r,e){return null==n?[]:(e&&Ir(t,r,e)&&(r=null),rf(t)||(t=null==t?[]:[t]),rf(r)||(r=null==r?[]:[r]),Jt(n,t,r))}function Qe(n,t){return Se(n,Lt(t))}function nu(n,t){if("function"!=typeof t){if("function"!=typeof n)throw new Hi(B);var r=n;n=t,t=r}return n=ko(n=+n)?n:0,function(){return--n<1?t.apply(this,arguments):void 0}}function tu(n,t,r){return r&&Ir(n,t,r)&&(t=null),t=n&&null==t?n.length:Oo(+t||0,0),_r(n,T,null,null,null,null,t)}function ru(n,t){var r;if("function"!=typeof t){if("function"!=typeof n)throw new Hi(B);var e=n;n=t,t=e}return function(){return--n>0?r=t.apply(this,arguments):t=null,r}}function eu(n,t){var r=A;if(arguments.length>2){var e=Vt(arguments,2),u=_(e,eu.placeholder);r|=I}return _r(n,r,t,e,u)}function uu(n){return _t(n,arguments.length>1?Rt(arguments,!1,!1,1):Ju(n))}function iu(n,t){var r=A|j;if(arguments.length>2){var e=Vt(arguments,2),u=_(e,iu.placeholder);r|=I}return _r(t,r,n,e,u)}function ou(n,t,r){r&&Ir(n,t,r)&&(t=null);var e=_r(n,R,null,null,null,null,null,t);return e.placeholder=ou.placeholder,e}function fu(n,t,r){r&&Ir(n,t,r)&&(t=null);var e=_r(n,k,null,null,null,null,null,t);return e.placeholder=fu.placeholder,e}function au(n,t,r){function e(){p&&ho(p),a&&ho(a),a=p=h=b}function u(){var r=t-(Qo()-l);if(0>=r||r>t){a&&ho(a);var e=h;a=p=h=b,e&&(v=Qo(),c=n.apply(s,f),p||a||(f=s=null))}else p=wo(u,r)}function i(){p&&ho(p),a=p=h=b,(g||_!==t)&&(v=Qo(),c=n.apply(s,f),p||a||(f=s=null))}function o(){if(f=arguments,l=Qo(),s=this,h=g&&(p||!y),_===!1)var r=y&&!p;else{a||y||(v=l);var e=_-(l-v),o=0>=e||e>_;o?(a&&(a=ho(a)),v=l,c=n.apply(s,f)):a||(a=wo(i,e))}return o&&p?p=ho(p):p||t===_||(p=wo(u,t)),r&&(o=!0,c=n.apply(s,f)),!o||p||a||(f=s=null),c}var f,a,c,l,s,p,h,v=0,_=!1,g=!0;if("function"!=typeof n)throw new Hi(B);if(t=0>t?0:+t||0,r===!0){var y=!0;g=!1}else Ou(r)&&(y=r.leading,_="maxWait"in r&&Oo(+r.maxWait||0,t),g="trailing"in r?r.trailing:g);return o.cancel=e,o}function cu(n){return dt(n,1,arguments,1)}function lu(n,t){return dt(n,t,arguments,2)}function su(n,t){if("function"!=typeof n||t&&"function"!=typeof t)throw new Hi(B);var r=function(){var e=arguments,u=r.cache,i=t?t.apply(this,e):e[0];if(u.has(i))return u.get(i);var o=n.apply(this,e);return u.set(i,o),o};return r.cache=new su.Cache,r}function pu(n){if("function"!=typeof n)throw new Hi(B);return function(){return!n.apply(this,arguments)}}function hu(n){return ru(n,2)}function vu(n){var t=Vt(arguments,1),r=_(t,vu.placeholder);return _r(n,I,null,t,r)}function _u(n){var t=Vt(arguments,1),r=_(t,_u.placeholder);return _r(n,O,null,t,r)}function gu(n){var t=Rt(arguments,!1,!1,1);return _r(n,C,null,null,null,t)}function yu(n){if("function"!=typeof n)throw new Hi(B);return function(t){return n.apply(this,t)}}function du(n,t,r){var e=!0,u=!0;if("function"!=typeof n)throw new Hi(B);return r===!1?e=!1:Ou(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),Ln.leading=e,Ln.maxWait=+t,Ln.trailing=u,au(n,t,Ln)}function mu(n,t){return t=null==t?Ci:t,_r(t,I,null,[n],[])}function wu(n,t,r,e){return t&&"boolean"!=typeof t&&Ir(n,t,r)?t=!1:"function"==typeof t&&(e=r,r=t,t=!1),r="function"==typeof r&&tr(r,e,1),yt(n,t,r)}function bu(n,t,r){return t="function"==typeof t&&tr(t,r,1),yt(n,!0,t)}function xu(n){var t=h(n)?n.length:b;return Or(t)&&fo.call(n)==z||!1}function Au(n){return n===!0||n===!1||h(n)&&fo.call(n)==q||!1}function ju(n){return h(n)&&fo.call(n)==P||!1}function Eu(n){return n&&1===n.nodeType&&h(n)&&fo.call(n).indexOf("Element")>-1||!1}function Ru(n){if(null==n)return!0;var t=n.length;return Or(t)&&(rf(n)||Fu(n)||xu(n)||h(n)&&uf(n.splice))?!t:!af(n).length}function ku(n,t,r,e){if(r="function"==typeof r&&tr(r,e,3),!r&&Cr(n)&&Cr(t))return n===t;var u=r?r(n,t):b;return"undefined"==typeof u?Nt(n,t,r):!!u}function Iu(n){return h(n)&&"string"==typeof n.message&&fo.call(n)==K||!1}function Ou(n){var t=typeof n;return"function"==t||n&&"object"==t||!1}function Cu(n,t,r,e){var u=af(t),i=u.length;if(r="function"==typeof r&&tr(r,e,3),!r&&1==i){var o=u[0],f=t[o];if(Cr(f))return null!=n&&f===n[o]&&io.call(n,o)}for(var a=qi(i),c=qi(i);i--;)f=a[i]=t[u[i]],c[i]=Cr(f);return Ft(n,u,a,c,r)}function Tu(n){return Nu(n)&&n!=+n}function Wu(n){return null==n?!1:fo.call(n)==V?co.test(eo.call(n)):h(n)&&En.test(n)||!1}function Su(n){return null===n}function Nu(n){return"number"==typeof n||h(n)&&fo.call(n)==G||!1}function Uu(n){return h(n)&&fo.call(n)==X||!1}function Fu(n){return"string"==typeof n||h(n)&&fo.call(n)==H||!1}function $u(n){return h(n)&&Or(n.length)&&Fn[fo.call(n)]||!1}function Lu(n){return"undefined"==typeof n}function Bu(n){var t=n?n.length:0;return Or(t)?t?Qn(n):[]:ii(n)}function Du(n){return vt(n,Hu(n))}function zu(n,t,r){var e=Po(n);return r&&Ir(n,t,r)&&(t=null),t?vt(t,e,af(t)):e}function Mu(n){if(null==n)return n;var t=Qn(arguments);return t.push(lt),ff.apply(b,t)}function qu(n,t,r){return t=wr(t,r,3),Et(n,t,Ct,!0)}function Pu(n,t,r){return t=wr(t,r,3),Et(n,t,Tt,!0)}function Ku(n,t,r){return("function"!=typeof t||"undefined"!=typeof r)&&(t=tr(t,r,3)),kt(n,t,Hu)}function Vu(n,t,r){return t=tr(t,r,3),It(n,t,Hu)}function Yu(n,t,r){return("function"!=typeof t||"undefined"!=typeof r)&&(t=tr(t,r,3)),Ct(n,t)}function Gu(n,t,r){return t=tr(t,r,3),It(n,t,af)}function Ju(n){return Wt(n,Hu(n))}function Xu(n,t){return n?io.call(n,t):!1}function Zu(n,t,r){r&&Ir(n,t,r)&&(t=null);for(var e=-1,u=af(n),i=u.length,o={};++e<i;){var f=u[e],a=n[f];t?io.call(o,a)?o[a].push(f):o[a]=[f]:o[a]=f}return o}function Hu(n){if(null==n)return[];Ou(n)||(n=Ji(n));var t=n.length;t=t&&Or(t)&&(rf(n)||qo.nonEnumArgs&&xu(n))&&t||0;for(var r=n.constructor,e=-1,u="function"==typeof r&&r.prototype===n,i=qi(t),o=t>0;++e<t;)i[e]=e+"";for(var f in n)o&&kr(f,t)||"constructor"==f&&(u||!io.call(n,f))||i.push(f);return i}function Qu(n,t,r){var e={};return t=wr(t,r,3),Ct(n,function(n,r,u){e[r]=t(n,r,u)}),e}function ni(n,t,r){if(null==n)return{};if("function"!=typeof t){var e=ut(Rt(arguments,!1,!1,1),Zi);return Wr(n,mt(Hu(n),e))}return t=tr(t,r,3),Sr(n,function(n,r,e){return!t(n,r,e)})}function ti(n){for(var t=-1,r=af(n),e=r.length,u=qi(e);++t<e;){var i=r[t];u[t]=[i,n[i]]}return u}function ri(n,t,r){return null==n?{}:"function"==typeof t?Sr(n,tr(t,r,3)):Wr(n,Rt(arguments,!1,!1,1))}function ei(n,t,r){var e=null==n?b:n[t];return"undefined"==typeof e&&(e=r),uf(e)?e.call(n):e}function ui(n,t,r,e){var u=rf(n)||$u(n);if(t=wr(t,e,4),null==r)if(u||Ou(n)){var i=n.constructor;r=u?rf(n)?new i:[]:Po(uf(i)&&i.prototype)}else r={};return(u?nt:Ct)(n,function(n,e,u){return t(r,n,e,u)}),r}function ii(n){return Zt(n,af(n))}function oi(n){return Zt(n,Hu(n))}function fi(n,t,r){return t=+t||0,"undefined"==typeof r?(r=t,t=0):r=+r||0,n>=t&&r>n}function ai(n,t,r){r&&Ir(n,t,r)&&(t=r=null);var e=null==n,u=null==t;if(null==r&&(u&&"boolean"==typeof n?(r=n,n=1):"boolean"==typeof t&&(r=t,u=!0)),e&&u&&(t=1,u=!1),n=+n||0,u?(t=n,
n=0):t=+t||0,r||n%1||t%1){var i=No();return Co(n+i*(t-n+parseFloat("1e-"+((i+"").length-1))),t)}return Pt(n,t)}function ci(n){return n=e(n),n&&n.charAt(0).toUpperCase()+n.slice(1)}function li(n){return n=e(n),n&&n.replace(Rn,c)}function si(n,t,r){n=e(n),t+="";var u=n.length;return r="undefined"==typeof r?u:Co(0>r?0:+r||0,u),r-=t.length,r>=0&&n.indexOf(t,r)==r}function pi(n){return n=e(n),n&&yn.test(n)?n.replace(_n,l):n}function hi(n){return n=e(n),n&&On.test(n)?n.replace(In,"\\$&"):n}function vi(n,t,r){n=e(n),t=+t;var u=n.length;if(u>=t||!ko(t))return n;var i=(t-u)/2,o=vo(i),f=po(i);return r=hr("",f,r),r.slice(0,o)+n+r}function _i(n,t,r){return n=e(n),n&&hr(n,t,r)+n}function gi(n,t,r){return n=e(n),n&&n+hr(n,t,r)}function yi(n,t,r){return r&&Ir(n,t,r)&&(t=0),So(n,t)}function di(n,t){var r="";if(n=e(n),t=+t,1>t||!n||!ko(t))return r;do t%2&&(r+=n),t=vo(t/2),n+=n;while(t);return r}function mi(n,t,r){return n=e(n),r=null==r?0:Co(0>r?0:+r||0,n.length),n.lastIndexOf(t,r)==r}function wi(n,t,r){var u=Y.templateSettings;r&&Ir(n,t,r)&&(t=r=null),n=e(n),t=pt(pt({},r||t),u,st);var i,o,f=pt(pt({},t.imports),u.imports,st),a=af(f),c=Zt(f,a),l=0,p=t.interpolate||kn,h="__p += '",v=Xi((t.escape||kn).source+"|"+p.source+"|"+(p===wn?bn:kn).source+"|"+(t.evaluate||kn).source+"|$","g"),_="//# sourceURL="+("sourceURL"in t?t.sourceURL:"lodash.templateSources["+ ++Un+"]")+"\n";n.replace(v,function(t,r,e,u,f,a){return e||(e=u),h+=n.slice(l,a).replace(Tn,s),r&&(i=!0,h+="' +\n__e("+r+") +\n'"),f&&(o=!0,h+="';\n"+f+";\n__p += '"),e&&(h+="' +\n((__t = ("+e+")) == null ? '' : __t) +\n'"),l=a+t.length,t}),h+="';\n";var g=t.variable;g||(h="with (obj) {\n"+h+"\n}\n"),h=(o?h.replace(sn,""):h).replace(pn,"$1").replace(hn,"$1;"),h="function("+(g||"obj")+") {\n"+(g?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(i?", __e = _.escape":"")+(o?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+h+"return __p\n}";var y=ki(function(){return Vi(a,_+"return "+h).apply(b,c)});if(y.source=h,Iu(y))throw y;return y}function bi(n,t,r){var u=n;return(n=e(n))?(r?Ir(u,t,r):null==t)?n.slice(y(n),d(n)+1):(t+="",n.slice(i(n,t),o(n,t)+1)):n}function xi(n,t,r){var u=n;return n=e(n),n?(r?Ir(u,t,r):null==t)?n.slice(y(n)):n.slice(i(n,t+"")):n}function Ai(n,t,r){var u=n;return n=e(n),n?(r?Ir(u,t,r):null==t)?n.slice(0,d(n)+1):n.slice(0,o(n,t+"")+1):n}function ji(n,t,r){r&&Ir(n,t,r)&&(t=null);var u=W,i=S;if(null!=t)if(Ou(t)){var o="separator"in t?t.separator:o;u="length"in t?+t.length||0:u,i="omission"in t?e(t.omission):i}else u=+t||0;if(n=e(n),u>=n.length)return n;var f=u-i.length;if(1>f)return i;var a=n.slice(0,f);if(null==o)return a+i;if(Uu(o)){if(n.slice(f).search(o)){var c,l,s=n.slice(0,f);for(o.global||(o=Xi(o.source,(xn.exec(o)||"")+"g")),o.lastIndex=0;c=o.exec(s);)l=c.index;a=a.slice(0,null==l?f:l)}}else if(n.indexOf(o,f)!=f){var p=a.lastIndexOf(o);p>-1&&(a=a.slice(0,p))}return a+i}function Ei(n){return n=e(n),n&&gn.test(n)?n.replace(vn,m):n}function Ri(n,t,r){return r&&Ir(n,t,r)&&(t=null),n=e(n),n.match(t||Wn)||[]}function ki(){for(var n=arguments[0],t=arguments.length,r=qi(t?t-1:0);--t>0;)r[t-1]=arguments[t];try{return n.apply(b,r)}catch(e){return Iu(e)?e:new Ki(e)}}function Ii(n,t,r){return r&&Ir(n,t,r)&&(t=null),h(n)?Ti(n):gt(n,t)}function Oi(n){return function(){return n}}function Ci(n){return n}function Ti(n){return Lt(yt(n,!0))}function Wi(n,t){return Bt(n+"",yt(t,!0))}function Si(n,t,r){if(null==r){var e=Ou(t),u=e&&af(t),i=u&&u.length&&Wt(t,u);(i?i.length:e)||(i=!1,r=t,t=n,n=this)}i||(i=Wt(t,af(t)));var o=!0,f=-1,a=uf(n),c=i.length;r===!1?o=!1:Ou(r)&&"chain"in r&&(o=r.chain);for(;++f<c;){var l=i[f],s=t[l];n[l]=s,a&&(n.prototype[l]=function(t){return function(){var r=this.__chain__;if(o||r){var e=n(this.__wrapped__);return(e.__actions__=Qn(this.__actions__)).push({func:t,args:arguments,thisArg:n}),e.__chain__=r,e}var u=[this.value()];return go.apply(u,arguments),t.apply(n,u)}}(s))}return n}function Ni(){return v._=ao,this}function Ui(){}function Fi(n){return Mt(n+"")}function $i(n){return function(t){return null==n?b:n[t]}}function Li(n,t,r){r&&Ir(n,t,r)&&(t=r=null),n=+n||0,r=null==r?1:+r||0,null==t?(t=n,n=0):t=+t||0;for(var e=-1,u=Oo(po((t-n)/(r||1)),0),i=qi(u);++e<u;)i[e]=n,n+=r;return i}function Bi(n,t,r){if(n=+n,1>n||!ko(n))return[];var e=-1,u=qi(Co(n,$o));for(t=tr(t,r,1);++e<n;)$o>e?u[e]=t(e):t(e);return u}function Di(n){var t=++oo;return e(n)+t}function zi(n,t){return n+t}function Mi(n){rf(n)||(n=$r(n));for(var t=n.length,r=0;t--;)r+=+n[t]||0;return r}v=v?Xn.defaults(Jn.Object(),v,Xn.pick(Jn,Nn)):Jn;var qi=v.Array,Pi=v.Date,Ki=v.Error,Vi=v.Function,Yi=v.Math,Gi=v.Number,Ji=v.Object,Xi=v.RegExp,Zi=v.String,Hi=v.TypeError,Qi=qi.prototype,no=Ji.prototype,to=Zi.prototype,ro=(ro=v.window)&&ro.document,eo=Vi.prototype.toString,uo=Mt("length"),io=no.hasOwnProperty,oo=0,fo=no.toString,ao=v._,co=Xi("^"+hi(fo).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),lo=Wu(lo=v.ArrayBuffer)&&lo,so=Wu(so=lo&&new lo(0).slice)&&so,po=Yi.ceil,ho=v.clearTimeout,vo=Yi.floor,_o=Wu(_o=Ji.getPrototypeOf)&&_o,go=Qi.push,yo=no.propertyIsEnumerable,mo=Wu(mo=v.Set)&&mo,wo=v.setTimeout,bo=Qi.splice,xo=Wu(xo=v.Uint8Array)&&xo,Ao=Wu(Ao=v.WeakMap)&&Ao,jo=function(){try{var n=Wu(n=v.Float64Array)&&n,t=new n(new lo(10),0,1)&&n}catch(r){}return t}(),Eo=Wu(Eo=qi.isArray)&&Eo,Ro=Wu(Ro=Ji.create)&&Ro,ko=v.isFinite,Io=Wu(Io=Ji.keys)&&Io,Oo=Yi.max,Co=Yi.min,To=Wu(To=Pi.now)&&To,Wo=Wu(Wo=Gi.isFinite)&&Wo,So=v.parseInt,No=Yi.random,Uo=Gi.NEGATIVE_INFINITY,Fo=Gi.POSITIVE_INFINITY,$o=Yi.pow(2,32)-1,Lo=$o-1,Bo=$o>>>1,Do=jo?jo.BYTES_PER_ELEMENT:0,zo=Yi.pow(2,53)-1,Mo=Ao&&new Ao,qo=Y.support={};!function(n){qo.funcDecomp=!Wu(v.WinRTError)&&Cn.test(w),qo.funcNames="string"==typeof Vi.name;try{qo.dom=11===ro.createDocumentFragment().nodeType}catch(t){qo.dom=!1}try{qo.nonEnumArgs=!yo.call(arguments,1)}catch(t){qo.nonEnumArgs=!0}}(0,0),Y.templateSettings={escape:dn,evaluate:mn,interpolate:wn,variable:"",imports:{_:Y}};var Po=function(){function n(){}return function(t){if(Ou(t)){n.prototype=t;var r=new n;n.prototype=null}return r||v.Object()}}(),Ko=Mo?function(n,t){return Mo.set(n,t),n}:Ci;so||(rr=lo&&xo?function(n){var t=n.byteLength,r=jo?vo(t/Do):0,e=r*Do,u=new lo(t);if(r){var i=new jo(u,0,r);i.set(new jo(n,0,r))}return t!=e&&(i=new xo(u,e),i.set(new xo(n,e))),u}:Oi(null));var Vo=Ro&&mo?function(n){return new Gn(n)}:Oi(null),Yo=Mo?function(n){return Mo.get(n)}:Ui,Go=function(){var n=0,t=0;return function(r,e){var u=Qo(),i=U-(u-t);if(t=u,i>0){if(++n>=N)return r}else n=0;return Ko(r,e)}}(),Jo=ir(function(n,t,r){io.call(n,r)?++n[r]:n[r]=1}),Xo=ir(function(n,t,r){io.call(n,r)?n[r].push(t):n[r]=[t]}),Zo=ir(function(n,t,r){n[r]=t}),Ho=ir(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Qo=To||function(){return(new Pi).getTime()},nf=ar(),tf=ar(!0),rf=Eo||function(n){return h(n)&&Or(n.length)&&fo.call(n)==M||!1};qo.dom||(Eu=function(n){return n&&1===n.nodeType&&h(n)&&!of(n)||!1});var ef=Wo||function(n){return"number"==typeof n&&ko(n)},uf=r(/x/)||xo&&!r(xo)?function(n){return fo.call(n)==V}:r,of=_o?function(n){if(!n||fo.call(n)!=J)return!1;var t=n.valueOf,r=Wu(t)&&(r=_o(t))&&_o(r);return r?n==r||_o(n)==r:Ur(n)}:Ur,ff=or(pt),af=Io?function(n){if(n)var t=n.constructor,r=n.length;return"function"==typeof t&&t.prototype===n||"function"!=typeof n&&r&&Or(r)?Fr(n):Ou(n)?Io(n):[]}:Fr,cf=or(Dt),lf=cr(function(n,t,r){return t=t.toLowerCase(),n+(r?t.charAt(0).toUpperCase()+t.slice(1):t)}),sf=cr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()});8!=So(Sn+"08")&&(yi=function(n,t,r){return(r?Ir(n,t,r):null==t)?t=0:t&&(t=+t),n=bi(n),So(n,t||(jn.test(n)?16:10))});var pf=cr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),hf=cr(function(n,t,r){return n+(r?" ":"")+(t.charAt(0).toUpperCase()+t.slice(1))}),vf=sr(it),_f=sr(ot,!0);return Y.prototype=Z.prototype,Q.prototype=Po(Z.prototype),Q.prototype.constructor=Q,Bn.prototype=Po(Z.prototype),Bn.prototype.constructor=Bn,qn.prototype["delete"]=Pn,qn.prototype.get=Kn,qn.prototype.has=Vn,qn.prototype.set=Yn,Gn.prototype.push=Hn,su.Cache=qn,Y.after=nu,Y.ary=tu,Y.assign=ff,Y.at=Te,Y.before=ru,Y.bind=eu,Y.bindAll=uu,Y.bindKey=iu,Y.callback=Ii,Y.chain=xe,Y.chunk=Dr,Y.compact=zr,Y.constant=Oi,Y.countBy=Jo,Y.create=zu,Y.curry=ou,Y.curryRight=fu,Y.debounce=au,Y.defaults=Mu,Y.defer=cu,Y.delay=lu,Y.difference=Mr,Y.drop=qr,Y.dropRight=Pr,Y.dropRightWhile=Kr,Y.dropWhile=Vr,Y.fill=Yr,Y.filter=Se,Y.flatten=Zr,Y.flattenDeep=Hr,Y.flow=nf,Y.flowRight=tf,Y.forEach=$e,Y.forEachRight=Le,Y.forIn=Ku,Y.forInRight=Vu,Y.forOwn=Yu,Y.forOwnRight=Gu,Y.functions=Ju,Y.groupBy=Xo,Y.indexBy=Zo,Y.initial=ne,Y.intersection=te,Y.invert=Zu,Y.invoke=De,Y.keys=af,Y.keysIn=Hu,Y.map=ze,Y.mapValues=Qu,Y.matches=Ti,Y.matchesProperty=Wi,Y.memoize=su,Y.merge=cf,Y.mixin=Si,Y.negate=pu,Y.omit=ni,Y.once=hu,Y.pairs=ti,Y.partial=vu,Y.partialRight=_u,Y.partition=Ho,Y.pick=ri,Y.pluck=Me,Y.property=Fi,Y.propertyOf=$i,Y.pull=ue,Y.pullAt=ie,Y.range=Li,Y.rearg=gu,Y.reject=Ke,Y.remove=oe,Y.rest=fe,Y.shuffle=Ye,Y.slice=ae,Y.sortBy=Xe,Y.sortByAll=Ze,Y.sortByOrder=He,Y.spread=yu,Y.take=se,Y.takeRight=pe,Y.takeRightWhile=he,Y.takeWhile=ve,Y.tap=Ae,Y.throttle=du,Y.thru=je,Y.times=Bi,Y.toArray=Bu,Y.toPlainObject=Du,Y.transform=ui,Y.union=_e,Y.uniq=ge,Y.unzip=ye,Y.values=ii,Y.valuesIn=oi,Y.where=Qe,Y.without=de,Y.wrap=mu,Y.xor=me,Y.zip=we,Y.zipObject=be,Y.backflow=tf,Y.collect=ze,Y.compose=tf,Y.each=$e,Y.eachRight=Le,Y.extend=ff,Y.iteratee=Ii,Y.methods=Ju,Y.object=be,Y.select=Se,Y.tail=fe,Y.unique=ge,Si(Y,Y),Y.add=zi,Y.attempt=ki,Y.camelCase=lf,Y.capitalize=ci,Y.clone=wu,Y.cloneDeep=bu,Y.deburr=li,Y.endsWith=si,Y.escape=pi,Y.escapeRegExp=hi,Y.every=We,Y.find=Ne,Y.findIndex=Gr,Y.findKey=qu,Y.findLast=Ue,Y.findLastIndex=Jr,Y.findLastKey=Pu,Y.findWhere=Fe,Y.first=Xr,Y.has=Xu,Y.identity=Ci,Y.includes=Be,Y.indexOf=Qr,Y.inRange=fi,Y.isArguments=xu,Y.isArray=rf,Y.isBoolean=Au,Y.isDate=ju,Y.isElement=Eu,Y.isEmpty=Ru,Y.isEqual=ku,Y.isError=Iu,Y.isFinite=ef,Y.isFunction=uf,Y.isMatch=Cu,Y.isNaN=Tu,Y.isNative=Wu,Y.isNull=Su,Y.isNumber=Nu,Y.isObject=Ou,Y.isPlainObject=of,Y.isRegExp=Uu,Y.isString=Fu,Y.isTypedArray=$u,Y.isUndefined=Lu,Y.kebabCase=sf,Y.last=re,Y.lastIndexOf=ee,Y.max=vf,Y.min=_f,Y.noConflict=Ni,Y.noop=Ui,Y.now=Qo,Y.pad=vi,Y.padLeft=_i,Y.padRight=gi,Y.parseInt=yi,Y.random=ai,Y.reduce=qe,Y.reduceRight=Pe,Y.repeat=di,Y.result=ei,Y.runInContext=w,Y.size=Ge,Y.snakeCase=pf,Y.some=Je,Y.sortedIndex=ce,Y.sortedLastIndex=le,Y.startCase=hf,Y.startsWith=mi,Y.sum=Mi,Y.template=wi,Y.trim=bi,Y.trimLeft=xi,Y.trimRight=Ai,Y.trunc=ji,Y.unescape=Ei,Y.uniqueId=Di,Y.words=Ri,Y.all=We,Y.any=Je,Y.contains=Be,Y.detect=Ne,Y.foldl=qe,Y.foldr=Pe,Y.head=Xr,Y.include=Be,Y.inject=qe,Si(Y,function(){var n={};return Ct(Y,function(t,r){Y.prototype[r]||(n[r]=t)}),n}(),!1),Y.sample=Ve,Y.prototype.sample=function(n){return this.__chain__||null!=n?this.thru(function(t){return Ve(t,n)}):Ve(this.value())},Y.VERSION=x,nt(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){Y[n].placeholder=Y}),nt(["dropWhile","filter","map","takeWhile"],function(n,t){var r=t!=L,e=t==F;Bn.prototype[n]=function(n,u){var i=this.__filtered__,o=i&&e?new Bn(this):this.clone(),f=o.__iteratees__||(o.__iteratees__=[]);return f.push({done:!1,count:0,index:0,iteratee:wr(n,u,1),limit:-1,type:t}),o.__filtered__=i||r,o}}),nt(["drop","take"],function(n,t){var r=n+"While";Bn.prototype[n]=function(r){var e=this.__filtered__,u=e&&!t?this.dropWhile():this.clone();if(r=null==r?1:Oo(vo(r)||0,0),e)t?u.__takeCount__=Co(u.__takeCount__,r):re(u.__iteratees__).limit=r;else{var i=u.__views__||(u.__views__=[]);i.push({size:r,type:n+(u.__dir__<0?"Right":"")})}return u},Bn.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()},Bn.prototype[n+"RightWhile"]=function(n,t){return this.reverse()[r](n,t).reverse()}}),nt(["first","last"],function(n,t){var r="take"+(t?"Right":"");Bn.prototype[n]=function(){return this[r](1).value()[0]}}),nt(["initial","rest"],function(n,t){var r="drop"+(t?"":"Right");Bn.prototype[n]=function(){return this[r](1)}}),nt(["pluck","where"],function(n,t){var r=t?"filter":"map",e=t?Lt:Mt;Bn.prototype[n]=function(n){return this[r](e(n))}}),Bn.prototype.compact=function(){return this.filter(Ci)},Bn.prototype.reject=function(n,t){return n=wr(n,t,1),this.filter(function(t){return!n(t)})},Bn.prototype.slice=function(n,t){n=null==n?0:+n||0;var r=0>n?this.takeRight(-n):this.drop(n);return"undefined"!=typeof t&&(t=+t||0,r=0>t?r.dropRight(-t):r.take(t-n)),r},Bn.prototype.toArray=function(){return this.drop(0)},Ct(Bn.prototype,function(n,t){var r=Y[t],e=/^(?:filter|map|reject)|While$/.test(t),u=/^(?:first|last)$/.test(t);Y.prototype[t]=function(){var t=arguments,i=(t.length,this.__chain__),o=this.__wrapped__,f=!!this.__actions__.length,a=o instanceof Bn,c=t[0],l=a||rf(o);l&&e&&"function"==typeof c&&1!=c.length&&(a=l=!1);var s=a&&!f;if(u&&!i)return s?n.call(o):r.call(Y,this.value());var p=function(n){var e=[n];return go.apply(e,t),r.apply(Y,e)};if(l){var h=s?o:new Bn(this),v=n.apply(h,t);if(!u&&(f||v.__actions__)){var _=v.__actions__||(v.__actions__=[]);_.push({func:je,args:[p],thisArg:Y})}return new Q(v,i)}return this.thru(p)}}),nt(["concat","join","pop","push","replace","shift","sort","splice","split","unshift"],function(n){var t=(/^(?:replace|split)$/.test(n)?to:Qi)[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:join|pop|replace|shift)$/.test(n);Y.prototype[n]=function(){var n=arguments;return e&&!this.__chain__?t.apply(this.value(),n):this[r](function(r){return t.apply(r,n)})}}),Bn.prototype.clone=Dn,Bn.prototype.reverse=zn,Bn.prototype.value=Mn,Y.prototype.chain=Ee,Y.prototype.commit=Re,Y.prototype.plant=ke,Y.prototype.reverse=Ie,Y.prototype.toString=Oe,Y.prototype.run=Y.prototype.toJSON=Y.prototype.valueOf=Y.prototype.value=Ce,Y.prototype.collect=Y.prototype.map,Y.prototype.head=Y.prototype.first,Y.prototype.select=Y.prototype.filter,Y.prototype.tail=Y.prototype.rest,Y}var b,x="3.5.0",A=1,j=2,E=4,R=8,k=16,I=32,O=64,C=128,T=256,W=30,S="...",N=150,U=16,F=0,$=1,L=2,B="Expected a function",D="__lodash_placeholder__",z="[object Arguments]",M="[object Array]",q="[object Boolean]",P="[object Date]",K="[object Error]",V="[object Function]",Y="[object Map]",G="[object Number]",J="[object Object]",X="[object RegExp]",Z="[object Set]",H="[object String]",Q="[object WeakMap]",nn="[object ArrayBuffer]",tn="[object Float32Array]",rn="[object Float64Array]",en="[object Int8Array]",un="[object Int16Array]",on="[object Int32Array]",fn="[object Uint8Array]",an="[object Uint8ClampedArray]",cn="[object Uint16Array]",ln="[object Uint32Array]",sn=/\b__p \+= '';/g,pn=/\b(__p \+=) '' \+/g,hn=/(__e\(.*?\)|\b__t\)) \+\n'';/g,vn=/&(?:amp|lt|gt|quot|#39|#96);/g,_n=/[&<>"'`]/g,gn=RegExp(vn.source),yn=RegExp(_n.source),dn=/<%-([\s\S]+?)%>/g,mn=/<%([\s\S]+?)%>/g,wn=/<%=([\s\S]+?)%>/g,bn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,xn=/\w*$/,An=/^\s*function[ \n\r\t]+\w/,jn=/^0[xX]/,En=/^\[object .+?Constructor\]$/,Rn=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,kn=/($^)/,In=/[.*+?^${}()|[\]\/\\]/g,On=RegExp(In.source),Cn=/\bthis\b/,Tn=/['\n\r\u2028\u2029\\]/g,Wn=function(){var n="[A-Z\\xc0-\\xd6\\xd8-\\xde]",t="[a-z\\xdf-\\xf6\\xf8-\\xff]+";return RegExp(n+"+(?="+n+t+")|"+n+"?"+t+"|"+n+"+|[0-9]+","g")}(),Sn=" 	\f \ufeff\n\r\u2028\u2029 ᠎             　",Nn=["Array","ArrayBuffer","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Math","Number","Object","RegExp","Set","String","_","clearTimeout","document","isFinite","parseInt","setTimeout","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","window","WinRTError"],Un=-1,Fn={};Fn[tn]=Fn[rn]=Fn[en]=Fn[un]=Fn[on]=Fn[fn]=Fn[an]=Fn[cn]=Fn[ln]=!0,Fn[z]=Fn[M]=Fn[nn]=Fn[q]=Fn[P]=Fn[K]=Fn[V]=Fn[Y]=Fn[G]=Fn[J]=Fn[X]=Fn[Z]=Fn[H]=Fn[Q]=!1;var $n={};$n[z]=$n[M]=$n[nn]=$n[q]=$n[P]=$n[tn]=$n[rn]=$n[en]=$n[un]=$n[on]=$n[G]=$n[J]=$n[X]=$n[H]=$n[fn]=$n[an]=$n[cn]=$n[ln]=!0,$n[K]=$n[V]=$n[Y]=$n[Z]=$n[Q]=!1;var Ln={leading:!1,maxWait:0,trailing:!1},Bn={"À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","Ç":"C","ç":"c","Ð":"D","ð":"d","È":"E","É":"E","Ê":"E","Ë":"E","è":"e","é":"e","ê":"e","ë":"e","Ì":"I","Í":"I","Î":"I","Ï":"I","ì":"i","í":"i","î":"i","ï":"i","Ñ":"N","ñ":"n","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","Ù":"U","Ú":"U","Û":"U","Ü":"U","ù":"u","ú":"u","û":"u","ü":"u","Ý":"Y","ý":"y","ÿ":"y","Æ":"Ae","æ":"ae","Þ":"Th","þ":"th","ß":"ss"},Dn={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"},zn={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&#96;":"`"},Mn={"function":!0,object:!0},qn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Pn=Mn[typeof exports]&&exports&&!exports.nodeType&&exports,Kn=Mn[typeof module]&&module&&!module.nodeType&&module,Vn=Pn&&Kn&&"object"==typeof global&&global,Yn=Mn[typeof window]&&window,Gn=Kn&&Kn.exports===Pn&&Pn,Jn=Vn||Yn!==(this&&this.window)&&Yn||this,Xn=w();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(Jn._=Xn,define(function(){return Xn})):Pn&&Kn?Gn?(Kn.exports=Xn)._=Xn:Pn._=Xn:Jn._=Xn}).call(this);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],9:[function(require,module,exports){
(function (process){
!function(t){"use strict";if("function"==typeof bootstrap)bootstrap("promise",t);else if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define(t);else if("undefined"!=typeof ses){if(!ses.ok())return;ses.makeQ=t}else{if("undefined"==typeof self)throw new Error("This environment was not anticipated by Q. Please file a bug.");self.Q=t()}}(function(){"use strict";function t(t){return function(){return K.apply(t,arguments)}}function n(t){return t===Object(t)}function e(t){return"[object StopIteration]"===et(t)||t instanceof q}function r(t,n){if(V&&n.stack&&"object"==typeof t&&null!==t&&t.stack&&-1===t.stack.indexOf(rt)){for(var e=[],r=n;r;r=r.source)r.stack&&e.unshift(r.stack);e.unshift(t.stack);var i=e.join("\n"+rt+"\n");t.stack=o(i)}}function o(t){for(var n=t.split("\n"),e=[],r=0;r<n.length;++r){var o=n[r];c(o)||i(o)||!o||e.push(o)}return e.join("\n")}function i(t){return-1!==t.indexOf("(module.js:")||-1!==t.indexOf("(node.js:")}function u(t){var n=/at .+ \((.+):(\d+):(?:\d+)\)$/.exec(t);if(n)return[n[1],Number(n[2])];var e=/at ([^ ]+):(\d+):(?:\d+)$/.exec(t);if(e)return[e[1],Number(e[2])];var r=/.*@(.+):(\d+)$/.exec(t);return r?[r[1],Number(r[2])]:void 0}function c(t){var n=u(t);if(!n)return!1;var e=n[0],r=n[1];return e===_&&r>=z&&ct>=r}function s(){if(V)try{throw new Error}catch(t){var n=t.stack.split("\n"),e=n[0].indexOf("@")>0?n[1]:n[2],r=u(e);if(!r)return;return _=r[0],r[1]}}function f(t,n,e){return function(){return"undefined"!=typeof console&&"function"==typeof console.warn&&console.warn(n+" is deprecated, use "+e+" instead.",new Error("").stack),t.apply(t,arguments)}}function p(t){return t instanceof h?t:g(t)?E(t):O(t)}function a(){function t(t){n=t,i.source=t,W(e,function(n,e){p.nextTick(function(){t.promiseDispatch.apply(t,e)})},void 0),e=void 0,r=void 0}var n,e=[],r=[],o=Z(a.prototype),i=Z(h.prototype);if(i.promiseDispatch=function(t,o,i){var u=L(arguments);e?(e.push(u),"when"===o&&i[1]&&r.push(i[1])):p.nextTick(function(){n.promiseDispatch.apply(n,u)})},i.valueOf=function(){if(e)return i;var t=v(n);return m(t)&&(n=t),t},i.inspect=function(){return n?n.inspect():{state:"pending"}},p.longStackSupport&&V)try{throw new Error}catch(u){i.stack=u.stack.substring(u.stack.indexOf("\n")+1)}return o.promise=i,o.resolve=function(e){n||t(p(e))},o.fulfill=function(e){n||t(O(e))},o.reject=function(e){n||t(R(e))},o.notify=function(t){n||W(r,function(n,e){p.nextTick(function(){e(t)})},void 0)},o}function l(t){if("function"!=typeof t)throw new TypeError("resolver must be a function.");var n=a();try{t(n.resolve,n.reject,n.notify)}catch(e){n.reject(e)}return n.promise}function d(t){return l(function(n,e){for(var r=0,o=t.length;o>r;r++)p(t[r]).then(n,e)})}function h(t,n,e){void 0===n&&(n=function(t){return R(new Error("Promise does not support operation: "+t))}),void 0===e&&(e=function(){return{state:"unknown"}});var r=Z(h.prototype);if(r.promiseDispatch=function(e,o,i){var u;try{u=t[o]?t[o].apply(r,i):n.call(r,o,i)}catch(c){u=R(c)}e&&e(u)},r.inspect=e,e){var o=e();"rejected"===o.state&&(r.exception=o.reason),r.valueOf=function(){var t=e();return"pending"===t.state||"rejected"===t.state?r:t.value}}return r}function y(t,n,e,r){return p(t).then(n,e,r)}function v(t){if(m(t)){var n=t.inspect();if("fulfilled"===n.state)return n.value}return t}function m(t){return t instanceof h}function g(t){return n(t)&&"function"==typeof t.then}function k(t){return m(t)&&"pending"===t.inspect().state}function j(t){return!m(t)||"fulfilled"===t.inspect().state}function w(t){return m(t)&&"rejected"===t.inspect().state}function x(){ot.length=0,it.length=0,ut||(ut=!0)}function b(t,n){ut&&(it.push(t),n&&"undefined"!=typeof n.stack?ot.push(n.stack):ot.push("(no stack) "+n))}function T(t){if(ut){var n=X(it,t);-1!==n&&(it.splice(n,1),ot.splice(n,1))}}function R(t){var n=h({when:function(n){return n&&T(this),n?n(t):this}},function(){return this},function(){return{state:"rejected",reason:t}});return b(n,t),n}function O(t){return h({when:function(){return t},get:function(n){return t[n]},set:function(n,e){t[n]=e},"delete":function(n){delete t[n]},post:function(n,e){return null===n||void 0===n?t.apply(void 0,e):t[n].apply(t,e)},apply:function(n,e){return t.apply(n,e)},keys:function(){return nt(t)}},void 0,function(){return{state:"fulfilled",value:t}})}function E(t){var n=a();return p.nextTick(function(){try{t.then(n.resolve,n.reject,n.notify)}catch(e){n.reject(e)}}),n.promise}function S(t){return h({isDef:function(){}},function(n,e){return A(t,n,e)},function(){return p(t).inspect()})}function N(t,n,e){return p(t).spread(n,e)}function D(t){return function(){function n(t,n){var u;if("undefined"==typeof StopIteration){try{u=r[t](n)}catch(c){return R(c)}return u.done?p(u.value):y(u.value,o,i)}try{u=r[t](n)}catch(c){return e(c)?p(c.value):R(c)}return y(u,o,i)}var r=t.apply(this,arguments),o=n.bind(n,"next"),i=n.bind(n,"throw");return o()}}function P(t){p.done(p.async(t)())}function C(t){throw new q(t)}function I(t){return function(){return N([this,U(arguments)],function(n,e){return t.apply(n,e)})}}function A(t,n,e){return p(t).dispatch(n,e)}function U(t){return y(t,function(t){var n=0,e=a();return W(t,function(r,o,i){var u;m(o)&&"fulfilled"===(u=o.inspect()).state?t[i]=u.value:(++n,y(o,function(r){t[i]=r,0===--n&&e.resolve(t)},e.reject,function(t){e.notify({index:i,value:t})}))},void 0),0===n&&e.resolve(t),e.promise})}function F(t){if(0===t.length)return p.resolve();var n=p.defer(),e=0;return W(t,function(r,o,i){function u(t){n.resolve(t)}function c(){e--,0===e&&n.reject(new Error("Can't get fulfillment value from any promise, all promises were rejected."))}function s(t){n.notify({index:i,value:t})}var f=t[i];e++,y(f,u,c,s)},void 0),n.promise}function M(t){return y(t,function(t){return t=Y(t,p),y(U(Y(t,function(t){return y(t,H,H)})),function(){return t})})}function Q(t){return p(t).allSettled()}function B(t,n){return p(t).then(void 0,void 0,n)}function $(t,n){return p(t).nodeify(n)}var V=!1;try{throw new Error}catch(G){V=!!G.stack}var _,q,z=s(),H=function(){},J=function(){function t(){for(;n.next;){n=n.next;var e=n.task;n.task=void 0;var o=n.domain;o&&(n.domain=void 0,o.enter());try{e()}catch(u){if(i)throw o&&o.exit(),setTimeout(t,0),o&&o.enter(),u;setTimeout(function(){throw u},0)}o&&o.exit()}r=!1}var n={task:void 0,next:null},e=n,r=!1,o=void 0,i=!1;if(J=function(t){e=e.next={task:t,domain:i&&process.domain,next:null},r||(r=!0,o())},"undefined"!=typeof process&&process.nextTick)i=!0,o=function(){process.nextTick(t)};else if("function"==typeof setImmediate)o="undefined"!=typeof window?setImmediate.bind(window,t):function(){setImmediate(t)};else if("undefined"!=typeof MessageChannel){var u=new MessageChannel;u.port1.onmessage=function(){o=c,u.port1.onmessage=t,t()};var c=function(){u.port2.postMessage(0)};o=function(){setTimeout(t,0),c()}}else o=function(){setTimeout(t,0)};return J}(),K=Function.call,L=t(Array.prototype.slice),W=t(Array.prototype.reduce||function(t,n){var e=0,r=this.length;if(1===arguments.length)for(;;){if(e in this){n=this[e++];break}if(++e>=r)throw new TypeError}for(;r>e;e++)e in this&&(n=t(n,this[e],e));return n}),X=t(Array.prototype.indexOf||function(t){for(var n=0;n<this.length;n++)if(this[n]===t)return n;return-1}),Y=t(Array.prototype.map||function(t,n){var e=this,r=[];return W(e,function(o,i,u){r.push(t.call(n,i,u,e))},void 0),r}),Z=Object.create||function(t){function n(){}return n.prototype=t,new n},tt=t(Object.prototype.hasOwnProperty),nt=Object.keys||function(t){var n=[];for(var e in t)tt(t,e)&&n.push(e);return n},et=t(Object.prototype.toString);q="undefined"!=typeof ReturnValue?ReturnValue:function(t){this.value=t};var rt="From previous event:";p.resolve=p,p.nextTick=J,p.longStackSupport=!1,"object"==typeof process&&process&&process.env&&process.env.Q_DEBUG&&(p.longStackSupport=!0),p.defer=a,a.prototype.makeNodeResolver=function(){var t=this;return function(n,e){n?t.reject(n):arguments.length>2?t.resolve(L(arguments,1)):t.resolve(e)}},p.Promise=l,p.promise=l,l.race=d,l.all=U,l.reject=R,l.resolve=p,p.passByCopy=function(t){return t},h.prototype.passByCopy=function(){return this},p.join=function(t,n){return p(t).join(n)},h.prototype.join=function(t){return p([this,t]).spread(function(t,n){if(t===n)return t;throw new Error("Can't join: not the same: "+t+" "+n)})},p.race=d,h.prototype.race=function(){return this.then(p.race)},p.makePromise=h,h.prototype.toString=function(){return"[object Promise]"},h.prototype.then=function(t,n,e){function o(n){try{return"function"==typeof t?t(n):n}catch(e){return R(e)}}function i(t){if("function"==typeof n){r(t,c);try{return n(t)}catch(e){return R(e)}}return R(t)}function u(t){return"function"==typeof e?e(t):t}var c=this,s=a(),f=!1;return p.nextTick(function(){c.promiseDispatch(function(t){f||(f=!0,s.resolve(o(t)))},"when",[function(t){f||(f=!0,s.resolve(i(t)))}])}),c.promiseDispatch(void 0,"when",[void 0,function(t){var n,e=!1;try{n=u(t)}catch(r){if(e=!0,!p.onerror)throw r;p.onerror(r)}e||s.notify(n)}]),s.promise},p.tap=function(t,n){return p(t).tap(n)},h.prototype.tap=function(t){return t=p(t),this.then(function(n){return t.fcall(n).thenResolve(n)})},p.when=y,h.prototype.thenResolve=function(t){return this.then(function(){return t})},p.thenResolve=function(t,n){return p(t).thenResolve(n)},h.prototype.thenReject=function(t){return this.then(function(){throw t})},p.thenReject=function(t,n){return p(t).thenReject(n)},p.nearer=v,p.isPromise=m,p.isPromiseAlike=g,p.isPending=k,h.prototype.isPending=function(){return"pending"===this.inspect().state},p.isFulfilled=j,h.prototype.isFulfilled=function(){return"fulfilled"===this.inspect().state},p.isRejected=w,h.prototype.isRejected=function(){return"rejected"===this.inspect().state};var ot=[],it=[],ut=!0;p.resetUnhandledRejections=x,p.getUnhandledReasons=function(){return ot.slice()},p.stopUnhandledRejectionTracking=function(){x(),ut=!1},x(),p.reject=R,p.fulfill=O,p.master=S,p.spread=N,h.prototype.spread=function(t,n){return this.all().then(function(n){return t.apply(void 0,n)},n)},p.async=D,p.spawn=P,p["return"]=C,p.promised=I,p.dispatch=A,h.prototype.dispatch=function(t,n){var e=this,r=a();return p.nextTick(function(){e.promiseDispatch(r.resolve,t,n)}),r.promise},p.get=function(t,n){return p(t).dispatch("get",[n])},h.prototype.get=function(t){return this.dispatch("get",[t])},p.set=function(t,n,e){return p(t).dispatch("set",[n,e])},h.prototype.set=function(t,n){return this.dispatch("set",[t,n])},p.del=p["delete"]=function(t,n){return p(t).dispatch("delete",[n])},h.prototype.del=h.prototype["delete"]=function(t){return this.dispatch("delete",[t])},p.mapply=p.post=function(t,n,e){return p(t).dispatch("post",[n,e])},h.prototype.mapply=h.prototype.post=function(t,n){return this.dispatch("post",[t,n])},p.send=p.mcall=p.invoke=function(t,n){return p(t).dispatch("post",[n,L(arguments,2)])},h.prototype.send=h.prototype.mcall=h.prototype.invoke=function(t){return this.dispatch("post",[t,L(arguments,1)])},p.fapply=function(t,n){return p(t).dispatch("apply",[void 0,n])},h.prototype.fapply=function(t){return this.dispatch("apply",[void 0,t])},p["try"]=p.fcall=function(t){return p(t).dispatch("apply",[void 0,L(arguments,1)])},h.prototype.fcall=function(){return this.dispatch("apply",[void 0,L(arguments)])},p.fbind=function(t){var n=p(t),e=L(arguments,1);return function(){return n.dispatch("apply",[this,e.concat(L(arguments))])}},h.prototype.fbind=function(){var t=this,n=L(arguments);return function(){return t.dispatch("apply",[this,n.concat(L(arguments))])}},p.keys=function(t){return p(t).dispatch("keys",[])},h.prototype.keys=function(){return this.dispatch("keys",[])},p.all=U,h.prototype.all=function(){return U(this)},p.any=F,h.prototype.any=function(){return F(this)},p.allResolved=f(M,"allResolved","allSettled"),h.prototype.allResolved=function(){return M(this)},p.allSettled=Q,h.prototype.allSettled=function(){return this.then(function(t){return U(Y(t,function(t){function n(){return t.inspect()}return t=p(t),t.then(n,n)}))})},p.fail=p["catch"]=function(t,n){return p(t).then(void 0,n)},h.prototype.fail=h.prototype["catch"]=function(t){return this.then(void 0,t)},p.progress=B,h.prototype.progress=function(t){return this.then(void 0,void 0,t)},p.fin=p["finally"]=function(t,n){return p(t)["finally"](n)},h.prototype.fin=h.prototype["finally"]=function(t){return t=p(t),this.then(function(n){return t.fcall().then(function(){return n})},function(n){return t.fcall().then(function(){throw n})})},p.done=function(t,n,e,r){return p(t).done(n,e,r)},h.prototype.done=function(t,n,e){var o=function(t){p.nextTick(function(){if(r(t,i),!p.onerror)throw t;p.onerror(t)})},i=t||n||e?this.then(t,n,e):this;"object"==typeof process&&process&&process.domain&&(o=process.domain.bind(o)),i.then(void 0,o)},p.timeout=function(t,n,e){return p(t).timeout(n,e)},h.prototype.timeout=function(t,n){var e=a(),r=setTimeout(function(){n&&"string"!=typeof n||(n=new Error(n||"Timed out after "+t+" ms"),n.code="ETIMEDOUT"),e.reject(n)},t);return this.then(function(t){clearTimeout(r),e.resolve(t)},function(t){clearTimeout(r),e.reject(t)},e.notify),e.promise},p.delay=function(t,n){return void 0===n&&(n=t,t=void 0),p(t).delay(n)},h.prototype.delay=function(t){return this.then(function(n){var e=a();return setTimeout(function(){e.resolve(n)},t),e.promise})},p.nfapply=function(t,n){return p(t).nfapply(n)},h.prototype.nfapply=function(t){var n=a(),e=L(t);return e.push(n.makeNodeResolver()),this.fapply(e).fail(n.reject),n.promise},p.nfcall=function(t){var n=L(arguments,1);return p(t).nfapply(n)},h.prototype.nfcall=function(){var t=L(arguments),n=a();return t.push(n.makeNodeResolver()),this.fapply(t).fail(n.reject),n.promise},p.nfbind=p.denodeify=function(t){var n=L(arguments,1);return function(){var e=n.concat(L(arguments)),r=a();return e.push(r.makeNodeResolver()),p(t).fapply(e).fail(r.reject),r.promise}},h.prototype.nfbind=h.prototype.denodeify=function(){var t=L(arguments);return t.unshift(this),p.denodeify.apply(void 0,t)},p.nbind=function(t,n){var e=L(arguments,2);return function(){function r(){return t.apply(n,arguments)}var o=e.concat(L(arguments)),i=a();return o.push(i.makeNodeResolver()),p(r).fapply(o).fail(i.reject),i.promise}},h.prototype.nbind=function(){var t=L(arguments,0);return t.unshift(this),p.nbind.apply(void 0,t)},p.nmapply=p.npost=function(t,n,e){return p(t).npost(n,e)},h.prototype.nmapply=h.prototype.npost=function(t,n){var e=L(n||[]),r=a();return e.push(r.makeNodeResolver()),this.dispatch("post",[t,e]).fail(r.reject),r.promise},p.nsend=p.nmcall=p.ninvoke=function(t,n){var e=L(arguments,2),r=a();return e.push(r.makeNodeResolver()),p(t).dispatch("post",[n,e]).fail(r.reject),r.promise},h.prototype.nsend=h.prototype.nmcall=h.prototype.ninvoke=function(t){var n=L(arguments,1),e=a();return n.push(e.makeNodeResolver()),this.dispatch("post",[t,n]).fail(e.reject),e.promise},p.nodeify=$,h.prototype.nodeify=function(t){return t?void this.then(function(n){p.nextTick(function(){t(null,n)})},function(n){p.nextTick(function(){t(n)})}):this};var ct=s();return p});
}).call(this,require('_process'))

},{"_process":1}]},{},[7])(7)
});


//# sourceMappingURL=expandjs.min.map</script><script>
    Polymer.MatPalette = {

        /**
         * Returns the palette's RGB value.
         *
         * @method _getColor
         * @param {string} palette
         * @returns {string}
         * @private
         */
        _getColor: function (palette) {
            return this.palettes.light[palette] || this.palettes.dark[palette] || null;
        },

        /**
         * Returns the palette's foreground.
         *
         * @method _getForeground
         * @param {string} [palette = "light"]
         * @param {boolean} [inverse = false]
         * @returns {string}
         * @private
         */
        _getForeground: function (palette, inverse) {
            var result = palette && (palette === 'dark' || this.palettes.dark[palette]) ? 'light' : 'dark';
            return inverse ? (result === 'light' ? 'dark' : 'light') : result;
        },

        /*********************************************************************/

        /**
         * The list of material palettes.
         *
         * @property palettes
         * @type Object
         * @readonly
         */
        palettes: {
            light: {
                'amber': '#FFC107',
                'amber-100': '#FFECB3',
                'amber-200': '#FFE082',
                'amber-300': '#FFD54F',
                'amber-400': '#FFCA28',
                'amber-50': '#FFF8E1',
                'amber-500': '#FFC107',
                'amber-600': '#FFB300',
                'amber-700': '#FFA000',
                'amber-800': '#FF8F00',
                'amber-900': '#FF6F00',
                'amber-a100': '#FFE57F',
                'amber-a200': '#FFD740',
                'amber-a400': '#FFC400',
                'amber-a700': '#FFAB00',
                'blue-100': '#BBDEFB',
                'blue-200': '#90CAF9',
                'blue-300': '#64B5F6',
                'blue-400': '#42A5F5',
                'blue-50': '#E3F2FD',
                'blue-a100': '#82B1FF',
                'blue-grey-100': '#CFD8DC',
                'blue-grey-200': '#B0BEC5',
                'blue-grey-300': '#90A4AE',
                'blue-grey-50': '#ECEFF1',
                'brown-100': '#D7CCC8',
                'brown-200': '#BCAAA4',
                'brown-50': '#EFEBE9',
                'cyan-100': '#B2EBF2',
                'cyan-200': '#80DEEA',
                'cyan-300': '#4DD0E1',
                'cyan-400': '#26C6DA',
                'cyan-50': '#E0F7FA',
                'cyan-a100': '#84FFFF',
                'cyan-a200': '#18FFFF',
                'cyan-a400': '#00E5FF',
                'cyan-a700': '#00B8D4',
                'deep-orange-100': '#FFCCBC',
                'deep-orange-200': '#FFAB91',
                'deep-orange-300': '#FF8A65',
                'deep-orange-400': '#FF7043',
                'deep-orange-50': '#FBE9E7',
                'deep-orange-a100': '#FF9E80',
                'deep-orange-a200': '#FF6E40',
                'deep-purple-100': '#D1C4E9',
                'deep-purple-200': '#B39DDB',
                'deep-purple-50': '#EDE7F6',
                'deep-purple-a100': '#B388FF',
                'green-100': '#C8E6C9',
                'green-200': '#A5D6A7',
                'green-300': '#81C784',
                'green-400': '#66BB6A',
                'green-50': '#E8F5E9',
                'green-a100': '#B9F6CA',
                'green-a200': '#69F0AE',
                'green-a400': '#00E676',
                'green-a700': '#00C853',
                'grey': '#9E9E9E',
                'grey-100': '#F5F5F5',
                'grey-200': '#EEEEEE',
                'grey-300': '#E0E0E0',
                'grey-400': '#BDBDBD',
                'grey-50': '#FAFAFA',
                'grey-500': '#9E9E9E',
                'indigo-100': '#C5CAE9',
                'indigo-200': '#9FA8DA',
                'indigo-50': '#E8EAF6',
                'indigo-a100': '#8C9EFF',
                'light-blue-100': '#B3E5FC',
                'light-blue-200': '#81D4FA',
                'light-blue-300': '#4FC3F7',
                'light-blue-400': '#29B6F6',
                'light-blue-50': '#E1F5FE',
                'light-blue-a100': '#80D8FF',
                'light-blue-a200': '#40C4FF',
                'light-blue-a400': '#00B0FF',
                'light-green': '#8BC34A',
                'light-green-100': '#DCEDC8',
                'light-green-200': '#C5E1A5',
                'light-green-300': '#AED581',
                'light-green-400': '#9CCC65',
                'light-green-50': '#F1F8E9',
                'light-green-500': '#8BC34A',
                'light-green-600': '#7CB342',
                'light-green-700': '#689F38',
                'light-green-a100': '#CCFF90',
                'light-green-a200': '#B2FF59',
                'light-green-a400': '#76FF03',
                'light-green-a700': '#64DD17',
                'lime': '#CDDC39',
                'lime-100': '#F0F4C3',
                'lime-200': '#E6EE9C',
                'lime-300': '#DCE775',
                'lime-400': '#D4E157',
                'lime-50': '#F9FBE7',
                'lime-500': '#CDDC39',
                'lime-600': '#C0CA33',
                'lime-700': '#AFB42B',
                'lime-800': '#9E9D24',
                'lime-a100': '#F4FF81',
                'lime-a200': '#EEFF41',
                'lime-a400': '#C6FF00',
                'lime-a700': '#AEEA00',
                'orange': '#FF9800',
                'orange-100': '#FFE0B2',
                'orange-200': '#FFCC80',
                'orange-300': '#FFB74D',
                'orange-400': '#FFA726',
                'orange-50': '#FFF3E0',
                'orange-500': '#FF9800',
                'orange-600': '#FB8C00',
                'orange-700': '#F57C00',
                'orange-a100': '#FFD180',
                'orange-a200': '#FFAB40',
                'orange-a400': '#FF9100',
                'orange-a700': '#FF6D00',
                'pink-100': '#F8BBD0',
                'pink-200': '#F48FB1',
                'pink-300': '#F06292',
                'pink-400': '#EC407A',
                'pink-50': '#FCE4EC',
                'pink-a100': '#FF80AB',
                'purple-100': '#E1BEE7',
                'purple-200': '#CE93D8',
                'purple-50': '#F3E5F5',
                'purple-a100': '#EA80FC',
                'red-100': '#FFCDD2',
                'red-200': '#EF9A9A',
                'red-300': '#E57373',
                'red-400': '#EF5350',
                'red-50': '#FFEBEE',
                'red-a100': '#FF8A80',
                'teal-100': '#B2DFDB',
                'teal-200': '#80CBC4',
                'teal-300': '#4DB6AC',
                'teal-400': '#26A69A',
                'teal-50': '#E0F2F1',
                'teal-a100': '#A7FFEB',
                'teal-a200': '#64FFDA',
                'teal-a400': '#1DE9B6',
                'teal-a700': '#00BFA5',
                'white': '#FFFFFF',
                'yellow': '#FFEB3B',
                'yellow-100': '#FFF9C4',
                'yellow-200': '#FFF59D',
                'yellow-300': '#FFF176',
                'yellow-400': '#FFEE58',
                'yellow-50': '#FFFDE7',
                'yellow-500': '#FFEB3B',
                'yellow-600': '#FDD835',
                'yellow-700': '#FBC02D',
                'yellow-800': '#F9A825',
                'yellow-900': '#F57F17',
                'yellow-a100': '#FFFF8D',
                'yellow-a200': '#FFFF00',
                'yellow-a400': '#FFEA00',
                'yellow-a700': '#FFD600'
            },
            dark: {
                'black': '#000000',
                'blue': '#2196F3',
                'blue-500': '#2196F3',
                'blue-600': '#1E88E5',
                'blue-700': '#1976D2',
                'blue-800': '#1565C0',
                'blue-900': '#0D47A1',
                'blue-a200': '#448AFF',
                'blue-a400': '#2979FF',
                'blue-a700': '#2962FF',
                'blue-grey': '#607D8B',
                'blue-grey-400': '#78909C',
                'blue-grey-500': '#607D8B',
                'blue-grey-600': '#546E7A',
                'blue-grey-700': '#455A64',
                'blue-grey-800': '#37474F',
                'blue-grey-900': '#263238',
                'brown': '#795548',
                'brown-300': '#A1887F',
                'brown-400': '#8D6E63',
                'brown-500': '#795548',
                'brown-600': '#6D4C41',
                'brown-700': '#5D4037',
                'brown-800': '#4E342E',
                'brown-900': '#3E2723',
                'cyan': '#00BCD4',
                'cyan-500': '#00BCD4',
                'cyan-600': '#00ACC1',
                'cyan-700': '#0097A7',
                'cyan-800': '#00838F',
                'cyan-900': '#006064',
                'deep-orange': '#FF5722',
                'deep-orange-500': '#FF5722',
                'deep-orange-600': '#F4511E',
                'deep-orange-700': '#E64A19',
                'deep-orange-800': '#D84315',
                'deep-orange-900': '#BF360C',
                'deep-orange-a400': '#FF3D00',
                'deep-orange-a700': '#DD2C00',
                'deep-purple': '#673AB7',
                'deep-purple-300': '#9575CD',
                'deep-purple-400': '#7E57C2',
                'deep-purple-500': '#673AB7',
                'deep-purple-600': '#5E35B1',
                'deep-purple-700': '#512DA8',
                'deep-purple-800': '#4527A0',
                'deep-purple-900': '#311B92',
                'deep-purple-a200': '#7C4DFF',
                'deep-purple-a400': '#651FFF',
                'deep-purple-a700': '#6200EA',
                'green': '#4CAF50',
                'green-500': '#4CAF50',
                'green-600': '#43A047',
                'green-700': '#388E3C',
                'green-800': '#2E7D32',
                'green-900': '#1B5E20',
                'grey-600': '#757575',
                'grey-700': '#616161',
                'grey-800': '#424242',
                'grey-900': '#212121',
                'indigo': '#3F51B5',
                'indigo-300': '#7986CB',
                'indigo-400': '#5C6BC0',
                'indigo-500': '#3F51B5',
                'indigo-600': '#3949AB',
                'indigo-700': '#303F9F',
                'indigo-800': '#283593',
                'indigo-900': '#1A237E',
                'indigo-a200': '#536DFE',
                'indigo-a400': '#3D5AFE',
                'indigo-a700': '#304FFE',
                'light-blue': '#03A9F4',
                'light-blue-500': '#03A9F4',
                'light-blue-600': '#039BE5',
                'light-blue-700': '#0288D1',
                'light-blue-800': '#0277BD',
                'light-blue-900': '#01579B',
                'light-blue-a700': '#0091EA',
                'light-green-800': '#558B2F',
                'light-green-900': '#33691E',
                'lime-900': '#827717',
                'orange-800': '#EF6C00',
                'orange-900': '#E65100',
                'pink': '#E91E63',
                'pink-500': '#E91E63',
                'pink-600': '#D81B60',
                'pink-700': '#C2185B',
                'pink-800': '#AD1457',
                'pink-900': '#880E4F',
                'pink-a200': '#FF4081',
                'pink-a400': '#F50057',
                'pink-a700': '#C51162',
                'purple': '#9C27B0',
                'purple-300': '#BA68C8',
                'purple-400': '#AB47BC',
                'purple-500': '#9C27B0',
                'purple-600': '#8E24AA',
                'purple-700': '#7B1FA2',
                'purple-800': '#6A1B9A',
                'purple-900': '#4A148C',
                'purple-a200': '#E040FB',
                'purple-a400': '#D500F9',
                'purple-a700': '#AA00FF',
                'red': '#F44336',
                'red-500': '#F44336',
                'red-600': '#E53935',
                'red-700': '#D32F2F',
                'red-800': '#C62828',
                'red-900': '#B71C1C',
                'red-a200': '#FF5252',
                'red-a400': '#FF1744',
                'red-a700': '#D50000',
                'teal': '#009688',
                'teal-500': '#009688',
                'teal-600': '#00897B',
                'teal-700': '#00796B',
                'teal-800': '#00695C',
                'teal-900': '#004D40'
            }
        }
    };
</script><style is="custom-style">
    :root {

        --mat-shadow-z1: {
            box-shadow: 0 1px 2px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 5px 0 hsla(0, 0%, 0%, 0.12),
                        0 3px 1px -2px hsla(0, 0%, 0%, 0.2);
        };

        --mat-shadow-z2: {
            box-shadow: 0 2px 2px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 5px 0 hsla(0, 0%, 0%, 0.12),
                        0 3px 1px -2px hsla(0, 0%, 0%, 0.2);
        };

        --mat-shadow-z3: {
            box-shadow: 0 3px 4px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 8px 0 hsla(0, 0%, 0%, 0.12),
                        0 3px 3px -2px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z4: {
            box-shadow: 0 4px  5px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 10px 0 hsla(0, 0%, 0%, 0.12),
                        0 2px  4px -1px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z5: {
            box-shadow: 0 5px  8px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 18px 0 hsla(0, 0%, 0%, 0.12),
                        0 2px  5px -1px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z6: {
            box-shadow: 0 6px 10px 0 hsla(0, 0%, 0%, 0.14),
                        0 1px 18px 0 hsla(0, 0%, 0%, 0.12),
                        0 3px  5px -1px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z7: {
            box-shadow: 0 7px 10px  1px hsla(0, 0%, 0%, 0.14),
                        0 2px 16px  2px hsla(0, 0%, 0%, 0.12),
                        0 4px  5px -3px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z8: {
            box-shadow: 0 8px 10px  1px hsla(0, 0%, 0%, 0.14),
                        0 3px 14px  2px hsla(0, 0%, 0%, 0.12),
                        0 5px  5px -3px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z9: {
            box-shadow: 0 9px 12px  1px hsla(0, 0%, 0%, 0.14),
                        0 3px 14px  2px hsla(0, 0%, 0%, 0.12),
                        0 5px  6px -3px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z10: {
            box-shadow: 0 10px 13px  1px hsla(0, 0%, 0%, 0.14),
                        0  3px 14px  2px hsla(0, 0%, 0%, 0.12),
                        0  6px  6px -3px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z11: {
            box-shadow: 0 11px 14px  1px hsla(0, 0%, 0%, 0.14),
                        0  4px 14px  3px hsla(0, 0%, 0%, 0.12),
                        0  6px  7px -4px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z12: {
            box-shadow: 0 12px 16px  1px hsla(0, 0%, 0%, 0.14),
                        0  4px 14px  3px hsla(0, 0%, 0%, 0.12),
                        0  6px  8px -4px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z13: {
            box-shadow: 0 13px 18px  1px hsla(0, 0%, 0%, 0.14),
                        0  4px 18px  3px hsla(0, 0%, 0%, 0.12),
                        0  7px  8px -4px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z14: {
            box-shadow: 0 14px 20px  1px hsla(0, 0%, 0%, 0.14),
                        0  5px 22px  4px hsla(0, 0%, 0%, 0.12),
                        0  7px  8px -4px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z15: {
            box-shadow: 0 15px 22px  1px hsla(0, 0%, 0%, 0.14),
                        0  5px 26px  4px hsla(0, 0%, 0%, 0.12),
                        0  7px  9px -5px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z16: {
            box-shadow: 0 16px 24px  2px hsla(0, 0%, 0%, 0.14),
                        0  5px 30px  5px hsla(0, 0%, 0%, 0.12),
                        0  8px 10px -5px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z17: {
            box-shadow: 0 17px 26px  3px hsla(0, 0%, 0%, 0.14),
                        0  5px 32px  5px hsla(0, 0%, 0%, 0.12),
                        0  8px 10px -5px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z18: {
            box-shadow: 0 18px 28px  3px hsla(0, 0%, 0%, 0.14),
                        0  6px 34px  6px hsla(0, 0%, 0%, 0.12),
                        0  8px 11px -5px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z19: {
            box-shadow: 0 19px 30px  3px hsla(0, 0%, 0%, 0.14),
                        0  6px 36px  6px hsla(0, 0%, 0%, 0.12),
                        0  9px 11px -6px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z20: {
            box-shadow: 0 20px 32px  3px hsla(0, 0%, 0%, 0.14),
                        0  6px 38px  7px hsla(0, 0%, 0%, 0.12),
                        0  9px 12px -6px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z21: {
            box-shadow: 0 21px 34px  4px hsla(0, 0%, 0%, 0.14),
                        0  7px 40px  7px hsla(0, 0%, 0%, 0.12),
                        0  9px 12px -6px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z22: {
            box-shadow: 0 22px 36px  4px hsla(0, 0%, 0%, 0.14),
                        0  7px 42px  8px hsla(0, 0%, 0%, 0.12),
                        0 10px 13px -6px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z23: {
            box-shadow: 0 23px 38px  4px hsla(0, 0%, 0%, 0.14),
                        0  7px 44px  8px hsla(0, 0%, 0%, 0.12),
                        0 10px 13px -7px hsla(0, 0%, 0%, 0.4);
        };

        --mat-shadow-z24: {
            box-shadow: 0 24px 40px  4px hsla(0, 0%, 0%, 0.14),
                        0  8px 46px  9px hsla(0, 0%, 0%, 0.12),
                        0 10px 10px -8px hsla(0, 0%, 0%, 0.4);
        };

    }
</style><style is="custom-style">
    :root {

        /* CAPTION */

        --mat-font-caption: {
            font-size: 12px;
            font-weight: 400;
            letter-spacing: 0.02em;
            line-height: 14px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

        /* BODY */

        --mat-font-body: {
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.01em;
            line-height: 20px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        --mat-font-body2: {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.01em;
            line-height: 24px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        /* MENU */

        --mat-font-menu: {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.01em;
            line-height: 20px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

        /* BUTTON */

        --mat-font-button: {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.01em;
            line-height: 20px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            text-transform: uppercase;
            white-space: nowrap;
        };

        /* SUBHEAD */

        --mat-font-subhead: {
            font-size: 16px;
            font-weight: 400;
            letter-spacing: 0.01em;
            line-height: 24px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        --mat-font-subhead2: {
            font-size: 16px;
            font-weight: 400;
            letter-spacing: 0.01em;
            line-height: 28px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        /* TITLE */

        --mat-font-title: {
            font-size: 20px;
            font-weight: 500;
            letter-spacing: 0.005em;
            line-height: 24px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

        /* HEADLINE */

        --mat-font-headline: {
            font-size: 24px;
            font-weight: 400;
            letter-spacing: 0;
            line-height: 32px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        /* DISPLAY */

        --mat-font-display: {
            font-size: 34px;
            font-weight: 400;
            letter-spacing: 0;
            line-height: 40px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        --mat-font-display2: {
            font-size: 45px;
            font-weight: 400;
            letter-spacing: 0;
            line-height: 48px;
            text-overflow: clip;
            text-rendering: optimizeLegibility;
            white-space: normal;
        };

        --mat-font-display3: {
            font-size: 56px;
            font-weight: 400;
            letter-spacing: -0.005em;
            line-height: 68px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

        --mat-font-display4: {
            font-size: 112px;
            font-weight: 300;
            letter-spacing: -0.01em;
            line-height: 134px;
            text-overflow: ellipsis;
            text-rendering: optimizeLegibility;
            white-space: nowrap;
        };

    }

    /* DEFAULT */

    html {
        background: hsla(0, 0%, 93%, 1);
        color: hsla(0, 0%, 0%, 0.87);
        font-family: RobotoDraft, Roboto, sans-serif;
        font-size: 16px;
        -webkit-font-smoothing: antialiased;
        font-weight: 400;
        letter-spacing: 0.01em;
        line-height: 24px;
        text-overflow: clip;
        text-rendering: optimizeLegibility;
        white-space: normal;
    }

    /* ANCHORS */

    html /deep/ a {
        color: inherit;
    }

    /* FONTS */

    html /deep/ [font-type="caption"] { @apply(--mat-font-caption); }
    html /deep/ [font-type="body"] { @apply(--mat-font-body); }
    html /deep/ [font-type="body2"] { @apply(--mat-font-body2); }
    html /deep/ [font-type="menu"] { @apply(--mat-font-menu); }
    html /deep/ [font-type="subhead"] { @apply(--mat-font-subhead); }
    html /deep/ [font-type="subhead2"] { @apply(--mat-font-subhead2); }
    html /deep/ [font-type="title"] { @apply(--mat-font-title); }
    html /deep/ [font-type="headline"] { @apply(--mat-font-headline); }
    html /deep/ [font-type="display"] { @apply(--mat-font-display); }
    html /deep/ [font-type="display2"] { @apply(--mat-font-display2); }
    html /deep/ [font-type="display3"] { @apply(--mat-font-display3); }
    html /deep/ [font-type="display4"] { @apply(--mat-font-display4); }

</style><script>
    Polymer.XPArrayBehavior = {

        /**
         * Adds a value at the end of an array, if it doesn't already exist,
         * and returns the passed element.
         *
         * @method append
         * @param {string} array The name of the array to modify.
         * @param {*} value The value to be added to the array.
         * @returns {*} Returns the appended `value`.
         */
        append: function (array, value) {
            XP.assertArgument(XP.isString(array, true), 1, 'string');
            XP.assertOption(XP.isArray(this[array]), array, 'Array');
            var self = this, includes = XP.includes(self[array], value);
            if (!includes) { self.push(array, value); }
            return value;
        },

        /**
         * Substitutes all items of `array` with ones from `other`, and returns the modified `array`.
         * The substitution happens only if necessary.
         *
         * @method overwrite
         * @param {string} array The name of the array to modify.
         * @param {Array} other The source array.
         * @returns {Array} Returns the modified `array`.
         */
        overwrite: function (array, other) {
            XP.assertArgument(XP.isString(array, true), 1, 'string');
            XP.assertArgument(XP.isArrayable(other), 2, 'Arrayable');
            XP.assertOption(XP.isArray(this[array]), array, 'Array');
            var self = this, differs = self[array].length !== other.length || XP.mapOne(self[array], function (val, i) { if (val !== other[i]) { return true; } });
            if (differs) { self.splice.apply(self, XP.concat([array, 0, self[array].length], other)); }
            return self[array];
        },

        /**
         * Removes all instances of `value` from `array`.
         *
         * @function pull
         * @param {string} array The name of the array to modify.
         * @param {*} [value] The value to remove.
         * @returns {Array} Returns `array`.
         */
        pull: function (array, value) {
            XP.assertArgument(XP.isString(array, true), 1, 'string');
            XP.assertOption(XP.isArray(this[array]), array, 'Array');
            var self = this;
            XP.forEachRight(self[array], function (val, i) { if (value === val) { self.splice(array, i, 1); } });
            return self[array];
        },

        /**
         * Removes an element from `array` corresponding to the given index and returns it.
         *
         * @function pullAt
         * @param {string} array The name of the array to modify.
         * @param {number} index The index of the element to remove
         * @returns {*} Returns the removed element.
         */
        pullAt: function (array, index) {
            XP.assertArgument(XP.isString(array, true), 1, 'string');
            XP.assertArgument(XP.isVoid(index) || XP.isIndex(index), 2, 'number');
            XP.assertOption(XP.isArray(this[array]), array, 'Array');
            return index < this[array].length ? this.splice(array, index, 1)[0] : undefined;
        }
    };
</script><script>
    Polymer({

        // ELEMENT
        is: 'xp-master-state',

        // EXTENDS
        extends: 'template',

        // BEHAVIORS
        behaviors: [
            Polymer.XPArrayBehavior
        ],

        /*********************************************************************/

        /**
         * Appends a slave.
         *
         * @method appendSlave
         * @param {Object} [properties]
         * @returns {Element}
         */
        appendSlave: function (properties) {
            XP.assertArgument(XP.isVoid(properties) || XP.isObject(properties), 1, 'Object');
            return XP.appendChild(Polymer.dom(this.domHost), this.slaveTag ? XP.createElement(this.slaveTag, {properties: properties}) : null);
        },

        /**
         * Removes a slave.
         *
         * @method removeSlave
         * @param {Element} [slave]
         * @returns {Element}
         */
        removeSlave: function (slave) {
            XP.assertArgument(XP.isVoid(slave) || XP.isElement(slave), 1, 'Element');
            return XP.removeChild(slave && Polymer.dom(Polymer.dom(slave).parentNode), XP.includes(this.slaves, slave) ? slave : null);
        },

        /*********************************************************************/

        /**
         * Couples the master to a slave.
         *
         * @method _couple
         * @param {Element} slave
         * @returns {Element}
         * @private
         */
        _couple: function (slave) {
            return this.append('slaves', slave);
        },

        /**
         * Decouples the master from a slave.
         *
         * @method _decouple
         * @param {Element} slave
         * @returns {Element}
         * @private
         */
        _decouple: function (slave) {
            var self = this, index = self.slaves.indexOf(slave);
            return index >= 0 ? self.pullAt('slaves', index) : null;
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * A selector used to recognize the slaves.
             *
             * @attribute slave-selector
             * @type string
             */
            slaveSelector: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The `tagName` of the slaves.
             *
             * @attribute slave-tag
             * @type string
             */
            slaveTag: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The master's slaves.
             *
             * @attribute slaves
             * @type Array
             * @notifies
             * @readonly
             */
            slaves: {
                notify: true,
                readOnly: true,
                type: Array,
                value: function () { return []; }
            }
        },

        /*********************************************************************/

        // LISTENER
        attached: function () {
            this.listen(this.domHost, 'xp-slave-state', '_handleSlave');
        },

        /*********************************************************************/

        // HANDLER
        _handleSlave: function (event) {

            // Vars
            var self = this;

            // Checking
            if (self.domHost === event.detail.firer) { return; }
            if (self.slaveTag && self.slaveTag !== event.detail.firer.tagName.toLowerCase()) { return; }
            if (self.slaveSelector && !XP.matches(event.detail.firer, self.slaveSelector)) { return; }
            if (event.detail.masterTag && event.detail.masterTag !== self.domHost.tagName.toLowerCase()) { return; }
            if (event.detail.masterSelector && !XP.matches(self.domHost, event.detail.masterSelector)) { return; }

            // Coupling (master side)
            self[event.detail.isAttached ? '_couple' : '_decouple'](event.detail.firer);

            // Coupling (slave side)
            event.detail.coupler(self.domHost);

            // Stopping
            event.stopPropagation();
        }
    });
</script><script>
    Polymer({

        // ELEMENT
        is: 'xp-slave-state',

        // EXTENDS
        extends: 'template',

        /*********************************************************************/

        /**
         * Fired when the slave is attached.
         *
         * @event xp-slave-state
         * @param {Element} firer
         * @param {Function} coupler
         * @param {string} masterSelector
         * @param {string} masterTag
         * @param {boolean} isAttached
         * @bubbles
         */

        /*********************************************************************/

        /**
         * Couples the slave to a master.
         *
         * @method _couple
         * @param {Element} master
         * @returns {Element}
         * @private
         */
        _couple: function (master) {
            var self = this;
            if (!self.master) { self._setMaster(master); }
            return master === self.master ? master : null;
        },

        /**
         * Decouples the slave from its master.
         *
         * @method _decouple
         * @param {Element} master
         * @returns {Element}
         * @private
         */
        _decouple: function (master) {
            var self = this;
            if (self.master === master) { self._setMaster(null); }
            return !self.master ? master : null;
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * The slave's master.
             *
             * @attribute master
             * @type Element
             * @notifies
             * @readonly
             */
            master: {
                notify: true,
                readOnly: true,
                value: null
            },

            /**
             * A selector used to recognize the master.
             *
             * @attribute master-selector
             * @type string
             */
            masterSelector: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The `tagName` of the master.
             *
             * @attribute master-tag
             * @type string
             */
            masterTag: {
                reflectToAttribute: true,
                type: String,
                value: null
            }
        },

        /*********************************************************************/

        // LISTENER
        attached: function () {
            var self = this;
            XP.delay(function () { self.fire('xp-slave-state', {firer: self.domHost, coupler: self._couple.bind(self), masterSelector: self.masterSelector, masterTag: self.masterTag, isAttached: true}); });
        },

        // LISTENER
        detached: function () {
            var self = this;
            if (!self.master) { return; }
            XP.delay(function () { self.master.fire('xp-slave-state', {firer: self.domHost, coupler: self._decouple.bind(self), masterSelector: self.masterSelector, masterTag: self.masterTag, isAttached: false}); });
        }
    });
</script><script>
    Polymer.XPTargeterBehavior = {

        /**
         * Finds the targeted element.
         *
         * @method findTarget
         * @returns {Element}
         */
        findTarget: function () {

            // Vars
            var self = this;

            // Finding
            if (XP.isElement(self.target)) { return self.target; }
            if (XP.isString(self.target, true)) { return XP.getElementById(self.target) || null; }

            return null;
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * The element's target.
             *
             * @attribute target
             * @type Element | string
             * @notifies
             */
            target: {
                notify: true,
                value: null
            }
        }
    };
</script><script>
    Polymer.XPOverlayBehaviorImp = {

        /**
         * Fired when the showed state changes.
         *
         * @event xp-toggle
         * @param {Element} firer
         * @param {boolean} isShowed
         * @bubbles
         */

        /*********************************************************************/

        /**
         * Hides the overlay.
         *
         * @method hide
         * @returns {Element}
         */
        hide: function () {
            var self = this;
            self.showed = false;
            return self;
        },

        /**
         * Shows the overlay.
         *
         * @method show
         * @param {Element | string} target
         * @param {*} [data]
         * @returns {Element}
         */
        show: function (target, data) {

            // Asserting
            XP.assertArgument(XP.isVoid(target) || XP.isElement(target) || XP.isString(target), 1, 'Element or string');

            // Vars
            var self = this;

            // Setting
            self.target = target || self.target;
            self.data   = data || (self.findTarget() || {}).data || null;
            self.showed = true;

            return self;
        },

        /**
         * Toggles the overlay.
         *
         * @method toggle
         * @param {Element | string} target
         * @param {*} [data]
         * @returns {Element}
         */
        toggle: function (target, data) {
            return this[this.showed ? 'hide' : 'show'](target, data);
        },

        /*********************************************************************/

        // PROPERTIES
        properties: {

            /**
             * If set to true, the overlay will not close by clicking outside.
             *
             * @attribute auto-hide-disabled
             * @type boolean
             * @default false
             */
            autoHideDisabled: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The element's data.
             *
             * @attribute data
             * @type *
             * @notifies
             */
            data: {
                notify: true,
                value: null
            },

            /**
             * If set to true, the overlay is showed.
             *
             * @attribute showed
             * @type boolean
             * @default false
             * @notifies
             */
            showed: {
                notify: true,
                observer: '_showedChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            }
        },

        /*********************************************************************/

        // OBSERVER
        _showedChanged: function (post) {

            // Vars
            var self = this;

            // Firing
            self.fire('xp-toggle', {firer: self, isShowed: post});

            // Listening
            XP.delay(function () {
                self[post ? 'listen' : 'unlisten'](window, 'keyup', '_hideHandler');
                self[post ? 'listen' : 'unlisten'](window, 'click', '_hideHandler');
                self[post ? 'listen' : 'unlisten'](self, 'click', '_distinguishHandler');
            });
        },

        /*********************************************************************/

        // HANDLER
        _distinguishHandler: function (event) {
            (event.overlays = event.overlays || []).push(this);
        },

        // HANDLER
        _hideHandler: function (event) {

            // Vars
            var self = this;

            // Checking
            if (event.overlays && XP.includes(event.overlays, self)) { return; }
            if ((self.autoHideDisabled || event.keyCode) && event.keyCode !== 27) { return; }

            // Unlistening
            self.unlisten(window, 'keyup', '_hideHandler');
            self.unlisten(window, 'click', '_hideHandler');
            self.unlisten(self, 'click', '_distinguishHandler');

            // Hiding
            self.hide();
        }
    };

    Polymer.XPOverlayBehavior = [
        Polymer.XPTargeterBehavior,
        Polymer.XPOverlayBehaviorImp
    ];
</script><script>
    Polymer.XPAnchorBehavior = {

        /**
         * Refreshes the anchor.
         *
         * @method _updateAnchor
         * @returns {Element}
         * @private
         */
        _updateAnchor: function () {

            // Vars
            var self = this;

            // Setting
            XP.setAttribute(self.anchor, 'download', (self.href && self.download) || null);
            XP.setAttribute(self.anchor, 'href', self.href || null);
            XP.setAttribute(self.anchor, 'rel', (self.href && self.rel) || null);
            XP.setAttribute(self.anchor, 'target', (self.href && self.target) || null);

            return self;
        },

        /*********************************************************************/

        // OBSERVERS
        observers: [
            '_updateAnchor(anchor, download, href, rel, target)'
        ],

        // PROPERTIES
        properties: {

            /**
             * The element's anchor.
             *
             * @attribute anchor
             * @type Element
             * @notifies
             * @readonly
             */
            anchor: {
                notify: true,
                readOnly: true,
                value: null
            },

            /**
             * The anchor's download property's value.
             *
             * @attribute download
             * @type string
             */
            download: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The anchor's href property's value.
             *
             * @attribute href
             * @type string
             */
            href: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The anchor's rel property's value.
             *
             * @attribute rel
             * @type string
             */
            rel: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The anchor's target property's value.
             *
             * @attribute target
             * @type string
             * @notifies
             */
            target: {
                notify: true,
                value: null
            }
        }
    };
</script><script>
    Polymer.XPFocusedBehavior = {

        // LISTENERS
        listeners: {
            blur: '_blurHandler',
            focus: '_focusHandler'
        },

        // PROPERTIES
        properties: {

            /**
             * If set to true, the element is disabled.
             *
             * @attribute disabled
             * @type boolean
             * @default false
             */
            disabled: {
                observer: '_disabledChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the element is focused.
             *
             * @attribute focused
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            focused: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            }
        },

        /**
         * The last value of tabIndex.
         *
         * @property lastTabIndex
         * @type number
         * @default 0
         * @readonly
         */
        lastTabIndex: 0,

        /*********************************************************************/

        // OBSERVER
        _disabledChanged: function (post) {

            // Vars
            var self = this;

            // Setting
            self.focused  = self.focused && !post;
            self.tabIndex = post ? -1 : self.lastTabIndex;

            // Styling
            self.style.pointerEvents = post ? 'none' : '';
        },

        /*********************************************************************/

        // LISTENER
        mutated: function () {

            // Vars
            var self = this;

            // Setting
            self.lastTabIndex = self.tabIndex >= 0 ? self.tabIndex : self.lastTabIndex;
            self.tabIndex     = self.disabled ? -1 : Math.max(self.tabIndex, 0);

            // Observing
            XP.onMutation(self, Polymer.XPFocusedBehavior.mutated.bind(self), {attributes: true, attributeFilter: ['tabindex']});
        },

        // LISTENER
        ready: function () {

            // Mutating
            Polymer.XPFocusedBehavior.mutated.apply(this);
        },

        /*********************************************************************/

        // HANDLER
        _blurHandler: function () {
            this._setFocused(false);
        },

        // HANDLER
        _focusHandler: function () {
            this._setFocused(!this.disabled);
        }
    };
</script><script>
    Polymer.XPPressedBehaviorImp = {

        /**
         * Fired when the active state changes.
         *
         * @event xp-active
         * @param {Element} firer
         * @param {boolean} isActive
         * @bubbles
         */

        /**
         * Fired when the context element is clicked.
         *
         * @event xp-activate
         * @param {Element} firer
         * @param {Element} target
         * @param {boolean} isActive
         * @bubbles
         * @cancelable
         */

        /*********************************************************************/

        /**
         * Presses the context element.
         *
         * @method press
         * @returns {Element}
         */
        press: function () {

            // Vars
            var self   = this,
                target = self.findTarget();

            // Firing
            if (self.fire('xp-activate', {firer: self, target: target, isActive: self.active}, {cancelable: true}).defaultPrevented) { return self; }

            // Setting
            if (self.toggleable) { self.active = !self.active; }

            return self;
        },

        /*********************************************************************/

        // LISTENERS
        listeners: {
            click: '_clickHandler',
            down: '_touchHandler',
            up: '_touchHandler'
        },

        // PROPERTIES
        properties: {

            /**
             * If set to true, the element is active.
             *
             * @attribute active
             * @type boolean
             * @default false
             * @notifies
             */
            active: {
                notify: true,
                observer: '_activeChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the element is pressed.
             *
             * @attribute pressed
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            pressed: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, pressing will toggle active state on the context element.
             *
             * @attribute toggleable
             * @type boolean
             * @default false
             */
            toggleable: {
                observer: '_toggleableChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            }
        },

        /*********************************************************************/

        // OBSERVER
        _activeChanged: function (post) {
            this.fire('xp-active', {firer: this, isActive: post});
        },

        // OBSERVER
        _toggleableChanged: function (post) {
            this.active = this.active && post;
        },

        /*********************************************************************/

        // HANDLER
        _clickHandler: function (event) {
            var self = this;
            if (self.disabled) { XP.stop(event); return; }
            if (!event.button) { self.press(); }
        },

        // HANDLER
        _touchHandler: function (event) {
            this._setPressed(event.type === 'down');
        }
    };

    Polymer.XPPressedBehavior = [
        Polymer.XPFocusedBehavior,
        Polymer.XPTargeterBehavior,
        Polymer.XPPressedBehaviorImp
    ];
</script><script>
    Polymer.XPReferralBehavior = {

        // PROPERTIES
        properties: {

            /**
             * The element itself.
             *
             * @attribute self
             * @type Element
             * @readonly
             */
            self: {
                readOnly: true,
                value: function () { return this; }
            }
        }
    };
</script><script>
    Polymer.XPInputBehavior = {

        /**
         * Fired when the input's model changes.
         *
         * @event xp-input-change
         * @param {Element} firer
         * @param {boolean} isChanged
         * @param {*} model
         * @bubbles
         */

        /*********************************************************************/

        /**
         * Blurs the input.
         *
         * @method focus
         * @abstract
         */
        blur: XP.mock(),

        /**
         * Focuses the input.
         *
         * @method focus
         * @abstract
         */
        focus: XP.mock(),

        /**
         * Selects the input.
         *
         * @method select
         * @abstract
         */
        select: XP.mock(),

        /*********************************************************************/

        /**
         * The operation used to reflect input's element's `value` onto input.
         *
         * @method _commitFrom
         * @abstract
         * @private
         */
        _commitFrom: XP.mock(),

        /**
         * The operation used to reflect input's `value` onto input's element.
         *
         * @method _commitTo
         * @abstract
         * @private
         */
        _commitTo: XP.mock(),

        /**
         * The operation used to reflect input's `tabIndex` onto input's element.
         *
         * @method _index
         * @abstract
         * @private
         */
        _index: XP.mock(),

        /**
         * The operation used to inject the input element.
         *
         * @method _inject
         * @abstract
         * @private
         */
        _inject: XP.mock(),

        /**
         * The operation used to sanitize input's `value`.
         *
         * @method _sanitize
         * @abstract
         * @private
         */
        _sanitize: XP.mock(),

        /**
         * The operation used to update input's element's attributes.
         *
         * @method _update
         * @abstract
         * @private
         */
        _update: XP.mock(),

        /**
         * The operation used to validate input's `value`.
         *
         * @method _validate
         * @abstract
         * @private
         */
        _validate: XP.mock(),

        /*********************************************************************/

        /**
         * Finds the label.
         *
         * @method findLabel
         * @returns {Element}
         */
        findLabel: function () {
            var self = this, label = (self.id && XP.getElement('label[for="' + self.id + '"]'));
            return label || XP.findParentElement(Polymer.dom(self), 'label') || null;
        },

        /**
         * Resets the input.
         *
         * @method reset
         * @returns {Element}
         */
        reset: function () {
            return XP.assign(this, this.initial);
        },

        /**
         * Toggles the checked state.
         *
         * @method toggle
         * @returns {Element}
         */
        toggle: function () {
            var self = this;
            if (self.primitive === 'boolean' && !self.disabled) { self.checked = !self.checked; }
            return self;
        },

        /*********************************************************************/

        /**
         * Refreshes the element.
         *
         * @method _refresh
         * @returns {Element}
         * @private
         */
        _refresh: function () {

            // Vars
            var self = this;

            // Checking
            if (!self.injected) { return self; }

            // Updating
            self._update();

            // Sanitizing
            self._sanitize();

            // Validating
            if (self.value || !self.required) { self._validate(); }

            return self;
        },

        /**
         * Returns model representation of input's plain value.
         *
         * @method _toModel
         * @param {*} value
         * @returns {boolean | number | string}
         * @private
         */
        _toModel: function (value) {
            var self = this, from = XP.isPrimitive(value) ? value : null;
            if (self.primitive === 'boolean') { return XP.toBoolean(from); }
            if (self.primitive === 'number') { return XP.toNumber(from); }
            return XP.toString(from);
        },

        /**
         * Returns primitive representation of input's type
         *
         * @method _toPrimitive
         * @param {string} type
         * @returns {string}
         * @private
         */
        _toPrimitive: function (type) {
            if (type === 'checkbox') { return 'boolean'; }
            if (type === 'number') { return 'number'; }
            return 'string';
        },

        /**
         * Returns plain value representation of input's model.
         *
         * @method _toValue
         * @param {*} model
         * @returns {boolean | string}
         * @private
         */
        _toValue: function (model) {
            var self = this, from = XP.isPrimitive(model) ? model : null;
            if (self.primitive === 'boolean') { return XP.toBoolean(from, true); }
            return XP.toString(from, true);
        },

        /*********************************************************************/

        // LISTENERS
        listeners: {
            click: '_clickHandler'
        },

        // OBSERVERS
        observers: [
            '_refresh(disabled, injected, name, readonly, required)'
        ],

        // PROPERTIES
        properties: {

            /**
             * If set to true, the input will focus on attach.
             *
             * @attribute auto-focus
             * @type boolean
             * @default false
             */
            autoFocus: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the input's model is changed.
             *
             * @attribute changed
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            changed: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The input's character counter.
             *
             * @attribute chars
             * @type number
             * @default 0
             * @notifies
             * @readonly
             */
            chars: {
                notify: true,
                readOnly: true,
                type: Number,
                value: 0
            },

            /**
             * If set to true, the input is checked.
             *
             * @attribute checked
             * @type boolean
             * @notifies
             */
            checked: {
                notify: true,
                observer: '_checkedChanged',
                reflectToAttribute: true,
                type: Boolean
            },

            /**
             * If set to true, the input is disabled.
             *
             * @attribute disabled
             * @type boolean
             * @default false
             */
            disabled: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the input is empty.
             *
             * @attribute empty
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            empty: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the label is hidden.
             *
             * @attribute empty-label
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            emptyLabel: {
                computed: '_computeEmptyLabel(label)',
                notify: true,
                reflectToAttribute: true,
                type: Boolean
            },

            /**
             * The input's custom error message, used instead of `invalidMessage`.
             *
             * @attribute error
             * @type string
             */
            error: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * If set to true, the input is focused.
             *
             * @attribute focused
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            focused: {
                notify: true,
                observer: '_focusedChanged',
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The input's form.
             *
             * @attribute form
             * @type Element
             * @readonly
             */
            form: {
                observer: '_formChanged',
                readOnly: true,
                value: null
            },

            /**
             * The initial state.
             *
             * @attribute initial
             * @type Object
             * @readonly
             */
            initial: {
                readOnly: true,
                value: function () { return {}; }
            },

            /**
             * The appended input's element.
             *
             * @attribute injected
             * @type Element
             * @readonly
             */
            injected: {
                observer: '_injectedChanged',
                readOnly: true,
                value: null
            },

            /**
             * If set to true, the input's value is not valid.
             *
             * @attribute invalid
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            invalid: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The input's system error message.
             *
             * @attribute invalid-message
             * @type string
             * @notifies
             * @readonly
             */
            invalidMessage: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The input's label.
             *
             * @attribute label
             * @type string
             */
            label: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The input's model.
             *
             * @attribute model
             * @type *
             * @notifies
             */
            model: {
                notify: true,
                observer: '_modelChanged'
            },

            /**
             * The input's name.
             *
             * @attribute name
             * @type string
             */
            name: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * The input's primitive type.
             *
             * @attribute primitive
             * @type "boolean" | "number" | "string"
             * @default "string"
             * @readonly
             */
            primitive: {
                readOnly: true,
                type: String,
                value: 'string'
            },

            /**
             * If set to true, the input is readonly.
             *
             * @attribute readonly
             * @type boolean
             * @default false
             */
            readonly: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the input is required.
             *
             * @attribute required
             * @type boolean
             * @default false
             */
            required: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The input's type.
             *
             * @attribute type
             * @type string
             * @default "text"
             */
            type: {
                observer: '_typeChanged',
                reflectToAttribute: true,
                type: String,
                value: 'text'
            },

            /**
             * The input's plain value.
             *
             * @attribute value
             * @type string
             * @notify
             */
            value: {
                notify: true,
                observer: '_valueChanged',
                type: String
            }
        },

        /**
         * The list of primitives.
         *
         * @property primitives
         * @type Array
         * @default ["boolean", "number", "string"]
         * @readonly
         */
        primitives: ['boolean', 'number', 'string'],

        /*********************************************************************/

        // COMPUTER
        _computeEmptyLabel: function (label) {
            return !label;
        },

        /*********************************************************************/

        // OBSERVER
        _checkedChanged: function (post) {

            // Vars
            var self = this;

            // Checking
            if (!self.injected) { return; }

            // Setting
            self._setChanged(self.initial.checked !== post);
            self.model = self.changed ? self._toModel(post) : self.initial.model;

            // Committing
            self._commitTo();

            // Firing
            self.fire('xp-input-change', {firer: self, isChanged: self.changed, model: self.model});
        },

        // OBSERVER
        _focusedChanged: function (post) {

            // Vars
            var self = this;

            // Propagating
            XP.setAttribute(self.findLabel(), 'focused', post);

            // Validating
            if (self.injected && !post) { self._validate(); }
        },

        // OBSERVER
        _formChanged: function (post, pre) {

            // Vars
            var self = this;

            // Checking
            if (arguments.length < 2) { return; }

            // Listening
            if (pre) { self.unlisten(pre, 'reset', '_changeHandler'); }
            if (post) { self.listen(post, 'reset', '_changeHandler'); }

            // Refreshing
            self._refresh();
        },

        // OBSERVER
        _injectedChanged: function (post, pre) {

            // Vars
            var self = this;

            // Checking
            if (arguments.length < 2) { return; }

            // Listening
            if (XP.isElement(pre)) { self.unlisten(pre, 'blur', '_blurHandler'); self.unlisten(pre, 'change', '_changeHandler'); self.unlisten(pre, 'focus', '_focusHandler'); }
            if (XP.isElement(post)) { self.listen(post, 'blur', '_blurHandler'); self.listen(post, 'change', '_changeHandler'); self.listen(post, 'focus', '_focusHandler'); }

            // Mutating
            Polymer.XPInputBehavior.mutated.apply(self);

            // Refreshing
            self._refresh();
        },

        // OBSERVER
        _modelChanged: function () {

            // Casting
            this[this.primitive === 'boolean' ? 'checked' : 'value'] = this._toValue(this.model);
        },

        // OBSERVER
        _typeChanged: function (post) {

            // Vars
            var self = this;

            // Setting
            self._setPrimitive(self._toPrimitive(post));

            // Refreshing
            self._refresh();
        },

        // OBSERVER
        _valueChanged: function (post) {

            // Vars
            var self = this;

            // Checking
            if (!self.injected) { return; }

            // Sanitizing
            self._sanitize();

            // Checking
            if (self.value !== post) { return; }

            // Setting
            self._setChanged(self.initial.value !== post);
            self._setEmpty(!self.value);
            self.model = self.changed ? self._toModel(post) : self.initial.model;

            // Committing
            self._commitTo();

            // Validating
            self._validate();

            // Firing
            self.fire('xp-input-change', {firer: self, isChanged: self.changed, model: self.model});
        },

        /*********************************************************************/

        // LISTENER
        attached: function () {

            // Vars
            var self = this;

            // Setting
            self._setForm(XP.findParentElement(Polymer.dom(self), 'form'));
            self._setInvalid(false);

            // Focusing
            if (self.autoFocus) { XP.delay(function () { self.focus(); }); }
        },

        // LISTENER
        detached: function () {

            // Vars
            var self = this;

            // Setting
            self._setForm(null);
        },

        // LISTENER
        mutated: function () {

            // Vars
            var self = this;

            // Disconnecting
            if (self.indexObserver) { self.indexObserver.disconnect(); }

            // Indexing
            self.async(function () { self._index(Math.max(self.tabIndex, 0)); });

            // Setting
            self.removeAttribute(self.injected ? 'tabindex' : '');

            // Observing
            self.indexObserver = XP.onMutation(self, Polymer.XPInputBehavior.mutated.bind(self), {attributes: true, attributeFilter: ['tabindex']});
        },

        // LISTENER
        ready: function () {

            // Vars
            var self = this;

            // Setting
            self.set('initial.checked', self.checked = self.model && self.primitive === 'boolean' ? true : self.checked || false);
            self.set('initial.value', self.value = self.model && self.primitive !== 'boolean' ? self._toValue(self.model) : self.value || '');
            self.set('initial.model', self.model = self.checked || (self.value ? self._toModel(self.value) : self.model || null));
            self._setEmpty(self.primitive !== 'boolean' && !self.value);

            // Injecting
            self._inject();

            // Committing
            self._commitTo();
        },

        /*********************************************************************/

        // HANDLER
        _blurHandler: function () {
            this._setFocused(false);
        },

        // HANDLER
        _changeHandler: function () {
            this._commitFrom();
        },

        // HANDLER
        _clickHandler: function () {
            this.focus();
        },

        // HANDLER
        _focusHandler: function () {
            this._setFocused(!this.disabled);
        }
    };
</script><style>
    html [inset] mat-item:not([inset]) #matItemText {
        padding-left: 72px;
    }
</style>

<style>
    html [cascade] mat-option {
        height: 32px;
    }

    html [cascade] mat-option #matOptionMain {
        padding: 0 24px;
    }

    html [cascade] mat-option #matOptionIcon {
        margin-right: 16px;
    }
</style>

<script>
    Polymer.XPSelectedBehaviorImp = {

        /**
         * Fired on item selection.
         *
         * @event xp-select
         * @param {Element} firer
         * @param {Element} item
         * @param {number} index
         * @param {boolean} isMulti
         * @param {boolean} isSelected
         * @param {boolean} isSwitchable
         * @bubbles
         * @cancelable
         */

        /**
         * Fired when the selection changes.
         *
         * @event xp-selection
         * @param {Element} firer
         * @param {Array | Element} selection
         * @param {Array | Element} selected
         * @param {boolean} isMulti
         * @param {boolean} isSwitchable
         * @bubbles
         */

        /*********************************************************************/

        /**
         * Finds an item's index.
         *
         * @method findIndex
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {number | string}
         */
        findIndex: function (identity, safe) {
            var self = this, item = self.findItem(identity, safe);
            if (item && self.indexAttribute) { return XP.getAttribute(item, self.indexAttribute) || null; }
            if (item) { return XP.indexOf(self.items || [], item); }
            return null;
        },

        /**
         * Finds an item.
         *
         * @method findItem
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        findItem: function (identity, safe) {
            return safe ? identity : XP.find(this.items || [], this._toDOMIdentity(identity)) || null;
        },

        /**
         * Finds items filtered by predicate.
         *
         * @method findItems
         * @param {Function} [predicate]
         * @returns {Array}
         */
        findItems: function (predicate) {
            return XP.filter(this.items || [], this._toDOMPredicate(predicate));
        },

        /**
         * Finds an item's index, iterating from right to left.
         *
         * @method findLastIndex
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {number | string}
         */
        findLastIndex: function (identity, safe) {
            var self = this, item = self.findLastItem(identity, safe);
            if (item && self.indexAttribute) { return XP.getAttribute(item, self.indexAttribute) || null; }
            if (item) { return XP.indexOf(self.items || [], item) || null; }
            return null;
        },

        /**
         * Finds an item, iterating from right to left.
         *
         * @method findLastItem
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        findLastItem: function (identity, safe) {
            return safe ? identity : XP.findLast(this.items || [], this._toDOMIdentity(identity)) || null;
        },

        /**
         * Checks if an item is selectable.
         *
         * @method isSelectable
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {boolean}
         */
        isSelectable: function (identity, safe) {
            var self = this, item = self.findItem(identity, safe);
            return XP.isElement(item) && !self.isSelected(item);
        },

        /**
         * Checks if an item is selected.
         *
         * @method isSelected
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {boolean}
         */
        isSelected: function (identity, safe) {
            var self = this, item = self.findItem(identity, safe);
            return self.multi ? XP.includes(self.selection, item) : self.selection === item;
        },

        /**
         * Checks if an item is unselectable.
         *
         * @method isUnselectable
         * @param {Element | Function | number | string} identity
         * @param {boolean} [force = false]
         * @param {boolean} [safe = false]
         * @returns {boolean}
         */
        isUnselectable: function (identity, force, safe) {
            var self = this, item = self.findItem(identity, safe);
            return XP.isElement(item) && self.isSelected(item) && (force || self.multi || self.switchable);
        },

        /**
         * Resets the selection.
         *
         * @method reset
         * @returns {Element}
         */
        reset: function () {
            var self = this;
            self._setSelection(self.multi ? [] : null);
            return self;
        },

        /**
         * Selects an item.
         *
         * @method select
         * @param {Element | Function | number | string} identity
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        select: function (identity, safe) {

            // Vars
            var self  = this,
                item  = self.findItem(identity, safe),
                index = self.findIndex(item, true);

            // Checking
            if (!item || !self.isSelectable(item)) { return null; }

            // Firing
            if (self.fire('xp-select', {firer: self, item: item, index: index, isMulti: self.multi, isSelected: true, isSwitchable: self.multi || self.switchable}, {cancelable: true}).defaultPrevented) { return null; }

            // Selecting
            if (!self.multi) { self.unselect(self.selection, true); }
            if (!self.multi) { self._setSelection(item); } else { self.append('selection', item); }
            if (!self.multi) { self.selected = index; } else { self.append('selected', index); }

            // Setting
            self._setSelecting(true);

            return item;
        },

        /**
         * Selects all items.
         *
         * @method selectAll
         * @param {Function} [predicate]
         * @returns {Array}
         */
        selectAll: function (predicate) {
            var self = this, items = self.multi ? self.findItems(predicate) : [];
            return XP.map(items, function (item) { return self.select(item, true); });
        },

        /**
         * Selects the next item.
         *
         * @method selectNext
         * @returns {Element}
         */
        selectNext: function () {
            var self = this, item = !self.multi ? XP.getNext(self.items || [], self.selection) : null;
            return item ? self.select(item, true) : null;
        },

        /**
         * Selects the previous item.
         *
         * @method selectPrevious
         * @returns {Element}
         */
        selectPrevious: function () {
            var self = this, item = !self.multi ? XP.getPrevious(self.items || [], self.selection) : null;
            return item ? self.select(item, true) : null;
        },

        /**
         * Toggles active state on an item.
         *
         * @method switch
         * @param {Element | Function | number | string} identity
         * @param {boolean} [force = false]
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        switch: function (identity, force, safe) {
            var self = this, item = self.findItem(identity, safe);
            if (item && self.isSelected(item)) { return self.unselect(item, force, true); }
            if (item) { return self.select(item, true); }
            return null;
        },

        /**
         * Toggles active state on all items.
         *
         * @method switchAll
         * @param {Function} [predicate]
         * @param {boolean} [force = false]
         * @returns {Array}
         */
        switchAll: function (predicate, force) {
            var self = this, items = self.multi ? self.findItems(predicate) : [];
            return XP.map(items, function (item) { return self.switch(item, force, true); });
        },

        /**
         * Unselects an item.
         *
         * @method unselect
         * @param {Element | Function | number | string} identity
         * @param {boolean} [force = false]
         * @param {boolean} [safe = false]
         * @returns {Element}
         */
        unselect: function (identity, force, safe) {

            // Vars
            var self  = this,
                item  = self.findItem(identity, safe),
                index = self.findIndex(item, true);

            // Checking
            if (!item || !self.isUnselectable(item, force)) { return null; }

            // Firing
            if (self.fire('xp-select', {firer: self, item: item, index: index, isMulti: self.multi, isSelected: false, isSwitchable: self.multi || self.switchable}, {cancelable: true}).defaultPrevented && !force) { return null; }

            // Unselecting
            if (!self.multi) { self._setSelection(null); } else { self.pull('selection', item); }
            if (!self.multi) { self.selected = null; } else { self.pull('selected', index); }

            // Setting
            self._setSelecting(true);

            return item;
        },

        /**
         * Unselects all items.
         *
         * @method unselectAll
         * @param {Function} [predicate]
         * @param {boolean} [force = false]
         * @returns {Array}
         */
        unselectAll: function (predicate, force) {
            var self = this, items = self.multi ? self.findItems(predicate) : [];
            return XP.map(items, function (item) { return self.unselect(item, force, true); });
        },

        /*********************************************************************/

        /**
         * Refreshes the element.
         *
         * @method _refresh
         * @returns {Element}
         * @private
         */
        _refresh: function () {

            // Vars
            var self     = this,
                selected = self.selected;

            // Checking
            if (self.multi !== XP.isArray(self.selected)) { return self; }

            // CASE: Selection changed
            if (self.selecting) { self._setSelecting(false); return self; }

            // CASE: Selected changed
            if (!self.mutating) { self._setSelection(self.multi ? self.overwrite('selection', XP.map(self.selected, function (identity) { return self.findItem(identity); })) : (XP.isInput(self.selected, true) && self.findItem(self.selected)) || null); return self; }

            // CASE: Items changed
            self._setSelection(self.multi ? self.overwrite('selection', XP.intersection(self.items || [], self.selection)) : self.findItem(self.selection));
            self.selected = self.multi ? self.overwrite(self.selected, XP.map(function (item) { return self.findIndex(item, true); })) : (self.selection ? self.findIndex(self.selection, true) : null);
            self._setSelecting(self.selected !== selected && XP.isNullable(self.selected) !== XP.isNullable(selected));
            self._setMutating(false);

            return self;
        },

        /**
         * Returns a DOM identity representation of `target`.
         *
         * @method _toDOMIdentity
         * @param {Element | Function | number | string} target
         * @returns {Function | number}
         * @private
         */
        _toDOMIdentity: function (target) {

            // Vars
            var self      = this,
                attribute = self.indexAttribute,
                index     = !attribute ? XP.toNumber(target) : null;

            // Casting
            if (XP.isIndex(index)) { return index; }
            if (XP.isString(target) && XP.isString(attribute, true)) { return function (element) { return XP.isElement(element) && target === element.getAttribute(attribute); }; }
            if (XP.isElement(target) || XP.isFunction(target) || XP.isNullable(target)) { return XP.toDOMIdentity(target); }

            // Asserting
            throw new XP.ArgumentError(1, 'Element, Function, number or string');
        },

        /**
         * Returns a DOM predicate representation of `target`.
         *
         * @method _toDOMPredicate
         * @param {Function} [target]
         * @returns {Function}
         * @private
         */
        _toDOMPredicate: function (target) {

            // Casting
            if (XP.isVoid(target) || XP.isFunction(target)) { return XP.toDOMPredicate(target); }

            // Asserting
            throw new XP.ArgumentError(1, 'Function');
        },

        /*********************************************************************/

        // LISTENERS
        listeners: {
            'items-changed': '_itemsHandler',
            'selected-changed': '_selectedHandler',
            'selection-changed': '_selectionHandler'
        },

        // PROPERTIES
        properties: {

            /**
             * The context element.
             *
             * @attribute context
             * @type Element
             */
            context: {
                value: null
            },

            /**
             * If set to true, the selectable items are searched deep.
             *
             * @attribute deep
             * @type boolean
             * @default false
             */
            deep: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The index of the item to select by default.
             *
             * @attribute default-selected
             * @type number | string
             */
            defaultSelected: {
                value: null
            },

            /**
             * If set to true, there are no items.
             *
             * @attribute empty-items
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            emptyItems: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * The attribute used as index.
             *
             * @attribute index-attribute
             * @type string
             */
            indexAttribute: {
                reflectToAttribute: true,
                type: String,
                value: null
            },

            /**
             * If set to true, the selector is initialized.
             *
             * @attribute initialized
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            initialized: {
                notify: true,
                observer: '_initializedChanged',
                readOnly: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the mutation observer is set.
             *
             * @attribute is-mutated
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            isMutated: {
                notify: true,
                readOnly: true,
                type: Boolean,
                value: false
            },

            /**
             * The selector used to recognize selectable items.
             *
             * @attribute item-selector
             * @type string
             * @default "[selectable]"
             */
            itemSelector: {
                reflectToAttribute: true,
                type: String,
                value: '[selectable]'
            },

            /**
             * The selectable items.
             *
             * @attribute items
             * @type Array
             * @notifies
             */
            items: {
                notify: true,
                type: Array
            },

            /**
             * If set to true, multi selection is allowed.
             *
             * @attribute multi
             * @type boolean
             * @default false
             */
            multi: {
                observer: '_multiChanged',
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the selector is currently mutating.
             *
             * @attribute mutating
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            mutating: {
                notify: true,
                readOnly: true,
                type: Boolean,
                value: false
            },

            /**
             * The selected item's index.
             *
             * @attribute selected
             * @type Array | number | string
             * @notifies
             */
            selected: {
                notify: true,
                value: null
            },

            /**
             * The attribute set on selection.
             *
             * @attribute selected-attribute
             * @type string
             * @default "active"
             */
            selectedAttribute: {
                reflectToAttribute: true,
                type: String,
                value: 'active'
            },

            /**
             * If set to true, the selection is about to change.
             *
             * @attribute selecting
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            selecting: {
                notify: true,
                readOnly: true,
                type: Boolean,
                value: false
            },

            /**
             * The selected item.
             *
             * @attribute selection
             * @type Element
             * @notifies
             * @readonly
             */
            selection: {
                notify: true,
                readOnly: true,
                value: null
            },

            /**
             * If set to true, there's only one item.
             *
             * @attribute single-item
             * @type boolean
             * @default false
             * @notifies
             * @readonly
             */
            singleItem: {
                notify: true,
                readOnly: true,
                reflectToAttribute: true,
                type: Boolean,
                value: false
            },

            /**
             * If set to true, the unselection is allowed even if not multi.
             *
             * @attribute switchable
             * @type boolean
             * @default false
             */
            switchable: {
                reflectToAttribute: true,
                type: Boolean,
                value: false
            }
        },

        /*********************************************************************/

        // OBSERVER
        _initializedChanged: function (post) {

            // Vars
            var self = this;

            // Selecting
            if (post && XP.isInput(self.defaultSelected, true)) { self.select(self.indexAttribute ? self.defaultSelected : XP.toIndex(self.defaultSelected, true)); return; }
            if (post && XP.isInput(self.selected, true)) { self.select(self.selected); }
        },

        // OBSERVER
        _multiChanged: function (post) {

            // Vars
            var self = this;

            // Setting
            if (post) { self._setSelection(XP.toArray(self.selection, true)); } else if (XP.isArray(self.selection)) { self._setSelection(null); }
            if (post) { self.selected = XP.toArray(self.selected, true); } else if (XP.isArray(self.selected)) { self.selected = null; }
        },

        /*********************************************************************/

        // LISTENER
        attached: function () {

            // Vars
            var self = this;

            // Setting
            if (!self.items) { self.items = []; } else { return; }

            // Mutating
            Polymer.XPSelectedBehaviorImp.mutated.apply(self);
        },

        // LISTENER
        mutated: function () {

            // Vars
            var self = this;

            // Finding
            self.overwrite('items', XP[self.deep ? 'getElements' : 'findElements'](Polymer.dom(self.context || self), self.itemSelector));

            // Setting
            self._setMutating(self.isMutated);
            self._setIsMutated(true);

            // Refreshing
            self._refresh();

            // Observing
            XP.onMutation(self.context || self, Polymer.XPSelectedBehaviorImp.mutated.bind(self));
        },

        /*********************************************************************/

        // HANDLER
        _itemsHandler: function () {

            // Vars
            var self = this;

            // Setting
            self._setEmptyItems(self.items.length === 0);
            self._setInitialized(self.initialized || self.items.length > 0);
            self._setSingleItem(self.items.length === 1);
        },

        // HANDLER
        _selectedHandler: function () {

            // Vars
            var self   = this._refresh(),
                target = self.findTarget();

            // Propagating
            if (target) { target.selected = self.selected; }
        },

        // HANDLER
        _selectionHandler: function () {

            // Vars
            var self = this;

            // Firing
            self.fire('xp-selection', {firer: self, selection: self.selection, selected: self.selected, isMulti: self.multi, isSwitchable: self.multi || self.switchable});

            // Setting
            XP.forEach(self.items || [], function (item) { XP.setAttribute(item, self.selectedAttribute, self.isSelected(item, true)); });
        }
    };

    Polymer.XPSelectedBehavior = [
        Polymer.XPArrayBehavior,
        Polymer.XPTargeterBehavior,
        Polymer.XPSelectedBehaviorImp
    ];
</script><style is="custom-style">
    /* Application theme */
    :root {
        --dark-primary-color: #303F9F;
        --default-primary-color: #3F51B5;
        --light-primary-color: #C5CAE9;
        --text-primary-color: #ffffff; /*text/icons*/
        --accent-color: #FF4081;
        --primary-background-color: #c5cae9;
        --primary-text-color: #212121;
        --secondary-text-color: #727272;
        --disabled-text-color: #bdbdbd;
        --divider-color: #B6B6B6;
        --paper-tabs-selection-bar-color: #FFFFFF;

        /* Components */

        /* paper-drawer-panel */
        --drawer-menu-color: #ffffff;
        --drawer-border-color: 1px solid #ccc;
        --drawer-toolbar-border-color: 1px solid rgba(0, 0, 0, 0.22);

        /* paper-menu */
        --paper-menu-background-color: #fff;
        --menu-link-color: #111111;
    }

    /* General styles */

    .paper-tab-0 #ink.paper-tab {
        color: #303F9F;
    }

    #drawerToolbar {
        color: var(--secondary-text-color);
        background-color: var(--drawer-menu-color);
        border-bottom: var(--drawer-toolbar-border-color);
        height: 64px;
    }

    paper-item {
        position: relative;
        height: 48px;
        line-height: 48px;
        /*color: #646464;*/
        font-size: 0.9em;
    }

    paper-item.paper-item-0 {
        /*font-family: "Roboto Mono", Roboto, sans-serif;*/
        letter-spacing: 0.25px;
    }

    paper-material:not(.container):not(.shadow) {
        border-radius: 2px;
        padding: 16px 0 16px 0;
        width: calc(98.66% - 16px);
        margin: 16px auto;
        background: white;
    }

    paper-menu iron-icon {
        margin-right: 33px;
        opacity: 0.54;
    }

    .paper-menu > .iron-selected {
        color: var(--default-primary-color);
    }

    paper-menu a {
        text-decoration: none;
        color: var(--menu-link-color);
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
        font-family: 'Roboto', 'Noto', sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        font-size: 14px;
        font-weight: 400;
        line-height: 24px;
        min-height: 48px;
        padding: 0 16px;
    }

    #mainToolbar .middle {
        margin-left: 48px;
    }

    #mainToolbar.has-shadow .middle {
        /*font-size: 20px;*/
        padding-bottom: 0;
        margin-left: 48px;
    }

    /* Height of the scroll area */
    /*.content {
      height: 900px;
    }*/

    /* Breakpoints */

    /* Small */
    @media (max-width: 600px) {

        paper-material:not(.container):not(.shadow) {
            --menu-container-display: none;
            width: calc(97.33% - 32px);
            padding-left: 16px;
            padding-right: 16px;
        }

        .paper-font-display1 {
            font-size: 12px;
        }

        .app-name {
            font-size: 26px;
        }

        #drawer .paper-toolbar {
            margin-left: 16px;
        }

        #overlay {
            min-width: 360px;
        }

        .bg {
            background: white;
        }

        img {
            width: calc(98.66% - 16px);
        }

    }

    /* Tablet+ */
    @media (min-width: 601px) {

        paper-material:not(.container):not(.shadow) {
            width: calc(98% - 46px);
            margin-bottom: 32px;
            padding-left: 30px;
            padding-right: 30px;
        }

        #drawer.paper-drawer-panel > [drawer] {
            border-right: 1px solid rgba(0, 0, 0, 0.14);
        }

        iron-pages {
            padding: 48px 62px;
        }

    }

    /* Material Design Adaptive Breakpoints */
    /*
      Below you'll find CSS media queries based on the breakpoint guidance
      published by the Material Design team. You can choose to use, customise
      or remove these breakpoints based on your needs.

      http://www.google.com/design/spec/layout/adaptive-ui.html#adaptive-ui-breakpoints
     */

    /* mobile-small */
    @media all and (min-width: 0) and (max-width: 360px) and (orientation: portrait) {
    }

    /* mobile-large */
    @media all and (min-width: 361px) and (orientation: portrait) {
    }

    /* mobile-small-landscape */
    @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) {
    }

    /* mobile-large-landscape */
    @media all and (min-width: 481px) and (orientation: landscape) {
    }

    /* tablet-small-landscape */
    @media all and (min-width: 600px) and (max-width: 960px) and (orientation: landscape) {
    }

    /* tablet-large-landscape */
    @media all and (min-width: 961px) and (orientation: landscape) {
    }

    /* tablet-small */
    @media all and (min-width: 600px) and (orientation: portrait) {
    }

    /* tablet-large */
    @media all and (min-width: 601px) and (max-width: 840px) and (orientation: portrait) {
    }

    /* desktop-x-small-landscape */
    @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) {
    }

    /* desktop-x-small */
    @media all and (min-width: 0) and (max-width: 480px) and (max-aspect-ratio: 4/3) {
    }

    /* desktop-small-landscape */
    @media all and (min-width: 481px) and (max-width: 840px) and (orientation: landscape) {
    }

    /* desktop-small */
    @media all and (min-width: 481px) and (max-width: 840px) and (max-aspect-ratio: 4/3) {
    }

    /* desktop-medium-landscape */
    @media all and (min-width: 841px) and (max-width: 1280px) and (orientation: landscape) {
    }

    /* desktop-medium */
    @media all and (min-width: 841px) and (max-width: 1280px) and (max-aspect-ratio: 4/3) {
    }

    /* desktop-large */
    @media all and (min-width: 1281px) and (max-width: 1600px) {
    }

    /* desktop-xlarge */
    @media all and (min-width: 1601px) and (max-width: 1920px) {
    }
</style>







<script>

  Polymer({

    is: 'cascaded-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    properties: {

      _animationMeta: {
        type: Object,
        value: function() {
          return new Polymer.IronMeta({type: 'animation'});
        }
      }

    },

    configure: function(config) {
      var animationConstructor = this._animationMeta.byKey(config.animation);
      if (!animationConstructor) {
        console.warn(this.is + ':', 'constructor for', config.animation, 'not found!');
        return;
      }

      var nodes = config.nodes;
      var effects = [];
      var nodeDelay = config.nodeDelay || 50;

      config.timing = config.timing || {};
      config.timing.delay = config.timing.delay || 0;

      var oldDelay = config.timing.delay;
      for (var node, index = 0; node = nodes[index]; index++) {
        config.timing.delay += nodeDelay;
        config.node = node;

        var animation = new animationConstructor();
        var effect = animation.configure(config);

        effects.push(effect);
      }
      config.timing.delay = oldDelay;

      this._effect = new GroupEffect(effects);
      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'fade-in-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;
      this._effect = new KeyframeEffect(node, [
        {'opacity': '0'},
        {'opacity': '1'}
      ], this.timingFromConfig(config));
      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'fade-out-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;
      this._effect = new KeyframeEffect(node, [
        {'opacity': '1'},
        {'opacity': '0'}
      ], this.timingFromConfig(config));
      return this._effect;
    }

  });

</script>
<script>

  /**
   * Use `Polymer.NeonSharedElementAnimationBehavior` to implement shared element animations.
   * @polymerBehavior
   */
  Polymer.NeonSharedElementAnimationBehavior = [Polymer.NeonAnimationBehavior, {

    properties: {

      /**
       * Cached copy of shared elements.
       */
      sharedElements: {
        type: Object
      }

    },

    /**
     * Finds shared elements based on `config`.
     */
    findSharedElements: function(config) {
      var fromPage = config.fromPage;
      var toPage = config.toPage;
      if (!fromPage || !toPage) {
        console.warn(this.is + ':', !fromPage ? 'fromPage' : 'toPage', 'is undefined!');
        return null;
      };

      if (!fromPage.sharedElements || !toPage.sharedElements) {
        console.warn(this.is + ':', 'sharedElements are undefined for', !fromPage.sharedElements ? fromPage : toPage);
        return null;
      };

      var from = fromPage.sharedElements[config.id]
      var to = toPage.sharedElements[config.id];

      if (!from || !to) {
        console.warn(this.is + ':', 'sharedElement with id', config.id, 'not found in', !from ? fromPage : toPage);
        return null;
      }

      this.sharedElements = {
        from: from,
        to: to
      };
      return this.sharedElements;
    }

  }];

</script>


<script>

  Polymer({

    is: 'hero-animation',

    behaviors: [
      Polymer.NeonSharedElementAnimationBehavior
    ],

    configure: function(config) {
      var shared = this.findSharedElements(config);
      if (!shared) {
        return null;
      }

      var fromRect = shared.from.getBoundingClientRect();
      var toRect = shared.to.getBoundingClientRect();

      var deltaLeft = fromRect.left - toRect.left;
      var deltaTop = fromRect.top - toRect.top;
      var deltaWidth = fromRect.width / toRect.width;
      var deltaHeight = fromRect.height / toRect.height;

      this.setPrefixedProperty(shared.to, 'transformOrigin', '0 0');
      shared.to.style.zIndex = 10000;
      shared.from.style.visibility = 'hidden';

      this._effect = new KeyframeEffect(shared.to, [
        {'transform': 'translate(' + deltaLeft + 'px,' + deltaTop + 'px) scale(' + deltaWidth + ',' + deltaHeight + ')'},
        {'transform': 'none'}
      ], this.timingFromConfig(config));

      return this._effect;
    },

    complete: function(config) {
      var shared = this.findSharedElements(config);
      if (!shared) {
        return null;
      }
      shared.to.style.zIndex = '';
      shared.from.style.visibility = '';
    }

  });

</script>


<script>

  Polymer({

    is: 'ripple-animation',

    behaviors: [
      Polymer.NeonSharedElementAnimationBehavior
    ],

    configure: function(config, fromPage, toPage) {
      var shared = this.findSharedElements(config, fromPage, toPage);
      if (!shared) {
        return null;
      }

      var translateX, translateY;
      var toRect = shared.to.getBoundingClientRect();
      if (config.gesture) {
        translateX = config.gesture.x - (toRect.left + (toRect.width / 2));
        translateY = config.gesture.y - (toRect.left + (toRect.height / 2));
      } else {
        var fromRect = shared.from.getBoundingClientRect();
        translateX = (fromRect.left + (fromRect.width / 2)) - (toRect.left + (toRect.width / 2));
        translateY = (fromRect.top + (fromRect.height / 2)) - (toRect.left + (toRect.height / 2));
      }
      var translate = 'translate(' + translateX + 'px,' + translateY + 'px)';

      var size = Math.max(toRect.width + Math.abs(translateX) * 2, toRect.height + Math.abs(translateY) * 2);
      var diameter = Math.sqrt(2 * size * size);
      var scaleX = diameter / toRect.width;
      var scaleY = diameter / toRect.height;
      var scale = 'scale(' + scaleX + ',' + scaleY + ')';

      this.setPrefixedProperty(shared.to, 'transformOrigin', '50% 50%');
      shared.to.style.borderRadius = '50%';

      this._effect = new KeyframeEffect(shared.to, [
        {'transform': translate + ' scale(0)'},
        {'transform': translate + ' ' + scale}
      ], this.timingFromConfig(config));
      return this._effect;
    },

    complete: function() {
      if (this.sharedElements) {
        this.setPrefixedProperty(this.sharedElements.to, 'transformOrigin', '');
        this.sharedElements.to.style.borderRadius = '';
      }
    }

  });

</script>


<script>

  Polymer({

    is: 'scale-down-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      }

      var scaleProperty = 'scale(0, 0)';
      if (config.axis === 'x') {
        scaleProperty = 'scale(0, 1)';
      } else if (config.axis === 'y') {
        scaleProperty = 'scale(1, 0)';
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': 'scale(1,1)'},
        {'transform': scaleProperty}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'scale-up-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': 'scale(0)'},
        {'transform': 'scale(1)'}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'slide-from-left-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      } else {
        this.setPrefixedProperty(node, 'transformOrigin', '0 50%');
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': 'translateX(-100%)'},
        {'transform': 'none'}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'slide-from-right-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      } else {
        this.setPrefixedProperty(node, 'transformOrigin', '0 50%');
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': 'translateX(100%)'},
        {'transform': 'none'}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'slide-left-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      } else {
        this.setPrefixedProperty(node, 'transformOrigin', '0 50%');
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': 'none'},
        {'transform': 'translateX(-100%)'}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'slide-right-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      } else {
        this.setPrefixedProperty(node, 'transformOrigin', '0 50%');
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': 'none'},
        {'transform': 'translateX(100%)'}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'slide-up-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      } else {
        this.setPrefixedProperty(node, 'transformOrigin', '50% 0');
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': 'translate(0)'},
        {'transform': 'translateY(-100%)'}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'slide-down-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      } else {
        this.setPrefixedProperty(node, 'transformOrigin', '50% 0');
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': 'translateY(-100%)'},
        {'transform': 'none'}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>


<script>

  Polymer({

    is: 'transform-animation',

    behaviors: [
      Polymer.NeonAnimationBehavior
    ],

    configure: function(config) {
      var node = config.node;
      var transformFrom = config.transformFrom || 'none';
      var transformTo = config.transformTo || 'none';

      if (config.transformOrigin) {
        this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
      }

      this._effect = new KeyframeEffect(node, [
        {'transform': transformFrom},
        {'transform': transformTo}
      ], this.timingFromConfig(config));

      return this._effect;
    }

  });

</script>








</head><body><div hidden="" by-vulcanize=""><dom-module id="iron-pages" assetpath="../bower_components/iron-pages/">

  <style>

    :host {
      display: block;
    }

    :host > ::content > :not(.iron-selected) {
      display: none !important;
    }

  </style>

  <template>

    <content></content>

  </template>

</dom-module>

<script>

  Polymer({

    is: 'iron-pages',

    behaviors: [
      Polymer.IronResizableBehavior,
      Polymer.IronSelectableBehavior
    ],

    observers: [
      '_selectedPageChanged(selected)'
    ],

    _selectedPageChanged: function(selected, old) {
      this.async(this.notifyResize);
    }
  });

</script>
<dom-module id="iron-image" assetpath="../bower_components/iron-image/">

  <style>

    :host {
      display: inline-block;
      overflow: hidden;
      position: relative;
    }

    :host([sizing]) #img {
      display: none;
    }

    #placeholder {
      background-color: inherit;
      opacity: 1;
    }

    #placeholder.faded-out {
      transition: opacity 0.5s linear;
      opacity: 0;
    }

  </style>

  <template>

    <img id="img" role="none" hidden$="[[_computeImageVisibility(sizing)]]">
    <div id="placeholder" hidden$="[[_computePlaceholderVisibility(fade,loaded,preload)]]" class$="[[_computePlaceholderClassName(fade,loaded,preload)]]"></div>
    <content></content>

  </template>

</dom-module>

<script>

  Polymer({

    is: 'iron-image',

    properties: {
      /**
       * The URL of an image.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: {
        observer: '_srcChanged',
        type: String,
        value: ''
      },

      /**
       * When true, the image is prevented from loading and any placeholder is
       * shown.  This may be useful when a binding to the src property is known to
       * be invalid, to prevent 404 requests.
       *
       * @attribute preventLoad
       * @type boolean
       * @default false
       */
      preventLoad: {
        type: Boolean,
        value: false
      },

      /**
       * Sets a sizing option for the image.  Valid values are `contain` (full
       * aspect ratio of the image is contained within the element and
       * letterboxed) or `cover` (image is cropped in order to fully cover the
       * bounds of the element), or `null` (default: image takes natural size).
       *
       * @attribute sizing
       * @type string
       * @default null
       */
      sizing: {
        type: String,
        value: null
      },

      /**
       * When a sizing option is uzed (`cover` or `contain`), this determines
       * how the image is aligned within the element bounds.
       *
       * @attribute position
       * @type string
       * @default 'center'
       */
      position: {
        type: String,
        value: 'center'
      },

      /**
       * When `true`, any change to the `src` property will cause the `placeholder`
       * image to be shown until the
       *
       * @attribute preload
       * @type boolean
       * @default false
       */
      preload: {
        type: Boolean,
        value: false
      },

      /**
       * This image will be used as a background/placeholder until the src image has
       * loaded.  Use of a data-URI for placeholder is encouraged for instant rendering.
       *
       * @attribute placeholder
       * @type string
       * @default null
       */
      placeholder: {
        type: String,
        value: null
      },

      /**
       * When `preload` is true, setting `fade` to true will cause the image to
       * fade into place.
       *
       * @attribute fade
       * @type boolean
       * @default false
       */
      fade: {
        type: Boolean,
        value: false
      },

      /**
       * Read-only value that is true when the image is loaded.
       *
       * @attribute preloaded
       * @type boolean
       * @default false
       */
      loaded: {
        notify: true,
        type: Boolean,
        value: false
      },

      /**
       * Read-only value that tracks the loading state of the image when the `preload`
       * option is used.
       *
       * @attribute loading
       * @type boolean
       * @default false
       */
      loading: {
        notify: true,
        type: Boolean,
        value: false
      },

      /**
       * Can be used to set the width of image (e.g. via binding); size may also be
       * set via CSS.
       *
       * @attribute width
       * @type number
       * @default null
       */
      width: {
        observer: '_widthChanged',
        type: Number,
        value: null
      },

      /**
       * Can be used to set the height of image (e.g. via binding); size may also be
       * set via CSS.
       *
       * @attribute height
       * @type number
       * @default null
       */
      height: {
        observer: '_heightChanged',
        type: Number,
        value: null
      },

      _placeholderBackgroundUrl: {
        type: String,
        computed: '_computePlaceholderBackgroundUrl(preload,placeholder)',
        observer: '_placeholderBackgroundUrlChanged'
      },

      requiresPreload: {
        type: Boolean,
        computed: '_computeRequiresPreload(preload,loaded)'
      },

      canLoad: {
        type: Boolean,
        computed: '_computeCanLoad(preventLoad, src)'
      }

    },

    observers: [
      '_transformChanged(sizing, position)',
      '_loadBehaviorChanged(canLoad, preload, loaded)',
      '_loadStateChanged(src, preload, loaded)',
    ],

    ready: function() {
      if (!this.hasAttribute('role')) {
        this.setAttribute('role', 'img');
      }
    },

    _computeImageVisibility: function() {
      return !!this.sizing;
    },

    _computePlaceholderVisibility: function() {
      return !this.preload || (this.loaded && !this.fade);
    },

    _computePlaceholderClassName: function() {
      if (!this.preload) {
        return '';
      }

      var className = 'fit';
      if (this.loaded && this.fade) {
        className += ' faded-out';
      }
      return className;
    },

    _computePlaceholderBackgroundUrl: function() {
      if (this.preload && this.placeholder) {
        return 'url(' + this.placeholder + ')';
      }

      return null;
    },

    _computeRequiresPreload: function() {
      return this.preload && !this.loaded;
    },

    _computeCanLoad: function() {
      return Boolean(!this.preventLoad && this.src);
    },

    _widthChanged: function() {
      this.style.width = isNaN(this.width) ? this.width : this.width + 'px';
    },

    _heightChanged: function() {
      this.style.height = isNaN(this.height) ? this.height : this.height + 'px';
    },

    _srcChanged: function(newSrc, oldSrc) {
      if (newSrc !== oldSrc) {
        this.loaded = false;
      }
    },

    _placeholderBackgroundUrlChanged: function() {
      this.$.placeholder.style.backgroundImage =
        this._placeholderBackgroundUrl;
    },

    _transformChanged: function() {
      var placeholderStyle = this.$.placeholder.style;

      this.style.backgroundSize =
        placeholderStyle.backgroundSize = this.sizing;

      this.style.backgroundPosition =
        placeholderStyle.backgroundPosition =
        this.sizing ? this.position : null;

      this.style.backgroundRepeat =
        placeholderStyle.backgroundRepeat =
        this.sizing ? 'no-repeat' : null;
    },

    _loadBehaviorChanged: function() {
      var img;

      if (!this.canLoad) {
        return;
      }

      if (this.requiresPreload) {
        img = new Image();
        img.src = this.src;

        this.loading = true;

        img.onload = function() {
          this.loading = false;
          this.loaded = true;
        }.bind(this);
      } else {
        this.loaded = true;
      }
    },

    _loadStateChanged: function() {
      if (this.requiresPreload) {
        return;
      }

      if (this.sizing) {
        this.style.backgroundImage = this.src ? 'url(' + this.src + ')': '';
      } else {
        this.$.img.src = this.src || '';
      }
    }
  });

</script>
<iron-iconset-svg name="icons" size="24">
<svg><defs>
<g id="3d-rotation"><path d="M7.52 21.48C4.25 19.94 1.91 16.76 1.55 13H.05C.56 19.16 5.71 24 12 24l.66-.03-3.81-3.81-1.33 1.32zm.89-6.52c-.19 0-.37-.03-.52-.08-.16-.06-.29-.13-.4-.24-.11-.1-.2-.22-.26-.37-.06-.14-.09-.3-.09-.47h-1.3c0 .36.07.68.21.95.14.27.33.5.56.69.24.18.51.32.82.41.3.1.62.15.96.15.37 0 .72-.05 1.03-.15.32-.1.6-.25.83-.44s.42-.43.55-.72c.13-.29.2-.61.2-.97 0-.19-.02-.38-.07-.56-.05-.18-.12-.35-.23-.51-.1-.16-.24-.3-.4-.43-.17-.13-.37-.23-.61-.31.2-.09.37-.2.52-.33.15-.13.27-.27.37-.42.1-.15.17-.3.22-.46.05-.16.07-.32.07-.48 0-.36-.06-.68-.18-.96-.12-.28-.29-.51-.51-.69-.2-.19-.47-.33-.77-.43C9.1 8.05 8.76 8 8.39 8c-.36 0-.69.05-1 .16-.3.11-.57.26-.79.45-.21.19-.38.41-.51.67-.12.26-.18.54-.18.85h1.3c0-.17.03-.32.09-.45s.14-.25.25-.34c.11-.09.23-.17.38-.22.15-.05.3-.08.48-.08.4 0 .7.1.89.31.19.2.29.49.29.86 0 .18-.03.34-.08.49-.05.15-.14.27-.25.37-.11.1-.25.18-.41.24-.16.06-.36.09-.58.09H7.5v1.03h.77c.22 0 .42.02.6.07s.33.13.45.23c.12.11.22.24.29.4.07.16.1.35.1.57 0 .41-.12.72-.35.93-.23.23-.55.33-.95.33zm8.55-5.92c-.32-.33-.7-.59-1.14-.77-.43-.18-.92-.27-1.46-.27H12v8h2.3c.55 0 1.06-.09 1.51-.27.45-.18.84-.43 1.16-.76.32-.33.57-.73.74-1.19.17-.47.26-.99.26-1.57v-.4c0-.58-.09-1.1-.26-1.57-.18-.47-.43-.87-.75-1.2zm-.39 3.16c0 .42-.05.79-.14 1.13-.1.33-.24.62-.43.85-.19.23-.43.41-.71.53-.29.12-.62.18-.99.18h-.91V9.12h.97c.72 0 1.27.23 1.64.69.38.46.57 1.12.57 1.99v.4zM12 0l-.66.03 3.81 3.81 1.33-1.33c3.27 1.55 5.61 4.72 5.96 8.48h1.5C23.44 4.84 18.29 0 12 0z"></path></g>
<g id="accessibility"><path d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"></path></g>
<g id="account-balance"><path d="M4 10v7h3v-7H4zm6 0v7h3v-7h-3zM2 22h19v-3H2v3zm14-12v7h3v-7h-3zm-4.5-9L2 6v2h19V6l-9.5-5z"></path></g>
<g id="account-balance-wallet"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="account-box"><path d="M3 5v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2H5c-1.11 0-2 .9-2 2zm12 4c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3zm-9 8c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1H6v-1z"></path></g>
<g id="account-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"></path></g>
<g id="add"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g>
<g id="add-alert"><path d="M10.01 21.01c0 1.1.89 1.99 1.99 1.99s1.99-.89 1.99-1.99h-3.98zm8.87-4.19V11c0-3.25-2.25-5.97-5.29-6.69v-.72C13.59 2.71 12.88 2 12 2s-1.59.71-1.59 1.59v.72C7.37 5.03 5.12 7.75 5.12 11v5.82L3 18.94V20h18v-1.06l-2.12-2.12zM16 13.01h-3v3h-2v-3H8V11h3V8h2v3h3v2.01z"></path></g>
<g id="add-box"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g>
<g id="add-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g>
<g id="add-circle-outline"><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="add-shopping-cart"><path d="M11 9h2V6h3V4h-3V1h-2v3H8v2h3v3zm-4 9c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm-9.83-3.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.86-7.01L19.42 4h-.01l-1.1 2-2.76 5H8.53l-.13-.27L6.16 6l-.95-2-.94-2H1v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.13 0-.25-.11-.25-.25z"></path></g>
<g id="alarm"><path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12.5 8H11v6l4.75 2.85.75-1.23-4-2.37V8zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path></g>
<g id="alarm-add"><path d="M7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm1-11h-2v3H8v2h3v3h2v-3h3v-2h-3V9z"></path></g>
<g id="alarm-off"><path d="M12 6c3.87 0 7 3.13 7 7 0 .84-.16 1.65-.43 2.4l1.52 1.52c.58-1.19.91-2.51.91-3.92 0-4.97-4.03-9-9-9-1.41 0-2.73.33-3.92.91L9.6 6.43C10.35 6.16 11.16 6 12 6zm10-.28l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM2.92 2.29L1.65 3.57 2.98 4.9l-1.11.93 1.42 1.42 1.11-.94.8.8C3.83 8.69 3 10.75 3 13c0 4.97 4.02 9 9 9 2.25 0 4.31-.83 5.89-2.2l2.2 2.2 1.27-1.27L3.89 3.27l-.97-.98zm13.55 16.1C15.26 19.39 13.7 20 12 20c-3.87 0-7-3.13-7-7 0-1.7.61-3.26 1.61-4.47l9.86 9.86zM8.02 3.28L6.6 1.86l-.86.71 1.42 1.42.86-.71z"></path></g>
<g id="alarm-on"><path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm-1.46-5.47L8.41 12.4l-1.06 1.06 3.18 3.18 6-6-1.06-1.06-4.93 4.95z"></path></g>
<g id="android"><path d="M6 18c0 .55.45 1 1 1h1v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h2v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h1c.55 0 1-.45 1-1V8H6v10zM3.5 8C2.67 8 2 8.67 2 9.5v7c0 .83.67 1.5 1.5 1.5S5 17.33 5 16.5v-7C5 8.67 4.33 8 3.5 8zm17 0c-.83 0-1.5.67-1.5 1.5v7c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-7c0-.83-.67-1.5-1.5-1.5zm-4.97-5.84l1.3-1.3c.2-.2.2-.51 0-.71-.2-.2-.51-.2-.71 0l-1.48 1.48C13.85 1.23 12.95 1 12 1c-.96 0-1.86.23-2.66.63L7.85.15c-.2-.2-.51-.2-.71 0-.2.2-.2.51 0 .71l1.31 1.31C6.97 3.26 6 5.01 6 7h12c0-1.99-.97-3.75-2.47-4.84zM10 5H9V4h1v1zm5 0h-1V4h1v1z"></path></g>
<g id="announcement"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 9h-2V5h2v6zm0 4h-2v-2h2v2z"></path></g>
<g id="apps"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"></path></g>
<g id="archive"><path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z"></path></g>
<g id="arrow-back"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></g>
<g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
<g id="arrow-drop-down-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 12l-4-4h8l-4 4z"></path></g>
<g id="arrow-drop-up"><path d="M7 14l5-5 5 5z"></path></g>
<g id="arrow-forward"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></g>
<g id="aspect-ratio"><path d="M19 12h-2v3h-3v2h5v-5zM7 9h3V7H5v5h2V9zm14-6H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"></path></g>
<g id="assessment"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path></g>
<g id="assignment"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path></g>
<g id="assignment-ind"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 4c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1.4c0-2 4-3.1 6-3.1s6 1.1 6 3.1V19z"></path></g>
<g id="assignment-late"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-6 15h-2v-2h2v2zm0-4h-2V8h2v6zm-1-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"></path></g>
<g id="assignment-return"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm4 12h-4v3l-5-5 5-5v3h4v4z"></path></g>
<g id="assignment-returned"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 15l-5-5h3V9h4v4h3l-5 5z"></path></g>
<g id="assignment-turned-in"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-2 14l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"></path></g>
<g id="attachment"><path d="M7.5 18C4.46 18 2 15.54 2 12.5S4.46 7 7.5 7H18c2.21 0 4 1.79 4 4s-1.79 4-4 4H9.5C8.12 15 7 13.88 7 12.5S8.12 10 9.5 10H17v1.5H9.5c-.55 0-1 .45-1 1s.45 1 1 1H18c1.38 0 2.5-1.12 2.5-2.5S19.38 8.5 18 8.5H7.5c-2.21 0-4 1.79-4 4s1.79 4 4 4H17V18H7.5z"></path></g>
<g id="autorenew"><path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"></path></g>
<g id="backspace"><path d="M22 3H7c-.69 0-1.23.35-1.59.88L0 12l5.41 8.11c.36.53.9.89 1.59.89h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-3 12.59L17.59 17 14 13.41 10.41 17 9 15.59 12.59 12 9 8.41 10.41 7 14 10.59 17.59 7 19 8.41 15.41 12 19 15.59z"></path></g>
<g id="backup"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"></path></g>
<g id="block"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z"></path></g>
<g id="book"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"></path></g>
<g id="bookmark"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z"></path></g>
<g id="bookmark-border"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z"></path></g>
<g id="bug-report"><path d="M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z"></path></g>
<g id="build"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"></path></g>
<g id="cached"><path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"></path></g>
<g id="camera-enhance"><path d="M9 3L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-3.17L15 3H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zM12 17l1.25-2.75L16 13l-2.75-1.25L12 9l-1.25 2.75L8 13l2.75 1.25z"></path></g>
<g id="cancel"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"></path></g>
<g id="card-giftcard"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"></path></g>
<g id="card-membership"><path d="M20 2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h4v5l4-2 4 2v-5h4c1.11 0 2-.89 2-2V4c0-1.11-.89-2-2-2zm0 13H4v-2h16v2zm0-5H4V4h16v6z"></path></g>
<g id="card-travel"><path d="M20 6h-3V4c0-1.11-.89-2-2-2H9c-1.11 0-2 .89-2 2v2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zM9 4h6v2H9V4zm11 15H4v-2h16v2zm0-5H4V8h3v2h2V8h6v2h2V8h3v6z"></path></g>
<g id="change-history"><path d="M12 7.77L18.39 18H5.61L12 7.77M12 4L2 20h20L12 4z"></path></g>
<g id="check"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
<g id="check-box"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
<g id="check-box-outline-blank"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="check-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
<g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
<g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
<g id="chrome-reader-mode"><path d="M13 12h7v1.5h-7zm0-2.5h7V11h-7zm0 5h7V16h-7zM21 4H3c-1.1 0-2 .9-2 2v13c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 15h-9V6h9v13z"></path></g>
<g id="class"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"></path></g>
<g id="clear"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
<g id="close"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
<g id="cloud"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"></path></g>
<g id="cloud-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.5 14H8c-1.66 0-3-1.34-3-3s1.34-3 3-3l.14.01C8.58 8.28 10.13 7 12 7c2.21 0 4 1.79 4 4h.5c1.38 0 2.5 1.12 2.5 2.5S17.88 16 16.5 16z"></path></g>
<g id="cloud-done"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 17l-3.5-3.5 1.41-1.41L10 14.17 15.18 9l1.41 1.41L10 17z"></path></g>
<g id="cloud-download"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM17 13l-5 5-5-5h3V9h4v4h3z"></path></g>
<g id="cloud-off"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4c-1.48 0-2.85.43-4.01 1.17l1.46 1.46C10.21 6.23 11.08 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3 0 1.13-.64 2.11-1.56 2.62l1.45 1.45C23.16 18.16 24 16.68 24 15c0-2.64-2.05-4.78-4.65-4.96zM3 5.27l2.75 2.74C2.56 8.15 0 10.77 0 14c0 3.31 2.69 6 6 6h11.73l2 2L21 20.73 4.27 4 3 5.27zM7.73 10l8 8H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h1.73z"></path></g>
<g id="cloud-queue"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM19 18H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h.71C7.37 7.69 9.48 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3s-1.34 3-3 3z"></path></g>
<g id="cloud-upload"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"></path></g>
<g id="code"><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></g>
<g id="content-copy"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></g>
<g id="content-cut"><path d="M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64zM6 8c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zM19 3l-6 6 2 2 7-7V3z"></path></g>
<g id="content-paste"><path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"></path></g>
<g id="create"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
<g id="credit-card"><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"></path></g>
<g id="dashboard"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"></path></g>
<g id="delete"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g>
<g id="description"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"></path></g>
<g id="dns"><path d="M20 13H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zM7 19c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zM7 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="done"><path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path></g>
<g id="done-all"><path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z"></path></g>
<g id="drafts"><path d="M21.99 8c0-.72-.37-1.35-.94-1.7L12 1 2.95 6.3C2.38 6.65 2 7.28 2 8v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10zM12 13L3.74 7.84 12 3l8.26 4.84L12 13z"></path></g>
<g id="eject"><path d="M5 17h14v2H5zm7-12L5.33 15h13.34z"></path></g>
<g id="error"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
<g id="error-outline"><path d="M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="event"><path d="M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"></path></g>
<g id="event-seat"><defs><path id="a" d="M0 0h24v24H0V0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path d="M4 18v3h3v-3h10v3h3v-6H4zm15-8h3v3h-3zM2 10h3v3H2zm15 3H7V5c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2v8z" clip-path="url(#b)"></path></g>
<g id="exit-to-app"><path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="expand-less"><path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"></path></g>
<g id="expand-more"><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></g>
<g id="explore"><path d="M12 10.9c-.61 0-1.1.49-1.1 1.1s.49 1.1 1.1 1.1c.61 0 1.1-.49 1.1-1.1s-.49-1.1-1.1-1.1zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm2.19 12.19L6 18l3.81-8.19L18 6l-3.81 8.19z"></path></g>
<g id="extension"><path d="M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z"></path></g>
<g id="face"><path d="M9 11.75c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zm6 0c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-.29.02-.58.05-.86 2.36-1.05 4.23-2.98 5.21-5.37C11.07 8.33 14.05 10 17.42 10c.78 0 1.53-.09 2.25-.26.21.71.33 1.47.33 2.26 0 4.41-3.59 8-8 8z"></path></g>
<g id="favorite"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></g>
<g id="favorite-border"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"></path></g>
<g id="feedback"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 12h-2v-2h2v2zm0-4h-2V6h2v4z"></path></g>
<g id="file-download"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></g>
<g id="file-upload"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"></path></g>
<g id="filter-list"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"></path></g>
<g id="find-in-page"><path d="M20 19.59V8l-6-6H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c.45 0 .85-.15 1.19-.4l-4.43-4.43c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75L20 19.59zM9 13c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3z"></path></g>
<g id="find-replace"><path d="M11 6c1.38 0 2.63.56 3.54 1.46L12 10h6V4l-2.05 2.05C14.68 4.78 12.93 4 11 4c-3.53 0-6.43 2.61-6.92 6H6.1c.46-2.28 2.48-4 4.9-4zm5.64 9.14c.66-.9 1.12-1.97 1.28-3.14H15.9c-.46 2.28-2.48 4-4.9 4-1.38 0-2.63-.56-3.54-1.46L10 12H4v6l2.05-2.05C7.32 17.22 9.07 18 11 18c1.55 0 2.98-.51 4.14-1.36L20 21.49 21.49 20l-4.85-4.86z"></path></g>
<g id="flag"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path></g>
<g id="flight-land"><defs><path id="a" d="M0 0h24v24H0V0z"></path></defs><defs><path id="c" d="M0 0h24v24H0V0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><clipPath id="d" clip-path="url(#b)"><use xlink:href="#c" overflow="visible"></use></clipPath><path d="M2.5 19h19v2h-19zm7.18-5.73l4.35 1.16 5.31 1.42c.8.21 1.62-.26 1.84-1.06.21-.8-.26-1.62-1.06-1.84l-5.31-1.42-2.76-9.02L10.12 2v8.28L5.15 8.95l-.93-2.32-1.45-.39v5.17l1.6.43 5.31 1.43z" clip-path="url(#d)"></path></g>
<g id="flight-takeoff"><defs><path id="a" d="M0 0h24v24H0V0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path d="M2.5 19h19v2h-19zm19.57-9.36c-.21-.8-1.04-1.28-1.84-1.06L14.92 10l-6.9-6.43-1.93.51 4.14 7.17-4.97 1.33-1.97-1.54-1.45.39 1.82 3.16.77 1.33 1.6-.43 5.31-1.42 4.35-1.16L21 11.49c.81-.23 1.28-1.05 1.07-1.85z" clip-path="url(#b)"></path></g>
<g id="flip-to-back"><path d="M9 7H7v2h2V7zm0 4H7v2h2v-2zm0-8c-1.11 0-2 .9-2 2h2V3zm4 12h-2v2h2v-2zm6-12v2h2c0-1.1-.9-2-2-2zm-6 0h-2v2h2V3zM9 17v-2H7c0 1.1.89 2 2 2zm10-4h2v-2h-2v2zm0-4h2V7h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zM5 7H3v12c0 1.1.89 2 2 2h12v-2H5V7zm10-2h2V3h-2v2zm0 12h2v-2h-2v2z"></path></g>
<g id="flip-to-front"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm2 4v-2H3c0 1.1.89 2 2 2zM3 9h2V7H3v2zm12 12h2v-2h-2v2zm4-18H9c-1.11 0-2 .9-2 2v10c0 1.1.89 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12H9V5h10v10zm-8 6h2v-2h-2v2zm-4 0h2v-2H7v2z"></path></g>
<g id="folder"><path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"></path></g>
<g id="folder-open"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"></path></g>
<g id="folder-shared"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-5 3c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2v1z"></path></g>
<g id="font-download"><path d="M9.93 13.5h4.14L12 7.98zM20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H9.17l-1.12 3H5.96l5.11-13h1.86l5.11 13h-2.09z"></path></g>
<g id="forward"><path d="M12 8V4l8 8-8 8v-4H4V8z"></path></g>
<g id="fullscreen"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></g>
<g id="fullscreen-exit"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path></g>
<g id="gesture"><path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"></path></g>
<g id="get-app"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></g>
<g id="gif"><defs><path id="a" d="M24 24H0V0h24v24z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path d="M11.5 9H13v6h-1.5zM9 9H6c-.6 0-1 .5-1 1v4c0 .5.4 1 1 1h3c.6 0 1-.5 1-1v-2H8.5v1.5h-2v-3H10V10c0-.5-.4-1-1-1zm10 1.5V9h-4.5v6H16v-2h2v-1.5h-2v-1z" clip-path="url(#b)"></path></g>
<g id="grade"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
<g id="group-work"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM8 17.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zM9.5 8c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8zm6.5 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="help"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path></g>
<g id="help-outline"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"></path></g>
<g id="highlight-off"><path d="M14.59 8L12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41 14.59 8zM12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="history"><path opacity=".9" d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path></g>
<g id="home"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"></path></g>
<g id="hourglass-empty"><path d="M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6zm10 14.5V20H8v-3.5l4-4 4 4zm-4-5l-4-4V4h8v3.5l-4 4z"></path></g>
<g id="hourglass-full"><path d="M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6z"></path></g>
<g id="http"><path d="M4.5 11h-2V9H1v6h1.5v-2.5h2V15H6V9H4.5v2zm2.5-.5h1.5V15H10v-4.5h1.5V9H7v1.5zm5.5 0H14V15h1.5v-4.5H17V9h-4.5v1.5zm9-1.5H18v6h1.5v-2h2c.8 0 1.5-.7 1.5-1.5v-1c0-.8-.7-1.5-1.5-1.5zm0 2.5h-2v-1h2v1z"></path></g>
<g id="https"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path></g>
<g id="inbox"><path d="M19 3H4.99c-1.1 0-1.98.9-1.98 2L3 19c0 1.1.89 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12h-4c0 1.66-1.34 3-3 3s-3-1.34-3-3H4.99V5H19v10zm-3-5h-2V7h-4v3H8l4 4 4-4z"></path></g>
<g id="indeterminate-check-box"><defs><path id="a" d="M0 0h24v24H0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path clip-path="url(#b)" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"></path></g>
<g id="info"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path></g>
<g id="info-outline"><path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z"></path></g>
<g id="input"><path d="M21 3.01H3c-1.1 0-2 .9-2 2V9h2V4.99h18v14.03H3V15H1v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zM11 16l4-4-4-4v3H1v2h10v3z"></path></g>
<g id="invert-colors"><path d="M17.66 7.93L12 2.27 6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58c2.05 0 4.1-.78 5.66-2.34 3.12-3.12 3.12-8.19 0-11.31zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"></path></g>
<g id="label"><path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"></path></g>
<g id="label-outline"><path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16zM16 17H5V7h11l3.55 5L16 17z"></path></g>
<g id="language"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"></path></g>
<g id="launch"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path></g>
<g id="link"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"></path></g>
<g id="list"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path></g>
<g id="lock"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path></g>
<g id="lock-open"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"></path></g>
<g id="lock-outline"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6-5.1c1.71 0 3.1 1.39 3.1 3.1v2H9V6h-.1c0-1.71 1.39-3.1 3.1-3.1zM18 20H6V10h12v10zm-6-3c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path></g>
<g id="loyalty"><path d="M21.41 11.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7zm11.77 8.27L13 19.54l-4.27-4.27C8.28 14.81 8 14.19 8 13.5c0-1.38 1.12-2.5 2.5-2.5.69 0 1.32.28 1.77.74l.73.72.73-.73c.45-.45 1.08-.73 1.77-.73 1.38 0 2.5 1.12 2.5 2.5 0 .69-.28 1.32-.73 1.77z"></path></g>
<g id="mail"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path></g>
<g id="markunread"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path></g>
<g id="markunread-mailbox"><path d="M20 6H10v6H8V4h6V0H6v6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"></path></g>
<g id="menu"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></g>
<g id="more-horiz"><path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="more-vert"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="note-add"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2zm-3-7V3.5L18.5 9H13z"></path></g>
<g id="offline-pin"><defs><path id="a" d="M0 0h24v24H0V0z"></path></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"></use></clipPath><path clip-path="url(#b)" d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm5 16H7v-2h10v2zm-6.7-4L7 10.7l1.4-1.4 1.9 1.9 5.3-5.3L17 7.3 10.3 14z"></path></g>
<g id="open-in-browser"><path d="M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h4v-2H5V8h14v10h-4v2h4c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2zm-7 6l-4 4h3v6h2v-6h3l-4-4z"></path></g>
<g id="open-in-new"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path></g>
<g id="open-with"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"></path></g>
<g id="pageview"><path d="M11.5 9C10.12 9 9 10.12 9 11.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5S12.88 9 11.5 9zM20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-3.21 14.21l-2.91-2.91c-.69.44-1.51.7-2.39.7C9.01 16 7 13.99 7 11.5S9.01 7 11.5 7 16 9.01 16 11.5c0 .88-.26 1.69-.7 2.39l2.91 2.9-1.42 1.42z"></path></g>
<g id="payment"><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"></path></g>
<g id="perm-camera-mic"><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v-2.09c-2.83-.48-5-2.94-5-5.91h2c0 2.21 1.79 4 4 4s4-1.79 4-4h2c0 2.97-2.17 5.43-5 5.91V21h7c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-6 8c0 1.1-.9 2-2 2s-2-.9-2-2V9c0-1.1.9-2 2-2s2 .9 2 2v4z"></path></g>
<g id="perm-contact-calendar"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1z"></path></g>
<g id="perm-data-setting"><path d="M18.99 11.5c.34 0 .67.03 1 .07L20 0 0 20h11.56c-.04-.33-.07-.66-.07-1 0-4.14 3.36-7.5 7.5-7.5zm3.71 7.99c.02-.16.04-.32.04-.49 0-.17-.01-.33-.04-.49l1.06-.83c.09-.08.12-.21.06-.32l-1-1.73c-.06-.11-.19-.15-.31-.11l-1.24.5c-.26-.2-.54-.37-.85-.49l-.19-1.32c-.01-.12-.12-.21-.24-.21h-2c-.12 0-.23.09-.25.21l-.19 1.32c-.3.13-.59.29-.85.49l-1.24-.5c-.11-.04-.24 0-.31.11l-1 1.73c-.06.11-.04.24.06.32l1.06.83c-.02.16-.03.32-.03.49 0 .17.01.33.03.49l-1.06.83c-.09.08-.12.21-.06.32l1 1.73c.06.11.19.15.31.11l1.24-.5c.26.2.54.37.85.49l.19 1.32c.02.12.12.21.25.21h2c.12 0 .23-.09.25-.21l.19-1.32c.3-.13.59-.29.84-.49l1.25.5c.11.04.24 0 .31-.11l1-1.73c.06-.11.03-.24-.06-.32l-1.07-.83zm-3.71 1.01c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="perm-device-information"><path d="M13 7h-2v2h2V7zm0 4h-2v6h2v-6zm4-9.99L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"></path></g>
<g id="perm-identity"><path d="M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></g>
<g id="perm-media"><path d="M2 6H0v5h.01L0 20c0 1.1.9 2 2 2h18v-2H2V6zm20-2h-8l-2-2H6c-1.1 0-1.99.9-1.99 2L4 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7 15l4.5-6 3.5 4.51 2.5-3.01L21 15H7z"></path></g>
<g id="perm-phone-msg"><path d="M20 15.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM12 3v10l3-3h6V3h-9z"></path></g>
<g id="perm-scan-wifi"><path d="M12 3C6.95 3 3.15 4.85 0 7.23L12 22 24 7.25C20.85 4.87 17.05 3 12 3zm1 13h-2v-6h2v6zm-2-8V6h2v2h-2z"></path></g>
<g id="picture-in-picture"><path d="M19 7h-8v6h8V7zm2-4H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z"></path></g>
<g id="play-for-work"><path fill="#010101" d="M11 5v5.59H7.5l4.5 4.5 4.5-4.5H13V5h-2zm-5 9c0 3.31 2.69 6 6 6s6-2.69 6-6h-2c0 2.21-1.79 4-4 4s-4-1.79-4-4H6z"></path></g>
<g id="polymer"><path d="M19 4h-4L7.11 16.63 4.5 12 9 4H5L.5 12 5 20h4l7.89-12.63L19.5 12 15 20h4l4.5-8z"></path></g>
<g id="power-settings-new"><path d="M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.58-5.42L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z"></path></g>
<g id="print"><path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"></path></g>
<g id="query-builder"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zM12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="question-answer"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"></path></g>
<g id="radio-button-checked"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="radio-button-unchecked"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="receipt"><path d="M18 17H6v-2h12v2zm0-4H6v-2h12v2zm0-4H6V7h12v2zM3 22l1.5-1.5L6 22l1.5-1.5L9 22l1.5-1.5L12 22l1.5-1.5L15 22l1.5-1.5L18 22l1.5-1.5L21 22V2l-1.5 1.5L18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2 4.5 3.5 3 2v20z"></path></g>
<g id="redeem"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"></path></g>
<g id="redo"><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"></path></g>
<g id="refresh"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></g>
<g id="remove"><path d="M19 13H5v-2h14v2z"></path></g>
<g id="remove-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"></path></g>
<g id="remove-circle-outline"><path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="reorder"><path d="M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"></path></g>
<g id="reply"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path></g>
<g id="reply-all"><path d="M7 8V5l-7 7 7 7v-3l-4-4 4-4zm6 1V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path></g>
<g id="report"><path d="M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"></path></g>
<g id="report-problem"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
<g id="restore"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path></g>
<g id="room"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="save"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path></g>
<g id="schedule"><path fill-opacity=".9" d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zM12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="search"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path></g>
<g id="select-all"><path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"></path></g>
<g id="send"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></g>
<g id="settings"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></g>
<g id="settings-applications"><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42c-.09-.15-.05-.34.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16c-.13-.11-.17-.3-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z"></path></g>
<g id="settings-backup-restore"><path d="M14 12c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2zm-2-9c-4.97 0-9 4.03-9 9H0l4 4 4-4H5c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.51 0-2.91-.49-4.06-1.3l-1.42 1.44C8.04 20.3 9.94 21 12 21c4.97 0 9-4.03 9-9s-4.03-9-9-9z"></path></g>
<g id="settings-bluetooth"><path d="M11 24h2v-2h-2v2zm-4 0h2v-2H7v2zm8 0h2v-2h-2v2zm2.71-18.29L12 0h-1v7.59L6.41 3 5 4.41 10.59 10 5 15.59 6.41 17 11 12.41V20h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 3.83l1.88 1.88L13 7.59V3.83zm1.88 10.46L13 16.17v-3.76l1.88 1.88z"></path></g>
<g id="settings-brightness"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02zM8 16h2.5l1.5 1.5 1.5-1.5H16v-2.5l1.5-1.5-1.5-1.5V8h-2.5L12 6.5 10.5 8H8v2.5L6.5 12 8 13.5V16zm4-7c1.66 0 3 1.34 3 3s-1.34 3-3 3V9z"></path></g>
<g id="settings-cell"><path d="M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM16 .01L8 0C6.9 0 6 .9 6 2v16c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V2c0-1.1-.9-1.99-2-1.99zM16 16H8V4h8v12z"></path></g>
<g id="settings-ethernet"><path d="M7.77 6.76L6.23 5.48.82 12l5.41 6.52 1.54-1.28L3.42 12l4.35-5.24zM7 13h2v-2H7v2zm10-2h-2v2h2v-2zm-6 2h2v-2h-2v2zm6.77-7.52l-1.54 1.28L20.58 12l-4.35 5.24 1.54 1.28L23.18 12l-5.41-6.52z"></path></g>
<g id="settings-input-antenna"><path d="M12 5c-3.87 0-7 3.13-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.87-3.13-7-7-7zm1 9.29c.88-.39 1.5-1.26 1.5-2.29 0-1.38-1.12-2.5-2.5-2.5S9.5 10.62 9.5 12c0 1.02.62 1.9 1.5 2.29v3.3L7.59 21 9 22.41l3-3 3 3L16.41 21 13 17.59v-3.3zM12 1C5.93 1 1 5.93 1 12h2c0-4.97 4.03-9 9-9s9 4.03 9 9h2c0-6.07-4.93-11-11-11z"></path></g>
<g id="settings-input-component"><path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path></g>
<g id="settings-input-composite"><path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path></g>
<g id="settings-input-hdmi"><path d="M18 7V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v3H5v6l3 6v3h8v-3l3-6V7h-1zM8 4h8v3h-2V5h-1v2h-2V5h-1v2H8V4z"></path></g>
<g id="settings-input-svideo"><path d="M8 11.5c0-.83-.67-1.5-1.5-1.5S5 10.67 5 11.5 5.67 13 6.5 13 8 12.33 8 11.5zm7-5c0-.83-.67-1.5-1.5-1.5h-3C9.67 5 9 5.67 9 6.5S9.67 8 10.5 8h3c.83 0 1.5-.67 1.5-1.5zM8.5 15c-.83 0-1.5.67-1.5 1.5S7.67 18 8.5 18s1.5-.67 1.5-1.5S9.33 15 8.5 15zM12 1C5.93 1 1 5.93 1 12s4.93 11 11 11 11-4.93 11-11S18.07 1 12 1zm0 20c-4.96 0-9-4.04-9-9s4.04-9 9-9 9 4.04 9 9-4.04 9-9 9zm5.5-11c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-2 5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path></g>
<g id="settings-overscan"><path d="M12.01 5.5L10 8h4l-1.99-2.5zM18 10v4l2.5-1.99L18 10zM6 10l-2.5 2.01L6 14v-4zm8 6h-4l2.01 2.5L14 16zm7-13H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"></path></g>
<g id="settings-phone"><path d="M13 9h-2v2h2V9zm4 0h-2v2h2V9zm3 6.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM19 9v2h2V9h-2z"></path></g>
<g id="settings-power"><path d="M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm2-22h-2v10h2V2zm3.56 2.44l-1.45 1.45C16.84 6.94 18 8.83 18 11c0 3.31-2.69 6-6 6s-6-2.69-6-6c0-2.17 1.16-4.06 2.88-5.12L7.44 4.44C5.36 5.88 4 8.28 4 11c0 4.42 3.58 8 8 8s8-3.58 8-8c0-2.72-1.36-5.12-3.44-6.56zM15 24h2v-2h-2v2z"></path></g>
<g id="settings-remote"><path d="M15 9H9c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V10c0-.55-.45-1-1-1zm-3 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM7.05 6.05l1.41 1.41C9.37 6.56 10.62 6 12 6s2.63.56 3.54 1.46l1.41-1.41C15.68 4.78 13.93 4 12 4s-3.68.78-4.95 2.05zM12 0C8.96 0 6.21 1.23 4.22 3.22l1.41 1.41C7.26 3.01 9.51 2 12 2s4.74 1.01 6.36 2.64l1.41-1.41C17.79 1.23 15.04 0 12 0z"></path></g>
<g id="settings-voice"><path d="M7 24h2v-2H7v2zm5-11c1.66 0 2.99-1.34 2.99-3L15 4c0-1.66-1.34-3-3-3S9 2.34 9 4v6c0 1.66 1.34 3 3 3zm-1 11h2v-2h-2v2zm4 0h2v-2h-2v2zm4-14h-1.7c0 3-2.54 5.1-5.3 5.1S6.7 13 6.7 10H5c0 3.41 2.72 6.23 6 6.72V20h2v-3.28c3.28-.49 6-3.31 6-6.72z"></path></g>
<g id="shop"><path d="M16 6V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H2v13c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6h-6zm-6-2h4v2h-4V4zM9 18V9l7.5 4L9 18z"></path></g>
<g id="shop-two"><path d="M3 9H1v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2H3V9zm15-4V3c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H5v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2V5h-5zm-6-2h4v2h-4V3zm0 12V8l5.5 3-5.5 4z"></path></g>
<g id="shopping-basket"><path d="M17.21 9l-4.38-6.56c-.19-.28-.51-.42-.83-.42-.32 0-.64.14-.83.43L6.79 9H2c-.55 0-1 .45-1 1 0 .09.01.18.04.27l2.54 9.27c.23.84 1 1.46 1.92 1.46h13c.92 0 1.69-.62 1.93-1.46l2.54-9.27L23 10c0-.55-.45-1-1-1h-4.79zM9 9l3-4.4L15 9H9zm3 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="shopping-cart"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="sort"><path d="M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"></path></g>
<g id="speaker-notes"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 14H6v-2h2v2zm0-3H6V9h2v2zm0-3H6V6h2v2zm7 6h-5v-2h5v2zm3-3h-8V9h8v2zm0-3h-8V6h8v2z"></path></g>
<g id="spellcheck"><path d="M12.45 16h2.09L9.43 3H7.57L2.46 16h2.09l1.12-3h5.64l1.14 3zm-6.02-5L8.5 5.48 10.57 11H6.43zm15.16.59l-8.09 8.09L9.83 16l-1.41 1.41 5.09 5.09L23 13l-1.41-1.41z"></path></g>
<g id="star"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
<g id="star-border"><path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"></path></g>
<g id="star-half"><path d="M22 9.74l-7.19-.62L12 2.5 9.19 9.13 2 9.74l5.46 4.73-1.64 7.03L12 17.77l6.18 3.73-1.63-7.03L22 9.74zM12 15.9V6.6l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.9z"></path></g>
<g id="stars"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm4.24 16L12 15.45 7.77 18l1.12-4.81-3.73-3.23 4.92-.42L12 5l1.92 4.53 4.92.42-3.73 3.23L16.23 18z"></path></g>
<g id="store"><path d="M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z"></path></g>
<g id="subject"><path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"></path></g>
<g id="supervisor-account"><path d="M16.5 12c1.38 0 2.49-1.12 2.49-2.5S17.88 7 16.5 7C15.12 7 14 8.12 14 9.5s1.12 2.5 2.5 2.5zM9 11c1.66 0 2.99-1.34 2.99-3S10.66 5 9 5C7.34 5 6 6.34 6 8s1.34 3 3 3zm7.5 3c-1.83 0-5.5.92-5.5 2.75V19h11v-2.25c0-1.83-3.67-2.75-5.5-2.75zM9 13c-2.33 0-7 1.17-7 3.5V19h7v-2.25c0-.85.33-2.34 2.37-3.47C10.5 13.1 9.66 13 9 13z"></path></g>
<g id="swap-horiz"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"></path></g>
<g id="swap-vert"><path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"></path></g>
<g id="swap-vertical-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.5 9L10 5.5 13.5 9H11v4H9V9H6.5zm11 6L14 18.5 10.5 15H13v-4h2v4h2.5z"></path></g>
<g id="system-update-alt"><path d="M12 16.5l4-4h-3v-9h-2v9H8l4 4zm9-13h-6v1.99h6v14.03H3V5.49h6V3.5H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2z"></path></g>
<g id="tab"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h10v4h8v10z"></path></g>
<g id="tab-unselected"><path d="M1 9h2V7H1v2zm0 4h2v-2H1v2zm0-8h2V3c-1.1 0-2 .9-2 2zm8 16h2v-2H9v2zm-8-4h2v-2H1v2zm2 4v-2H1c0 1.1.9 2 2 2zM21 3h-8v6h10V5c0-1.1-.9-2-2-2zm0 14h2v-2h-2v2zM9 5h2V3H9v2zM5 21h2v-2H5v2zM5 5h2V3H5v2zm16 16c1.1 0 2-.9 2-2h-2v2zm0-8h2v-2h-2v2zm-8 8h2v-2h-2v2zm4 0h2v-2h-2v2z"></path></g>
<g id="text-format"><path d="M5 17v2h14v-2H5zm4.5-4.2h5l.9 2.2h2.1L12.75 4h-1.5L6.5 15h2.1l.9-2.2zM12 5.98L13.87 11h-3.74L12 5.98z"></path></g>
<g id="theaters"><path d="M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z"></path></g>
<g id="thumb-down"><path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v1.91l.01.01L1 14c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"></path></g>
<g id="thumb-up"><path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"></path></g>
<g id="thumbs-up-down"><path d="M12 6c0-.55-.45-1-1-1H5.82l.66-3.18.02-.23c0-.31-.13-.59-.33-.8L5.38 0 .44 4.94C.17 5.21 0 5.59 0 6v6.5c0 .83.67 1.5 1.5 1.5h6.75c.62 0 1.15-.38 1.38-.91l2.26-5.29c.07-.17.11-.36.11-.55V6zm10.5 4h-6.75c-.62 0-1.15.38-1.38.91l-2.26 5.29c-.07.17-.11.36-.11.55V18c0 .55.45 1 1 1h5.18l-.66 3.18-.02.24c0 .31.13.59.33.8l.79.78 4.94-4.94c.27-.27.44-.65.44-1.06v-6.5c0-.83-.67-1.5-1.5-1.5z"></path></g>
<g id="toc"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z"></path></g>
<g id="today"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"></path></g>
<g id="toll"><path d="M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zM3 12c0-2.61 1.67-4.83 4-5.65V4.26C3.55 5.15 1 8.27 1 12s2.55 6.85 6 7.74v-2.09c-2.33-.82-4-3.04-4-5.65z"></path></g>
<g id="track-changes"><path fill="#231F20" d="M19.07 4.93l-1.41 1.41C19.1 7.79 20 9.79 20 12c0 4.42-3.58 8-8 8s-8-3.58-8-8c0-4.08 3.05-7.44 7-7.93v2.02C8.16 6.57 6 9.03 6 12c0 3.31 2.69 6 6 6s6-2.69 6-6c0-1.66-.67-3.16-1.76-4.24l-1.41 1.41C15.55 9.9 16 10.9 16 12c0 2.21-1.79 4-4 4s-4-1.79-4-4c0-1.86 1.28-3.41 3-3.86v2.14c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V2h-1C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10c0-2.76-1.12-5.26-2.93-7.07z"></path></g>
<g id="translate"><path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></g>
<g id="trending-down"><path d="M16 18l2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6z"></path></g>
<g id="trending-flat"><path d="M22 12l-4-4v3H3v2h15v3z"></path></g>
<g id="trending-up"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"></path></g>
<g id="turned-in"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z"></path></g>
<g id="turned-in-not"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z"></path></g>
<g id="undo"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"></path></g>
<g id="unfold-less"><path d="M7.41 18.59L8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"></path></g>
<g id="unfold-more"><path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"></path></g>
<g id="verified-user"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"></path></g>
<g id="view-agenda"><path d="M20 13H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm0-10H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"></path></g>
<g id="view-array"><path d="M4 18h3V5H4v13zM18 5v13h3V5h-3zM8 18h9V5H8v13z"></path></g>
<g id="view-carousel"><path d="M7 19h10V4H7v15zm-5-2h4V6H2v11zM18 6v11h4V6h-4z"></path></g>
<g id="view-column"><path d="M10 18h5V5h-5v13zm-6 0h5V5H4v13zM16 5v13h5V5h-5z"></path></g>
<g id="view-day"><path d="M2 21h19v-3H2v3zM20 8H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zM2 3v3h19V3H2z"></path></g>
<g id="view-headline"><path d="M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"></path></g>
<g id="view-list"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"></path></g>
<g id="view-module"><path d="M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z"></path></g>
<g id="view-quilt"><path d="M10 18h5v-6h-5v6zm-6 0h5V5H4v13zm12 0h5v-6h-5v6zM10 5v6h11V5H10z"></path></g>
<g id="view-stream"><path d="M4 18h17v-6H4v6zM4 5v6h17V5H4z"></path></g>
<g id="view-week"><path d="M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"></path></g>
<g id="visibility"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"></path></g>
<g id="visibility-off"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"></path></g>
<g id="warning"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
<g id="work"><path d="M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z"></path></g>
<g id="youtube-searched-for"><path d="M17.01 14h-.8l-.27-.27c.98-1.14 1.57-2.61 1.57-4.23 0-3.59-2.91-6.5-6.5-6.5s-6.5 3-6.5 6.5H2l3.84 4 4.16-4H6.51C6.51 7 8.53 5 11.01 5s4.5 2.01 4.5 4.5c0 2.48-2.02 4.5-4.5 4.5-.65 0-1.26-.14-1.82-.38L7.71 15.1c.97.57 2.09.9 3.3.9 1.61 0 3.08-.59 4.22-1.57l.27.27v.79l5.01 4.99L22 19l-4.99-5z"></path></g>
<g id="zoom-in"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"></path></g>
<g id="zoom-out"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"></path></g>
</defs></svg>
</iron-iconset-svg>
<iron-iconset-svg name="eh" iconsize="24">
    <svg>
        <defs>
            <g id="forum"><path d="M17,12V3A1,1 0 0,0 16,2H3A1,1 0 0,0 2,3V17L6,13H16A1,1 0 0,0 17,12M21,6H19V15H6V17A1,1 0 0,0 7,18H18L22,22V7A1,1 0 0,0 21,6Z"></path></g>
            <g id="information"><path d="M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z"></path></g>
            <g id="file-document-box"><path d="M14,17H7V15H14M17,13H7V11H17M17,9H7V7H17M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z"></path></g>
            <g id="truck"><path d="M18,18.5A1.5,1.5 0 0,1 16.5,17A1.5,1.5 0 0,1 18,15.5A1.5,1.5 0 0,1 19.5,17A1.5,1.5 0 0,1 18,18.5M19.5,9.5L21.46,12H17V9.5M6,18.5A1.5,1.5 0 0,1 4.5,17A1.5,1.5 0 0,1 6,15.5A1.5,1.5 0 0,1 7.5,17A1.5,1.5 0 0,1 6,18.5M20,8H17V4H3C1.89,4 1,4.89 1,6V17H3A3,3 0 0,0 6,20A3,3 0 0,0 9,17H15A3,3 0 0,0 18,20A3,3 0 0,0 21,17H23V12L20,8Z"></path></g>
            <g id="credit-card"><path d="M20,8H4V6H20M20,18H4V12H20M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z"></path></g>
            <g id="send"><path d="M2,21L23,12L2,3V10L17,12L2,14V21Z"></path></g>
            <g id="google-plus-box"><path d="M19,12H17V14H16V12H14V11H16V9H17V11H19M9.07,19.2C6.27,19.2 5,17.64 5,16.18C5,15.73 5.14,14.59 6.5,13.8C7.25,13.33 8.33,13 9.62,12.89C9.43,12.64 9.28,12.34 9.28,11.9C9.28,11.75 9.3,11.59 9.34,11.44H8.95C7,11.44 5.8,9.89 5.8,8.39C5.8,6.66 7.09,4.8 9.91,4.8H14.13L13.79,5.14L13.08,5.85L13,5.91H12.3C12.71,6.33 13.2,7 13.2,8.07C13.2,9.47 12.46,10.16 11.64,10.8C11.5,10.92 11.22,11.18 11.22,11.5C11.22,11.82 11.46,12 11.61,12.14C11.74,12.25 11.9,12.36 12.08,12.5C12.89,13.05 14,13.83 14,15.36C14,17.13 12.71,19.2 9.07,19.2M20,2H4A2,2 0 0,0 2,4V20A2,2 0 0,0 4,22H20A2,2 0 0,0 22,20V4C22,2.89 21.1,2 20,2M10.57,13.81C10.46,13.8 10.38,13.8 10.25,13.8H10.23C9.97,13.8 9.08,13.85 8.41,14.07C7.77,14.31 7,14.79 7,15.77C7,16.85 8.04,18 9.96,18C11.5,18 12.4,17 12.4,16C12.4,15.25 11.94,14.79 10.57,13.81M11.2,8.87C11.2,7.85 10.57,5.85 9.12,5.85C8.5,5.85 7.8,6.29 7.8,7.5C7.8,8.7 8.42,10.45 9.77,10.45C9.83,10.45 11.2,10.44 11.2,8.87Z"></path></g>
            <g id="facebook-box"><path d="M19,4V7H17A1,1 0 0,0 16,8V10H19V13H16V20H13V13H11V10H13V7.5C13,5.56 14.57,4 16.5,4M20,2H4A2,2 0 0,0 2,4V20A2,2 0 0,0 4,22H20A2,2 0 0,0 22,20V4C22,2.89 21.1,2 20,2Z"></path></g>
            <g id="cart"><path d="M17,18C15.89,18 15,18.89 15,20A2,2 0 0,0 17,22A2,2 0 0,0 19,20C19,18.89 18.1,18 17,18M1,2V4H3L6.6,11.59L5.24,14.04C5.09,14.32 5,14.65 5,15A2,2 0 0,0 7,17H19V15H7.42A0.25,0.25 0 0,1 7.17,14.75C7.17,14.7 7.18,14.66 7.2,14.63L8.1,13H15.55C16.3,13 16.96,12.58 17.3,11.97L20.88,5.5C20.95,5.34 21,5.17 21,5A1,1 0 0,0 20,4H5.21L4.27,2M7,18C5.89,18 5,18.89 5,20A2,2 0 0,0 7,22A2,2 0 0,0 9,20C9,18.89 8.1,18 7,18Z"></path></g>
            <g id="calendar-multiple"><path d="M21,17V8H7V17H21M21,3A2,2 0 0,1 23,5V17A2,2 0 0,1 21,19H7C5.89,19 5,18.1 5,17V5A2,2 0 0,1 7,3H8V1H10V3H18V1H20V3H21M3,21H17V23H3C1.89,23 1,22.1 1,21V9H3V21M19,15H15V11H19V15Z"></path></g>
            <g id="apple"><path d="M18.71,19.5C17.88,20.74 17,21.95 15.66,21.97C14.32,22 13.89,21.18 12.37,21.18C10.84,21.18 10.37,21.95 9.1,22C7.79,22.05 6.8,20.68 5.96,19.47C4.25,17 2.94,12.45 4.7,9.39C5.57,7.87 7.13,6.91 8.82,6.88C10.1,6.86 11.32,7.75 12.11,7.75C12.89,7.75 14.37,6.68 15.92,6.84C16.57,6.87 18.39,7.1 19.56,8.82C19.47,8.88 17.39,10.1 17.41,12.63C17.44,15.65 20.06,16.66 20.09,16.67C20.06,16.74 19.67,18.11 18.71,19.5M13,3.5C13.73,2.67 14.94,2.04 15.94,2C16.07,3.17 15.6,4.35 14.9,5.19C14.21,6.04 13.07,6.7 11.95,6.61C11.8,5.46 12.36,4.26 13,3.5Z"></path></g>
            <g id="google-play"><path d="M3,20.5V3.5C3,2.91 3.34,2.39 3.84,2.15L13.69,12L3.84,21.85C3.34,21.6 3,21.09 3,20.5M16.81,15.12L6.05,21.34L14.54,12.85L16.81,15.12M20.16,10.81C20.5,11.08 20.75,11.5 20.75,12C20.75,12.5 20.53,12.9 20.18,13.18L17.89,14.5L15.39,12L17.89,9.5L20.16,10.81M6.05,2.66L16.81,8.88L14.54,11.15L6.05,2.66Z"></path></g>
            <g id="map"><path d="M15,19L9,16.89V5L15,7.11M20.5,3C20.44,3 20.39,3 20.34,3L15,5.1L9,3L3.36,4.9C3.15,4.97 3,5.15 3,5.38V20.5A0.5,0.5 0 0,0 3.5,21C3.55,21 3.61,21 3.66,20.97L9,18.9L15,21L20.64,19.1C20.85,19 21,18.85 21,18.62V3.5A0.5,0.5 0 0,0 20.5,3Z"></path></g>
        </defs>
    </svg>
</iron-iconset-svg><iron-iconset-svg name="ai" iconsize="24">
	<svg>
		<defs>
			<g id="off">
				
				<svg version="1.1" id="Ebene_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 18 18" enable-background="new 0 0 18 18" xml:space="preserve">
<g display="none">
	
		<rect x="2.9" y="2.2" transform="matrix(0.9707 0.2403 -0.2403 0.9707 1.0059 -1.5223)" display="inline" width="7.7" height="2.3"></rect>
	<rect x="1" y="0.7" display="inline" width="5.7" height="11.8"></rect>
	<rect x="8.7" y="3.1" display="inline" width="2" height="4.9"></rect>
</g>
<g display="none">
	<rect x="5.9" y="13.8" display="inline" width="3.5" height="2"></rect>
	<polygon display="inline" points="9,12.3 12.1,14.8 9,17.4 	"></polygon>
</g>
<g display="none">
	<path display="inline" d="M9,0.5C4.3,0.5,0.5,4.3,0.5,9c0,4.7,3.8,8.5,8.5,8.5s8.5-3.8,8.5-8.5C17.5,4.3,13.7,0.5,9,0.5z M9,15.8
		c-3.7,0-6.8-3-6.8-6.8c0-3.7,3-6.8,6.8-6.8s6.8,3,6.8,6.8C15.8,12.7,12.7,15.8,9,15.8z"></path>
	<circle display="inline" cx="9" cy="9" r="6.8"></circle>
</g>
<circle display="none" cx="9" cy="9" r="5.5"></circle>
<circle display="none" cx="9" cy="9" r="7"></circle>
<rect x="8" y="2" display="none" width="2" height="14"></rect>
<g>
	<path d="M9,2C5.1,2,2,5.1,2,9c0,3.9,3.1,7,7,7s7-3.1,7-7C16,5.1,12.9,2,9,2z M9,14c-2.8,0-5-2.2-5-5c0-2.8,2.2-5,5-5s5,2.2,5,5
		C14,11.8,11.8,14,9,14z"></path>
	<circle display="none" cx="9" cy="9" r="5"></circle>
</g>
</svg>

			</g>
			<g id="on"><svg version="1.1" id="Ebene_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 18 18" enable-background="new 0 0 18 18" xml:space="preserve">
<g display="none">
	
		<rect x="2.9" y="2.2" transform="matrix(0.9707 0.2403 -0.2403 0.9707 1.0059 -1.5223)" display="inline" width="7.7" height="2.3"></rect>
	<rect x="1" y="0.7" display="inline" width="5.7" height="11.8"></rect>
	<rect x="8.7" y="3.1" display="inline" width="2" height="4.9"></rect>
</g>
<g display="none">
	<rect x="5.9" y="13.8" display="inline" width="3.5" height="2"></rect>
	<polygon display="inline" points="9,12.3 12.1,14.8 9,17.4 	"></polygon>
</g>
<g display="none">
	<path display="inline" d="M9,0.5C4.3,0.5,0.5,4.3,0.5,9c0,4.7,3.8,8.5,8.5,8.5s8.5-3.8,8.5-8.5C17.5,4.3,13.7,0.5,9,0.5z M9,15.8
		c-3.7,0-6.8-3-6.8-6.8c0-3.7,3-6.8,6.8-6.8s6.8,3,6.8,6.8C15.8,12.7,12.7,15.8,9,15.8z"></path>
	<circle display="inline" cx="9" cy="9" r="6.8"></circle>
</g>
<circle display="none" cx="9" cy="9" r="5.5"></circle>
<circle display="none" cx="9" cy="9" r="7"></circle>
<rect x="8" y="2" width="2" height="14"></rect>
<g display="none">
	<path display="inline" d="M9,2C5.1,2,2,5.1,2,9c0,3.9,3.1,7,7,7s7-3.1,7-7C16,5.1,12.9,2,9,2z M9,14c-2.8,0-5-2.2-5-5
		c0-2.8,2.2-5,5-5s5,2.2,5,5C14,11.8,11.8,14,9,14z"></path>
	<circle cx="9" cy="9" r="5"></circle>
</g>
</svg>
</g>
			<g id="in"></g>
			<g id="out"></g>
		</defs>
	</svg>
</iron-iconset-svg><dom-module id="iron-icon" assetpath="../bower_components/iron-icon/">

  <style>
    :host {
      @apply(--layout-inline);
      @apply(--layout-center-center);
      position: relative;

      vertical-align: middle;

      fill: currentcolor;

      width: var(--iron-icon-width);
      height: var(--iron-icon-height);
    }
  </style>

  <template>
    <iron-meta id="meta" type="iconset"></iron-meta>
  </template>

  <script>

    Polymer({

      is: 'iron-icon',

      properties: {

        /**
         * The name of the icon to use. The name should be of the form:
         * `iconset_name:icon_name`.
         */
        icon: {
          type: String,
          observer: '_iconChanged'
        },

        /**
         * The name of the theme to used, if one is specified by the
         * iconset.
         */
        theme: {
          type: String,
          observer: '_updateIcon'
        },

        /**
         * If using iron-icon without an iconset, you can set the src to be
         * the URL of an individual icon image file. Note that this will take
         * precedence over a given icon attribute.
         */
        src: {
          type: String,
          observer: '_srcChanged'
        }
      },

      _DEFAULT_ICONSET: 'icons',

      _iconChanged: function(icon) {
        var parts = (icon || '').split(':');
        this._iconName = parts.pop();
        this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
        this._updateIcon();
      },

      _srcChanged: function(src) {
        this._updateIcon();
      },

      _usesIconset: function() {
        return this.icon || !this.src;
      },

      _updateIcon: function() {
        if (this._usesIconset()) {
          if (this._iconsetName) {
            this._iconset = this.$.meta.byKey(this._iconsetName);
            if (this._iconset) {
              this._iconset.applyIcon(this, this._iconName, this.theme);
            } else {
              this._warn(this._logf('_updateIcon', 'could not find iconset `'
                + this._iconsetName + '`, did you import the iconset?'));
            }
          }
        } else {
          if (!this._img) {
            this._img = document.createElement('img');
            this._img.style.width = '100%';
            this._img.style.height = '100%';
          }
          this._img.src = this.src;
          Polymer.dom(this.root).appendChild(this._img);
        }
      }

    });

  </script>

</dom-module>

<dom-module id="paper-drawer-panel" assetpath="../bower_components/paper-drawer-panel/">
  <style>
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

*/
:host {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

iron-selector > #drawer {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background-color: white;
  will-change: transform;
  box-sizing: border-box;
  -moz-box-sizing: border-box;

  @apply(--paper-drawer-panel-drawer-container);
}

.transition > #drawer {
  transition: -webkit-transform ease-in-out 0.3s, width ease-in-out 0.3s;
  transition: transform ease-in-out 0.3s, width ease-in-out 0.3s;
}

.left-drawer > #drawer {
  @apply(--paper-drawer-panel-left-drawer-container);
}

.right-drawer > #drawer {
  left: auto;
  right: 0;

  @apply(--paper-drawer-panel-right-drawer-container);
}

iron-selector > #main {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;

  @apply(--paper-drawer-panel-main-container);
}

.transition > #main {
  transition: left ease-in-out 0.3s, padding ease-in-out 0.3s;
}

.right-drawer > #main {
  left: 0;
}

.right-drawer.transition > #main {
  transition: right ease-in-out 0.3s, padding ease-in-out 0.3s;
}

#main > ::content > [main] {
  height: 100%;
}

#drawer > ::content > [drawer] {
  height: 100%;
}

#scrim {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  visibility: hidden;
  opacity: 0;
  transition: opacity ease-in-out 0.38s, visibility ease-in-out 0.38s;
  background-color: rgba(0, 0, 0, 0.3);
}

.narrow-layout > #drawer.iron-selected {
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.15);
}

.right-drawer.narrow-layout > #drawer.iron-selected {
  box-shadow: -2px 2px 4px rgba(0, 0, 0, 0.15);
}

.narrow-layout > #drawer > ::content > [drawer] {
  border: 0;
}

.left-drawer.narrow-layout > #drawer:not(.iron-selected) {
  -webkit-transform: translateX(-100%);
  transform: translateX(-100%);
}

.right-drawer.narrow-layout > #drawer:not(.iron-selected) {
  left: auto;
  -webkit-transform: translateX(100%);
  transform: translateX(100%);
}

.narrow-layout > #main {
  left: 0 !important;
  padding: 0;
}

.right-drawer.narrow-layout > #main {
  left: 0;
  right: 0;
  padding: 0;
}

.narrow-layout > #main:not(.iron-selected) > #scrim,
.dragging > #main > #scrim {
  visibility: visible;
  opacity: var(--paper-drawer-panel-scrim-opacity, 1);
}

.narrow-layout > #main > * {
  margin: 0;
  min-height: 100%;
  left: 0;
  right: 0;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
}

iron-selector:not(.narrow-layout) #main ::content [paper-drawer-toggle] {
  display: none;
}
</style>

  <template>
    <iron-media-query id="mq" on-query-matches-changed="_onQueryMatchesChanged" query="[[_computeMediaQuery(forceNarrow, responsiveWidth)]]">
    </iron-media-query>

    <iron-selector attr-for-selected="id" class$="[[_computeIronSelectorClass(narrow, transition, dragging, rightDrawer)]]" activate-event="" selected="[[selected]]">

      <div id="main" style$="[[_computeMainStyle(narrow, rightDrawer, drawerWidth)]]">
        <content select="[main]"></content>
        <div id="scrim" on-tap="closeDrawer"></div>
      </div>

      <div id="drawer" style$="[[_computeDrawerStyle(drawerWidth)]]">
        <content select="[drawer]"></content>
      </div>

    </iron-selector>
  </template>

</dom-module>

<script>

  (function() {

    'use strict';

   // this would be the only `paper-drawer-panel` in
   // the whole app that can be in `dragging` state
    var sharedPanel = null;

    function classNames(obj) {
      var classes = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key]) {
          classes.push(key);
        }
      }

      return classes.join(' ');
    }

    Polymer({

      is: 'paper-drawer-panel',

      /**
       * Fired when the narrow layout changes.
       *
       * @event paper-responsive-change {{narrow: boolean}} detail -
       *     narrow: true if the panel is in narrow layout.
       */

      /**
       * Fired when the selected panel changes.
       *
       * Listening for this event is an alternative to observing changes in the `selected` attribute.
       * This event is fired both when a panel is selected and deselected.
       * The `isSelected` detail property contains the selection state.
       *
       * @event paper-select {{isSelected: boolean, item: Object}} detail -
       *     isSelected: True for selection and false for deselection.
       *     item: The panel that the event refers to.
       */

      properties: {

        /**
         * The panel to be selected when `paper-drawer-panel` changes to narrow
         * layout.
         */
        defaultSelected: {
          type: String,
          value: 'main'
        },

        /**
         * If true, swipe from the edge is disable.
         */
        disableEdgeSwipe: {
          type: Boolean,
          value: false
        },

        /**
         * If true, swipe to open/close the drawer is disabled.
         */
        disableSwipe: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the user is dragging the drawer interactively.
         */
        dragging: {
          type: Boolean,
          value: false
        },

        /**
         * Width of the drawer panel.
         */
        drawerWidth: {
          type: String,
          value: '256px'
        },

        /**
         * How many pixels on the side of the screen are sensitive to edge
         * swipes and peek.
         */
        edgeSwipeSensitivity: {
          type: Number,
          value: 30
        },

        /**
         * If true, ignore `responsiveWidth` setting and force the narrow layout.
         */
        forceNarrow: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the browser has support for the transform CSS property.
         */
        hasTransform: {
          type: Boolean,
          value: function() {
            return 'transform' in this.style;
          }
        },

        /**
         * Whether the browser has support for the will-change CSS property.
         */
        hasWillChange: {
          type: Boolean,
          value: function() {
            return 'willChange' in this.style;
          }
        },

        /**
         * Returns true if the panel is in narrow layout.  This is useful if you
         * need to show/hide elements based on the layout.
         */
        narrow: {
          reflectToAttribute: true,
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * Whether the drawer is peeking out from the edge.
         */
        peeking: {
          type: Boolean,
          value: false
        },

        /**
         * Max-width when the panel changes to narrow layout.
         */
        responsiveWidth: {
          type: String,
          value: '640px'
        },

        /**
         * If true, position the drawer to the right.
         */
        rightDrawer: {
          type: Boolean,
          value: false
        },

        /**
         * The panel that is being selected. `drawer` for the drawer panel and
         * `main` for the main panel.
         */
        selected: {
          reflectToAttribute: true,
          type: String,
          value: null
        },

        /**
         * The attribute on elements that should toggle the drawer on tap, also elements will
         * automatically be hidden in wide layout.
         */
        drawerToggleAttribute: {
          type: String,
          value: 'paper-drawer-toggle'
        },

        /**
         * Whether the transition is enabled.
         */
        transition: {
          type: Boolean,
          value: false
        },

      },

      listeners: {
        tap: '_onTap',
        track: '_onTrack',
        down: '_downHandler',
        up: '_upHandler'
      },

      observers: [
        '_forceNarrowChanged(forceNarrow, defaultSelected)'
      ],

      /**
       * Toggles the panel open and closed.
       *
       * @method togglePanel
       */
      togglePanel: function() {
        if (this._isMainSelected()) {
          this.openDrawer();
        } else {
          this.closeDrawer();
        }
      },

      /**
       * Opens the drawer.
       *
       * @method openDrawer
       */
      openDrawer: function() {
        this.selected = 'drawer';
      },

      /**
       * Closes the drawer.
       *
       * @method closeDrawer
       */
      closeDrawer: function() {
        this.selected = 'main';
      },

      ready: function() {
        // Avoid transition at the beginning e.g. page loads and enable
        // transitions only after the element is rendered and ready.
        this.transition = true;
      },

      _computeIronSelectorClass: function(narrow, transition, dragging, rightDrawer) {
        return classNames({
          dragging: dragging,
          'narrow-layout': narrow,
          'right-drawer': rightDrawer,
          'left-drawer': !rightDrawer,
          transition: transition
        });
      },

      _computeDrawerStyle: function(drawerWidth) {
        return 'width:' + drawerWidth + ';';
      },

      _computeMainStyle: function(narrow, rightDrawer, drawerWidth) {
        var style = '';

        style += 'left:' + ((narrow || rightDrawer) ? '0' : drawerWidth) + ';';

        if (rightDrawer) {
          style += 'right:' + (narrow ? '' : drawerWidth) + ';';
        } else {
          style += 'right:;';
        }

        return style;
      },

      _computeMediaQuery: function(forceNarrow, responsiveWidth) {
        return forceNarrow ? '' : '(max-width: ' + responsiveWidth + ')';
      },

      _computeSwipeOverlayHidden: function(narrow, disableEdgeSwipe) {
        return !narrow || disableEdgeSwipe;
      },

      _onTrack: function(e) {
        if (sharedPanel && this !== sharedPanel) {
          return;
        }
        switch (e.detail.state) {
          case 'start':
            this._trackStart(e);
            break;
          case 'track':
            this._trackX(e);
            break;
          case 'end':
            this._trackEnd(e);
            break;
        }

      },

      _responsiveChange: function(narrow) {
        this.narrow = narrow;

        if (this.narrow) {
          this.selected = this.defaultSelected;
        }

        this.setScrollDirection(this._swipeAllowed() ? 'y' : 'all');
        this.fire('paper-responsive-change', {narrow: this.narrow});
      },

      _onQueryMatchesChanged: function(e) {
        this._responsiveChange(e.detail.value);
      },

      _forceNarrowChanged: function() {
        // set the narrow mode only if we reached the `responsiveWidth`
        this._responsiveChange(this.forceNarrow || this.$.mq.queryMatches);
      },

      _swipeAllowed: function() {
        return this.narrow && !this.disableSwipe;
      },

      _isMainSelected: function() {
        return this.selected === 'main';
      },

      _startEdgePeek: function() {
        this.width = this.$.drawer.offsetWidth;
        this._moveDrawer(this._translateXForDeltaX(this.rightDrawer ?
            -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));
        this.peeking = true;
      },

      _stopEdgePeek: function() {
        if (this.peeking) {
          this.peeking = false;
          this._moveDrawer(null);
        }
      },

      _downHandler: function(e) {
        if (!this.dragging && this._isMainSelected() && this._isEdgeTouch(e) && !sharedPanel) {
          this._startEdgePeek();
          // grab this panel
          sharedPanel = this;
        }
      },

      _upHandler: function() {
        this._stopEdgePeek();
        // release the panel
        sharedPanel = null;
      },

      _onTap: function(e) {
        var targetElement = Polymer.dom(e).localTarget;
        var isTargetToggleElement = targetElement &&
          this.drawerToggleAttribute &&
          targetElement.hasAttribute(this.drawerToggleAttribute);

        if (isTargetToggleElement) {
          this.togglePanel();
        }
      },

      _isEdgeTouch: function(e) {
        var x = e.detail.x;

        return !this.disableEdgeSwipe && this._swipeAllowed() &&
          (this.rightDrawer ?
            x >= this.offsetWidth - this.edgeSwipeSensitivity :
            x <= this.edgeSwipeSensitivity);
      },

      _trackStart: function() {
        if (this._swipeAllowed()) {
          sharedPanel = this;
          this.dragging = true;

          if (this._isMainSelected()) {
            this.dragging = this.peeking || this._isEdgeTouch(event);
          }

          if (this.dragging) {
            this.width = this.$.drawer.offsetWidth;
            this.transition = false;
          }
        }
      },

      _translateXForDeltaX: function(deltaX) {
        var isMain = this._isMainSelected();

        if (this.rightDrawer) {
          return Math.max(0, isMain ? this.width + deltaX : deltaX);
        } else {
          return Math.min(0, isMain ? deltaX - this.width : deltaX);
        }
      },

      _trackX: function(e) {
        if (this.dragging) {
          var dx = e.detail.dx;

          if (this.peeking) {
            if (Math.abs(dx) <= this.edgeSwipeSensitivity) {
              // Ignore trackx until we move past the edge peek.
              return;
            }
            this.peeking = false;
          }

          this._moveDrawer(this._translateXForDeltaX(dx));
        }
      },

      _trackEnd: function(e) {
        if (this.dragging) {
          var xDirection = e.detail.dx > 0;

          this.dragging = false;
          this.transition = true;
          sharedPanel = null;
          this._moveDrawer(null);

          if (this.rightDrawer) {
            this[xDirection ? 'closeDrawer' : 'openDrawer']();
          } else {
            this[xDirection ? 'openDrawer' : 'closeDrawer']();
          }
        }
      },

      _transformForTranslateX: function(translateX) {
        if (translateX === null) {
          return '';
        }

        return this.hasWillChange ? 'translateX(' + translateX + 'px)' :
            'translate3d(' + translateX + 'px, 0, 0)';
      },

      _moveDrawer: function(translateX) {
        var s = this.$.drawer.style;

        if (this.hasTransform) {
          s.transform = this._transformForTranslateX(translateX);
        } else {
          s.webkitTransform = this._transformForTranslateX(translateX);
        }
      }

    });

  }());

</script>
<dom-module id="paper-header-panel" assetpath="../bower_components/paper-header-panel/">

  <style>
    :host {
      @apply(--layout);
      @apply(--layout-vertical);

      display: block;
      position: relative;
      height: 100%;

      /* Create a stack context, we will need it for the shadow*/
      z-index: 0;
    }

    #mainContainer {
      @apply(--layout-flex);

      position: relative;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      flex-basis: 0.0001px;
    }

    /*
     * mode: scroll
     */
    :host([mode=scroll]) #mainContainer {
      @apply(--paper-header-panel-scroll-container);
      overflow: visible;
    }

    :host([mode=scroll]) {
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
    }

    /*
     * mode: cover
     */
    :host([mode=cover]) #mainContainer {
      @apply(--paper-header-panel-cover-container);
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    /*
     * mode: standard
     */
    :host([mode=standard]) #mainContainer {
      @apply(--paper-header-panel-standard-container);
    }

    /*
     * mode: waterfall
     */
    :host([mode=waterfall]) #mainContainer {
      @apply(--paper-header-panel-waterfall-container);
    }

    /*
     * mode: waterfall-tall
     */
    :host([mode=waterfall-tall]) #mainContainer {
      @apply(--paper-header-panel-waterfall-tall-container);
    }

    :host ::content paper-toolbar,
    :host ::content .paper-header {
      position: relative;
      overflow: visible !important;
    }

    :host ::content paper-toolbar:after,
    :host ::content .paper-header:after {
      @apply(--paper-header-panel-shadow);

      -webkit-transition: opacity 0.5s, -webkit-transform 0.5s;
      transition: opacity 0.5s, transform 0.5s;

      opacity: 0;
      content: "";

      width: 100%;
      position: absolute;
      left: 0px;
      right: 0px;
      z-index: 1;

      -webkit-transform: scale3d(1, 0, 1);
      -webkit-transform-origin: 0% 0%;

      transform: scale3d(1, 0, 1);
      transform-origin: 0% 0%;
    }

    :host ::content paper-toolbar.has-shadow:after,
    :host ::content .paper-header.has-shadow:after {
      opacity: 1;
      -webkit-transform: scale3d(1, 1, 1);
      transform: scale3d(1, 1, 1);
    }
  </style>

  <template>
    <content id="headerContent" select="paper-toolbar, .paper-header"></content>
    <div id="mainContainer" class$="[[_computeMainContainerClass(mode)]]">
      <content id="mainContent" select="*"></content>
    </div>
  </template>

</dom-module>

<style is="custom-style">
  :root {
    /**
     * Default paper header panel shadow
     */
    --paper-header-panel-shadow: {
      height: 6px;
      bottom: -6px;
      box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
    };
  }
</style>

<script>

  (function() {

    'use strict';

    var SHADOW_WHEN_SCROLLING = 1;
    var SHADOW_ALWAYS = 2;


    var MODE_CONFIGS = {

      outerScroll: {
        scroll: true
      },

      shadowMode: {
        standard: SHADOW_ALWAYS,
        waterfall: SHADOW_WHEN_SCROLLING,
        'waterfall-tall': SHADOW_WHEN_SCROLLING
      },

      tallMode: {
        'waterfall-tall': true
      }
    };

    Polymer({

      is: 'paper-header-panel',

      /**
       * Fired when the content has been scrolled.  `event.detail.target` returns
       * the scrollable element which you can use to access scroll info such as
       * `scrollTop`.
       *
       *     <paper-header-panel on-content-scroll="{{scrollHandler}}">
       *       ...
       *     </paper-header-panel>
       *
       *
       *     scrollHandler: function(event) {
       *       var scroller = event.detail.target;
       *       console.log(scroller.scrollTop);
       *     }
       *
       * @event content-scroll
       */

      properties: {

        /**
         * Controls header and scrolling behavior. Options are
         * `standard`, `seamed`, `waterfall`, `waterfall-tall`, `scroll` and
         * `cover`. Default is `standard`.
         *
         * `standard`: The header is a step above the panel. The header will consume the
         * panel at the point of entry, preventing it from passing through to the
         * opposite side.
         *
         * `seamed`: The header is presented as seamed with the panel.
         *
         * `waterfall`: Similar to standard mode, but header is initially presented as
         * seamed with panel, but then separates to form the step.
         *
         * `waterfall-tall`: The header is initially taller (`tall` class is added to
         * the header).  As the user scrolls, the header separates (forming an edge)
         * while condensing (`tall` class is removed from the header).
         *
         * `scroll`: The header keeps its seam with the panel, and is pushed off screen.
         *
         * `cover`: The panel covers the whole `paper-header-panel` including the
         * header. This allows user to style the panel in such a way that the panel is
         * partially covering the header.
         *
         *     <paper-header-panel mode="cover">
         *       <paper-toolbar class="tall">
         *         <core-icon-button icon="menu"></core-icon-button>
         *       </paper-toolbar>
         *       <div class="content"></div>
         *     </paper-header-panel>
         */
        mode: {
          type: String,
          value: 'standard',
          observer: '_modeChanged',
          reflectToAttribute: true
        },

        /**
         * If true, the drop-shadow is always shown no matter what mode is set to.
         */
        shadow: {
          type: Boolean,
          value: false
        },

        /**
         * The class used in waterfall-tall mode.  Change this if the header
         * accepts a different class for toggling height, e.g. "medium-tall"
         */
        tallClass: {
          type: String,
          value: 'tall'
        },

        /**
         * If true, the scroller is at the top
         */
        atTop: {
          type: Boolean,
          value: true,
          readOnly: true
        }
      },

      observers: [
        '_computeDropShadowHidden(atTop, mode, shadow)'
      ],

      ready: function() {
        this.scrollHandler = this._scroll.bind(this);
        this._addListener();

        // Run `scroll` logic once to initialze class names, etc.
        this._keepScrollingState();
      },

      detached: function() {
        this._removeListener();
      },

      /**
       * Returns the header element
       *
       * @property header
       * @type Object
       */
      get header() {
        return Polymer.dom(this.$.headerContent).getDistributedNodes()[0];
      },

      /**
       * Returns the scrollable element.
       *
       * @property scroller
       * @type Object
       */
      get scroller() {
        return this._getScrollerForMode(this.mode);
      },

      /**
       * Returns true if the scroller has a visible shadow.
       *
       * @property visibleShadow
       * @type Boolean
       */
      get visibleShadow() {
        return this.header.classList.contains('has-shadow');
      },

      _computeDropShadowHidden: function(atTop, mode, shadow) {

        var shadowMode = MODE_CONFIGS.shadowMode[mode];

        if (this.shadow) {
          this.toggleClass('has-shadow', true, this.header);

        } else if (shadowMode === SHADOW_ALWAYS) {
          this.toggleClass('has-shadow', true, this.header);

        } else if (shadowMode === SHADOW_WHEN_SCROLLING && !atTop) {
          this.toggleClass('has-shadow', true, this.header);

        } else {
          this.toggleClass('has-shadow', false, this.header);

        }
      },

      _computeMainContainerClass: function(mode) {
        // TODO:  It will be useful to have a utility for classes
        // e.g. Polymer.Utils.classes({ foo: true });

        var classes = {};

        classes['flex'] = mode !== 'cover';

        return Object.keys(classes).filter(
          function(className) {
            return classes[className];
          }).join(' ');
      },

      _addListener: function() {
        this.scroller.addEventListener('scroll', this.scrollHandler, false);
      },

      _removeListener: function() {
        this.scroller.removeEventListener('scroll', this.scrollHandler);
      },

      _modeChanged: function(newMode, oldMode) {
        var configs = MODE_CONFIGS;
        var header = this.header;
        var animateDuration = 200;

        if (header) {
          // in tallMode it may add tallClass to the header; so do the cleanup
          // when mode is changed from tallMode to not tallMode
          if (configs.tallMode[oldMode] && !configs.tallMode[newMode]) {
            header.classList.remove(this.tallClass);
            this.async(function() {
              header.classList.remove('animate');
            }, null, animateDuration);
          } else {
            header.classList.toggle('animate', configs.tallMode[newMode]);
          }
        }
        this._keepScrollingState();
      },

      _keepScrollingState: function () {
        var main = this.scroller;
        var header = this.header;

        this._setAtTop(main.scrollTop === 0);

        if (header && MODE_CONFIGS.tallMode[this.mode]) {
          this.toggleClass(this.tallClass, this.atTop ||
              header.classList.contains(this.tallClass) &&
              main.scrollHeight < this.offsetHeight, header);
        }
      },

      _scroll: function(e) {
        this._keepScrollingState();
        this.fire('content-scroll', {target: this.scroller}, this, false);
      },

      _getScrollerForMode: function(mode) {
        return MODE_CONFIGS.outerScroll[mode] ?
            this : this.$.mainContainer;
      }

    });

  })();

</script>
<dom-module id="paper-ripple" assetpath="../bower_components/paper-ripple/">

  

  <style>
    :host {
      display: block;
      position: absolute;
      border-radius: inherit;
      overflow: hidden;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    :host([animating]) {
      /* This resolves a rendering issue in Chrome (as of 40) where the
         ripple is not properly clipped by its parent (which may have
         rounded corners). See: http://jsbin.com/temexa/4

         Note: We only apply this style conditionally. Otherwise, the browser
         will create a new compositing layer for every ripple element on the
         page, and that would be bad. */
      -webkit-transform: translate(0, 0);
      transform: translate3d(0, 0, 0);
    }

    :host([noink]) {
      pointer-events: none;
    }

    #background,
    #waves,
    .wave-container,
    .wave {
      pointer-events: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #background,
    .wave {
      opacity: 0;
    }

    #waves,
    .wave {
      overflow: hidden;
    }

    .wave-container,
    .wave {
      border-radius: 50%;
    }

    :host(.circle) #background,
    :host(.circle) #waves {
      border-radius: 50%;
    }

    :host(.circle) .wave-container {
      overflow: hidden;
    }

  </style>
  <template>
    <div id="background"></div>
    <div id="waves"></div>
  </template>
</dom-module>
<script>
  (function() {
    var Utility = {
      cssColorWithAlpha: function(cssColor, alpha) {
        var parts = cssColor.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

        if (typeof alpha == 'undefined') {
          alpha = 1;
        }

        if (!parts) {
          return 'rgba(255, 255, 255, ' + alpha + ')';
        }

        return 'rgba(' + parts[1] + ', ' + parts[2] + ', ' + parts[3] + ', ' + alpha + ')';
      },

      distance: function(x1, y1, x2, y2) {
        var xDelta = (x1 - x2);
        var yDelta = (y1 - y2);

        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
      },

      now: (function() {
        if (window.performance && window.performance.now) {
          return window.performance.now.bind(window.performance);
        }

        return Date.now;
      })()
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function ElementMetrics(element) {
      this.element = element;
      this.width = this.boundingRect.width;
      this.height = this.boundingRect.height;

      this.size = Math.max(this.width, this.height);
    }

    ElementMetrics.prototype = {
      get boundingRect () {
        return this.element.getBoundingClientRect();
      },

      furthestCornerDistanceFrom: function(x, y) {
        var topLeft = Utility.distance(x, y, 0, 0);
        var topRight = Utility.distance(x, y, this.width, 0);
        var bottomLeft = Utility.distance(x, y, 0, this.height);
        var bottomRight = Utility.distance(x, y, this.width, this.height);

        return Math.max(topLeft, topRight, bottomLeft, bottomRight);
      }
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function Ripple(element) {
      this.element = element;
      this.color = window.getComputedStyle(element).color;

      this.wave = document.createElement('div');
      this.waveContainer = document.createElement('div');
      this.wave.style.backgroundColor = this.color;
      this.wave.classList.add('wave');
      this.waveContainer.classList.add('wave-container');
      Polymer.dom(this.waveContainer).appendChild(this.wave);

      this.resetInteractionState();
    }

    Ripple.MAX_RADIUS = 300;

    Ripple.prototype = {
      get recenters() {
        return this.element.recenters;
      },

      get center() {
        return this.element.center;
      },

      get mouseDownElapsed() {
        var elapsed;

        if (!this.mouseDownStart) {
          return 0;
        }

        elapsed = Utility.now() - this.mouseDownStart;

        if (this.mouseUpStart) {
          elapsed -= this.mouseUpElapsed;
        }

        return elapsed;
      },

      get mouseUpElapsed() {
        return this.mouseUpStart ?
          Utility.now () - this.mouseUpStart : 0;
      },

      get mouseDownElapsedSeconds() {
        return this.mouseDownElapsed / 1000;
      },

      get mouseUpElapsedSeconds() {
        return this.mouseUpElapsed / 1000;
      },

      get mouseInteractionSeconds() {
        return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
      },

      get initialOpacity() {
        return this.element.initialOpacity;
      },

      get opacityDecayVelocity() {
        return this.element.opacityDecayVelocity;
      },

      get radius() {
        var width2 = this.containerMetrics.width * this.containerMetrics.width;
        var height2 = this.containerMetrics.height * this.containerMetrics.height;
        var waveRadius = Math.min(
          Math.sqrt(width2 + height2),
          Ripple.MAX_RADIUS
        ) * 1.1 + 5;

        var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
        var timeNow = this.mouseInteractionSeconds / duration;
        var size = waveRadius * (1 - Math.pow(80, -timeNow));

        return Math.abs(size);
      },

      get opacity() {
        if (!this.mouseUpStart) {
          return this.initialOpacity;
        }

        return Math.max(
          0,
          this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
        );
      },

      get outerOpacity() {
        // Linear increase in background opacity, capped at the opacity
        // of the wavefront (waveOpacity).
        var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
        var waveOpacity = this.opacity;

        return Math.max(
          0,
          Math.min(outerOpacity, waveOpacity)
        );
      },

      get isOpacityFullyDecayed() {
        return this.opacity < 0.01 &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isRestingAtMaxRadius() {
        return this.opacity >= this.initialOpacity &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isAnimationComplete() {
        return this.mouseUpStart ?
          this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
      },

      get translationFraction() {
        return Math.min(
          1,
          this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
        );
      },

      get xNow() {
        if (this.xEnd) {
          return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
        }

        return this.xStart;
      },

      get yNow() {
        if (this.yEnd) {
          return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
        }

        return this.yStart;
      },

      get isMouseDown() {
        return this.mouseDownStart && !this.mouseUpStart;
      },

      resetInteractionState: function() {
        this.maxRadius = 0;
        this.mouseDownStart = 0;
        this.mouseUpStart = 0;

        this.xStart = 0;
        this.yStart = 0;
        this.xEnd = 0;
        this.yEnd = 0;
        this.slideDistance = 0;

        this.containerMetrics = new ElementMetrics(this.element);
      },

      draw: function() {
        var scale;
        var translateString;
        var dx;
        var dy;

        this.wave.style.opacity = this.opacity;

        scale = this.radius / (this.containerMetrics.size / 2);
        dx = this.xNow - (this.containerMetrics.width / 2);
        dy = this.yNow - (this.containerMetrics.height / 2);


        // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
        // https://bugs.webkit.org/show_bug.cgi?id=98538
        this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
        this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
        this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
        this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
      },

      downAction: function(event) {
        var xCenter = this.containerMetrics.width / 2;
        var yCenter = this.containerMetrics.height / 2;

        this.resetInteractionState();
        this.mouseDownStart = Utility.now();

        if (this.center) {
          this.xStart = xCenter;
          this.yStart = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        } else {
          this.xStart = event ?
              event.detail.x - this.containerMetrics.boundingRect.left :
              this.containerMetrics.width / 2;
          this.yStart = event ?
              event.detail.y - this.containerMetrics.boundingRect.top :
              this.containerMetrics.height / 2;
        }

        if (this.recenters) {
          this.xEnd = xCenter;
          this.yEnd = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        }

        this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
          this.xStart,
          this.yStart
        );

        this.waveContainer.style.top =
          (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
        this.waveContainer.style.left =
          (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

        this.waveContainer.style.width = this.containerMetrics.size + 'px';
        this.waveContainer.style.height = this.containerMetrics.size + 'px';
      },

      upAction: function(event) {
        if (!this.isMouseDown) {
          return;
        }

        this.mouseUpStart = Utility.now();
      },

      remove: function() {
        Polymer.dom(this.waveContainer.parentNode).removeChild(
          this.waveContainer
        );
      }
    };

    Polymer({
      is: 'paper-ripple',

      behaviors: [
        Polymer.IronA11yKeysBehavior
      ],

      properties: {
        /**
         * The initial opacity set on the wave.
         *
         * @attribute initialOpacity
         * @type number
         * @default 0.25
         */
        initialOpacity: {
          type: Number,
          value: 0.25
        },

        /**
         * How fast (opacity per second) the wave fades out.
         *
         * @attribute opacityDecayVelocity
         * @type number
         * @default 0.8
         */
        opacityDecayVelocity: {
          type: Number,
          value: 0.8
        },

        /**
         * If true, ripples will exhibit a gravitational pull towards
         * the center of their container as they fade away.
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        recenters: {
          type: Boolean,
          value: false
        },

        /**
         * If true, ripples will center inside its container
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        center: {
          type: Boolean,
          value: false
        },

        /**
         * A list of the visual ripples.
         *
         * @attribute ripples
         * @type Array
         * @default []
         */
        ripples: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /**
         * True when there are visible ripples animating within the
         * element.
         */
        animating: {
          type: Boolean,
          readOnly: true,
          reflectToAttribute: true,
          value: false
        },

        /**
         * If true, the ripple will remain in the "down" state until `holdDown`
         * is set to false again.
         */
        holdDown: {
          type: Boolean,
          value: false,
          observer: '_holdDownChanged'
        },

        _animating: {
          type: Boolean
        },

        _boundAnimate: {
          type: Function,
          value: function() {
            return this.animate.bind(this);
          }
        }
      },

      get target () {
        var ownerRoot = Polymer.dom(this).getOwnerRoot();
        var target;

        if (ownerRoot) {
          target = ownerRoot.host;
        }

        if (!target) {
          target = this.parentNode;
        }

        return target;
      },

      keyBindings: {
        'enter:keydown': '_onEnterKeydown',
        'space:keydown': '_onSpaceKeydown',
        'space:keyup': '_onSpaceKeyup'
      },

      attached: function() {
        this._listen(this.target, 'up', this.upAction.bind(this));
        this._listen(this.target, 'down', this.downAction.bind(this));

        if (!this.target.hasAttribute('noink')) {
          this.keyEventTarget = this.target;
        }
      },

      get shouldKeepAnimating () {
        for (var index = 0; index < this.ripples.length; ++index) {
          if (!this.ripples[index].isAnimationComplete) {
            return true;
          }
        }

        return false;
      },

      simulatedRipple: function() {
        this.downAction(null);

        // Please see polymer/polymer#1305
        this.async(function() {
          this.upAction();
        }, 1);
      },

      downAction: function(event) {
        if (this.holdDown && this.ripples.length > 0) {
          return;
        }

        var ripple = this.addRipple();

        ripple.downAction(event);

        if (!this._animating) {
          this.animate();
        }
      },

      upAction: function(event) {
        if (this.holdDown) {
          return;
        }

        this.ripples.forEach(function(ripple) {
          ripple.upAction(event);
        });

        this.animate();
      },

      onAnimationComplete: function() {
        this._animating = false;
        this.$.background.style.backgroundColor = null;
        this.fire('transitionend');
      },

      addRipple: function() {
        var ripple = new Ripple(this);

        Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
        this.$.background.style.backgroundColor = ripple.color;
        this.ripples.push(ripple);

        this._setAnimating(true);

        return ripple;
      },

      removeRipple: function(ripple) {
        var rippleIndex = this.ripples.indexOf(ripple);

        if (rippleIndex < 0) {
          return;
        }

        this.ripples.splice(rippleIndex, 1);

        ripple.remove();

        if (!this.ripples.length) {
          this._setAnimating(false);
        }
      },

      animate: function() {
        var index;
        var ripple;

        this._animating = true;

        for (index = 0; index < this.ripples.length; ++index) {
          ripple = this.ripples[index];

          ripple.draw();

          this.$.background.style.opacity = ripple.outerOpacity;

          if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
            this.removeRipple(ripple);
          }
        }

        if (!this.shouldKeepAnimating && this.ripples.length === 0) {
          this.onAnimationComplete();
        } else {
          window.requestAnimationFrame(this._boundAnimate);
        }
      },

      _onEnterKeydown: function() {
        this.downAction();
        this.async(this.upAction, 1);
      },

      _onSpaceKeydown: function() {
        this.downAction();
      },

      _onSpaceKeyup: function() {
        this.upAction();
      },

      _holdDownChanged: function(holdDown) {
        if (holdDown) {
          this.downAction();
        } else {
          this.upAction();
        }
      }
    });
  })();
</script>
<dom-module id="paper-icon-button" assetpath="../bower_components/paper-icon-button/">
  <style>

    :host {
      display: inline-block;
      position: relative;
      padding: 8px;
      outline: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      cursor: pointer;
      z-index: 0;

      @apply(--paper-icon-button);
    }

    :host #ink {
      color: var(--paper-icon-button-ink-color, --primary-text-color);
      opacity: 0.6;
    }

    :host([disabled]) {
      color: var(--paper-icon-button-disabled-text, #fff);
      pointer-events: none;
      cursor: auto;
      @apply(--paper-icon-button-disabled);
    }
  </style>
  <template>
    <paper-ripple id="ink" class="circle" center=""></paper-ripple>
    <iron-icon id="icon" src="[[src]]" icon="[[icon]]"></iron-icon>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'paper-icon-button',

    behaviors: [
      Polymer.PaperButtonBehavior,
      Polymer.PaperInkyFocusBehavior
    ],

    properties: {
      /**
       * The URL of an image for the icon. If the src property is specified,
       * the icon property should not be.
       */
      src: {
        type: String
      },

      /**
       * Specifies the icon name or index in the set of icons available in
       * the icon's icon set. If the icon property is specified,
       * the src property should not be.
       */
      icon: {
        type: String
      }
    }
  });
</script>
<dom-module id="paper-item" assetpath="../bower_components/paper-item/">

  <style>
/*
    @license
    Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

:host {
  display: block;
  min-height: var(--paper-item-min-height, 48px);
  padding: 0px 16px;
}

:host > ::content > *:not(:first-child):not(:last-child) {
  margin-right: 16px;
}

</style>

  <style>

    :host {
      @apply(--layout-horizontal);
      @apply(--layout-center);
      @apply(--paper-font-subhead);

      @apply(--paper-item);
    }

  </style>

  <template>
    <content></content>
  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-item',

    hostAttributes: {
      role: 'listitem'
    }

  });

})();

</script>
<dom-module id="paper-material" assetpath="../bower_components/paper-material/">
  <style>
    :host {
      display: block;
      position: relative;
      @apply(--shadow-transition);
    }

    :host([elevation="1"]) {
      @apply(--shadow-elevation-2dp);
    }

    :host([elevation="2"]) {
      @apply(--shadow-elevation-4dp);
    }

    :host([elevation="3"]) {
      @apply(--shadow-elevation-6dp);
    }

    :host([elevation="4"]) {
      @apply(--shadow-elevation-8dp);
    }

    :host([elevation="5"]) {
      @apply(--shadow-elevation-16dp);
    }
  </style>
  <template>
    <content></content>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'paper-material',

    properties: {

      /**
       * The z-depth of this element, from 0-5. Setting to 0 will remove the
       * shadow, and each increasing number greater than 0 will be "deeper"
       * than the last.
       *
       * @attribute elevation
       * @type number
       * @default 1
       */
      elevation: {
        type: Number,
        reflectToAttribute: true,
        value: 1
      },

      /**
       * Set this to true to animate the shadow when setting a new
       * `elevation` value.
       *
       * @attribute animated
       * @type boolean
       * @default false
       */
      animated: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    }
  });
</script>
<dom-module id="paper-menu" assetpath="../bower_components/paper-menu/">

  <style>

    :host {
      display: block;
      padding: 8px 0;

      background: var(--paper-menu-background-color, --primary-background-color);
      color: var(--paper-menu-color, --primary-text-color);

      @apply(--paper-menu);
    }

    /* need a wrapper element to make this higher specificity than the :host rule in paper-item */
    .content > ::content > .iron-selected {
      font-weight: bold;

      @apply(--paper-menu-selected-item);
    }

    .content > ::content > [disabled] {
      color: var(--paper-menu-disabled-color, --disabled-text-color);
    }

    .content > ::content > *:focus {
      position: relative;
      outline: 0;

      @apply(--paper-menu-colored-focused-item);
    }

    .content > ::content > *:focus:after {
      @apply(--layout-fit);
      background: currentColor;
      /* FIXME move to paper-styles for next widget */
      opacity: 0.12;
      content: '';

      @apply(--paper-menu-colored-focused-item-after);
    }

    .content > ::content > *[colored]:focus:after {
      opacity: 0.26;
    }

  </style>

  <template>

    <div class="content">
      <content></content>
    </div>

  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-menu',

    behaviors: [
      Polymer.IronMenuBehavior
    ]

  });

})();

</script>
<dom-module id="iron-a11y-announcer" assetpath="../bower_components/iron-a11y-announcer/">
  <style>
    :host {
      display: inline-block;
      position: fixed;
      clip: rect(0px,0px,0px,0px);
    }
  </style>

  <template>
    <span aria-live$="[[mode]]">[[_text]]</span>
  </template>

  <script>

    (function() {
      'use strict';

      Polymer.IronA11yAnnouncer = Polymer({
        is: 'iron-a11y-announcer',

        properties: {

          /**
           * The value of mode is used to set the `aria-live` attribute
           * for the element that will be announced. Valid values are: `off`,
           * `polite` and `assertive`.
           */
          mode: {
            type: String,
            value: 'polite'
          },

          _text: {
            type: String,
            value: ''
          }
        },

        created: function() {
          if (!Polymer.IronA11yAnnouncer.instance) {
            Polymer.IronA11yAnnouncer.instance = this;
          }

          document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
        },

        /**
         * Cause a text string to be announced by screen readers.
         *
         * @param {string} text The text that should be announced.
         */
        announce: function(text) {
          this._text = '';
          this.async(function() {
            this._text = text;
          }, 100);
        },

        _onIronAnnounce: function(event) {
          if (event.detail && event.detail.text) {
            this.announce(event.detail.text);
          }
        }
      });

      Polymer.IronA11yAnnouncer.instance = null;

      Polymer.IronA11yAnnouncer.requestAvailability = function() {
        if (!Polymer.IronA11yAnnouncer.instance) {
          document.createElement('iron-a11y-announcer');
        }

        document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
      };
    })();

  </script>
</dom-module>
<dom-module id="paper-toast" assetpath="../bower_components/paper-toast/">
  <style>
    :host {
      display: inline-block;
      position: fixed;

      background: #323232;
      color: #f1f1f1;
      min-height: 48px;
      min-width: 288px;
      padding: 16px 24px 12px;
      box-sizing: border-box;
      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
      border-radius: 2px;
      bottom: 12px;
      left: 12px;
      font-size: 14px;
      cursor: default;

      -webkit-transition: visibility 0.3s, -webkit-transform 0.3s;
      transition: visibility 0.3s, transform 0.3s;

      -webkit-transform: translateY(100px);
      transform: translateY(100px);

      visibility: hidden;
    }

    :host(.capsule) {
      border-radius: 24px;
    }

    :host(.fit-bottom) {
      bottom: 0;
      left: 0;
      width: 100%;
      min-width: 0;
      border-radius: 0;
    }

    :host(.paper-toast-open){
      visibility: visible;

      -webkit-transform: translateY(0px);
      transform: translateY(0px);
    }
  </style>
  <template>
    <span id="label">{{text}}</span>
    <content></content>
  </template>
</dom-module>
<script>
(function() {

  var PaperToast = Polymer({
    is: 'paper-toast',

    properties: {
      /**
       * The duration in milliseconds to show the toast.
       */
      duration: {
        type: Number,
        value: 3000
      },

      /**
       * The text to display in the toast.
       */
      text: {
        type: String,
        value: ""
      },

      /**
       * True if the toast is currently visible.
       */
      visible: {
        type: Boolean,
        readOnly: true,
        value: false,
        observer: '_visibleChanged'
      }
    },

    created: function() {
      Polymer.IronA11yAnnouncer.requestAvailability();
    },

    ready: function() {
      this.async(function() {
        this.hide();
      });
    },

    /**
     * Show the toast.
     * @method show
     */
    show: function() {
      if (PaperToast.currentToast) {
        PaperToast.currentToast.hide();
      }
      PaperToast.currentToast = this;
      this.removeAttribute('aria-hidden');
      this._setVisible(true);
      this.fire('iron-announce', {
        text: this.text
      });
      this.debounce('hide', this.hide, this.duration);
    },

    /**
     * Hide the toast
     */
    hide: function() {
      this.setAttribute('aria-hidden', 'true');
      this._setVisible(false);
    },

    /**
     * Toggle the opened state of the toast.
     * @method toggle
     */
    toggle: function() {
      if (!this.visible) {
        this.show();
      } else {
        this.hide();
      }
    },

    _visibleChanged: function(visible) {
      this.toggleClass('paper-toast-open', visible);
    }
  });

  PaperToast.currentToast = null;

})();
</script>
<dom-module id="paper-toolbar" assetpath="../bower_components/paper-toolbar/">

  <style>
    :host {
      /* technical */
      display: block;
      position: relative;
      box-sizing: border-box;
      -moz-box-sizing: border-box;

      /* size */
      height: 64px;

      background: var(--paper-toolbar-background, --default-primary-color);
      color: var(--paper-toolbar-color, --text-primary-color);

      @apply(--paper-toolbar);
    }

    :host(.animate) {
      /* transition */
      transition: height 0.18s ease-in;
    }

    :host(.medium-tall) {
      height: 128px;
    }

    :host(.tall) {
      height: 192px;
    }

    .toolbar-tools {
      position: relative;
      height: 64px;
      padding: 0 16px;
      pointer-events: none;
    }

    /*
     * TODO: Where should media query breakpoints live so they can be shared between elements?
     */

    @media (max-width: 639px) {
      :host {
        height: 56px;
      }

      :host(.medium-tall) {
        height: 112px;
      }

      :host(.tall) {
        height: 168px;
      }

      .toolbar-tools {
        height: 56px;
      }
    }

    #topBar {
      position: relative;
    }

    /* middle bar */
    #middleBar {
      position: absolute;
      top: 0;
      right: 0;
      left: 0;
    }

    :host(.tall) #middleBar,
    :host(.medium-tall) #middleBar {
      -webkit-transform: translateY(100%);
      transform: translateY(100%);
    }

    /* bottom bar */
    #bottomBar {
      position: absolute;
      right: 0;
      bottom: 0;
      left: 0;
    }

    /*
     * make elements (e.g. buttons) respond to mouse/touch events
     *
     * `.toolbar-tools` disables touch events so multiple toolbars can stack and not
     * absorb events. All children must have pointer events re-enabled to work as
     * expected.
     */
    .toolbar-tools > ::content > *:not([disabled]) {
      pointer-events: auto;
    }

    .toolbar-tools > ::content .title {
      @apply(--paper-font-title);
      @apply(--layout-flex);

      pointer-events: none;
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;

      /*
       * Polymer/polymer/issues/1525
       * --paper-font-title defines a `font-weight`
       * let's override its value, but we need `important!`
       * because all mixins are resolved in rule's selector that has higher precedence
       * than the current selector.
       */
      font-weight: 400 !important;
    }

    /**
     * TODO: Refactor these selectors
     * Work in progress.
     */
    .toolbar-tools > ::content paper-icon-button[icon=menu] {
      margin-right: 24px;
    }

    .toolbar-tools > ::content > .title,
    .toolbar-tools > ::content[select=".middle"] > .title,
    .toolbar-tools > ::content[select=".bottom"] > .title {
      margin-left: 56px;
    }

    .toolbar-tools > ::content > paper-icon-button + .title,
    .toolbar-tools > ::content[select=".middle"] paper-icon-button + .title,
    .toolbar-tools > ::content[select=".bottom"] paper-icon-button + .title {
      margin-left: 0;
    }
  </style>

  <template>

    <div id="topBar" class$="[[_computeBarClassName(justify)]]">
      <content select=":not(.middle):not(.bottom)"></content>
    </div>

    <div id="middleBar" class$="[[_computeBarClassName(middleJustify)]]">
      <content select=".middle"></content>
    </div>

    <div id="bottomBar" class$="[[_computeBarClassName(bottomJustify)]]">
      <content select=".bottom"></content>
    </div>

  </template>

</dom-module>

<script>

  (function() {

    'use strict';

    function classNames(obj) {
      var classNames = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key]) {
          classNames.push(key);
        }
      }

      return classNames.join(' ');
    }

    Polymer({

      is: 'paper-toolbar',

      hostAttributes: {
        'role': 'toolbar'
      },

      properties: {

        /**
         * Controls how the items are aligned horizontally when they are placed
         * at the bottom.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute bottomJustify
         * @type string
         * @default ''
         */
        bottomJustify: {
          type: String,
          value: ''
        },

        /**
         * Controls how the items are aligned horizontally.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute justify
         * @type string
         * @default ''
         */
        justify: {
          type: String,
          value: ''
        },

        /**
         * Controls how the items are aligned horizontally when they are placed
         * in the middle.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute middleJustify
         * @type string
         * @default ''
         */
        middleJustify: {
          type: String,
          value: ''
        }

      },

      attached: function() {
        this._observer = this._observe(this);
        this._updateAriaLabelledBy();
      },

      detached: function() {
        if (this._observer) {
          this._observer.disconnect();
        }
      },

      _observe: function(node) {
        var observer = new MutationObserver(function() {
          this._updateAriaLabelledBy();
        }.bind(this));
        observer.observe(node, {
          childList: true,
          subtree: true
        });
        return observer;
      },

      _updateAriaLabelledBy: function() {
        var labelledBy = [];
        var contents = Polymer.dom(this.root).querySelectorAll('content');
        for (var content, index = 0; content = contents[index]; index++) {
          var nodes = Polymer.dom(content).getDistributedNodes();
          for (var node, jndex = 0; node = nodes[jndex]; jndex++) {
            if (node.classList && node.classList.contains('title')) {
              if (node.id) {
                labelledBy.push(node.id);
              } else {
                var id = 'paper-toolbar-label-' + Math.floor(Math.random() * 10000);
                node.id = id;
                labelledBy.push(id);
              }
            }
          }
        }
        if (labelledBy.length > 0) {
          this.setAttribute('aria-labelledby', labelledBy.join(' '));
        }
      },

      _computeBarClassName: function(barJustify) {
        var classObj = {
          center: true,
          horizontal: true,
          layout: true,
          'toolbar-tools': true
        };

        // If a blank string or any falsy value is given, no other class name is
        // added.
        if (barJustify) {
          var justifyClassName = (barJustify === 'justified') ?
              barJustify :
              barJustify + '-justified';

          classObj[justifyClassName] = true;
        }

        return classNames(classObj);
      }

    });

  }());

</script>
<dom-module id="paper-button" assetpath="../bower_components/paper-button/">

  <style>

    :host {
      display: inline-block;
      position: relative;
      box-sizing: border-box;
      min-width: 5.14em;
      margin: 0 0.29em;
      background: transparent;
      text-align: center;
      font: inherit;
      text-transform: uppercase;
      outline: none;
      border-radius: 3px;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: pointer;
      z-index: 0;

      @apply(--paper-button);
    }

    .keyboard-focus {
      font-weight: bold;
    }

    :host([disabled]) {
      background: #eaeaea;
      color: #a8a8a8;
      cursor: auto;
      pointer-events: none;

      @apply(--paper-button-disabled);
    }

    :host([noink]) paper-ripple {
      display: none;
    }

    paper-material {
      border-radius: inherit;
    }

    .content > ::content * {
      text-transform: inherit;
    }

    .content {
      padding: 0.7em 0.57em
    }
  </style>

  <template>

    <paper-ripple></paper-ripple>

    <paper-material class$="[[_computeContentClass(receivedFocusFromKeyboard)]]" elevation="[[_elevation]]" animated="">
      <content></content>
    </paper-material>

  </template>

</dom-module>

<script>

  Polymer({

    is: 'paper-button',

    behaviors: [
      Polymer.PaperButtonBehavior
    ],

    properties: {

      /**
       * If true, the button should be styled with a shadow.
       */
      raised: {
        type: Boolean,
        reflectToAttribute: true,
        value: false,
        observer: '_calculateElevation'
      }
    },

    _calculateElevation: function() {
      if (!this.raised) {
        this._elevation = 0;
      } else {
        Polymer.PaperButtonBehaviorImpl._calculateElevation.apply(this);
      }
    },

    _computeContentClass: function(receivedFocusFromKeyboard) {
      var className = 'content ';
      if (receivedFocusFromKeyboard) {
        className += ' keyboard-focus';
      }
      return className;
    }
  });

</script>
<dom-module id="paper-fab" assetpath="../bower_components/paper-fab/">
  <style>

    :host {
      display: inline-block;
      position: relative;
      outline: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: pointer;

      box-sizing: border-box;
      min-width: 0;
      width: 56px;
      height: 56px;
      background: var(--paper-fab-background, --paper-indigo-500);
      color: var(--text-primary-color);
      border-radius: 50%;
      padding: 16px;

      z-index: 0;

      @apply(--paper-fab);
    }

    :host([mini]) {
      width: 40px;
      height: 40px;
      padding: 8px;

      @apply(--paper-fab-mini);
    }

    :host([disabled]) {
      color: var(--paper-fab-disabled-text, --paper-grey-500);
      background: var(--paper-fab-disabled-background, --paper-grey-300);
      @apply(--paper-fab-disabled);
    }

    paper-material {
      border-radius: inherit;
    }
  </style>
  <template>
    <paper-ripple></paper-ripple>
    <paper-material class="content fit flex layout vertical center-center" elevation="[[elevation]]" animated="">
      <iron-icon id="icon" src="[[src]]" icon="[[icon]]"></iron-icon>
    </paper-material>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'paper-fab',

    behaviors: [
      Polymer.PaperButtonBehavior
    ],

    properties: {
      /**
       * The URL of an image for the icon. If the src property is specified,
       * the icon property should not be.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: {
        type: String,
        value: ''
      },

      /**
       * Specifies the icon name or index in the set of icons available in
       * the icon's icon set. If the icon property is specified,
       * the src property should not be.
       *
       * @attribute icon
       * @type string
       * @default ''
       */
      icon: {
        type: String,
        value: ''
      },

      /**
       * Set this to true to style this is a "mini" FAB.
       *
       * @attribute mini
       * @type boolean
       * @default false
       */
      mini: {
        type: Boolean,
        value: false
      }
    }

  });
</script>
<dom-module id="paper-spinner" assetpath="../bower_components/paper-spinner/">

  <style>
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

*/
/**************************/
/* STYLES FOR THE SPINNER */
/**************************/

/*
 * Constants:
 *      STROKEWIDTH = 3px
 *      ARCSIZE     = 270 degrees (amount of circle the arc takes up)
 *      ARCTIME     = 1333ms (time it takes to expand and contract arc)
 *      ARCSTARTROT = 216 degrees (how much the start location of the arc
 *                                should rotate each time, 216 gives us a
 *                                5 pointed star shape (it's 360/5 * 3).
 *                                For a 7 pointed star, we might do
 *                                360/7 * 3 = 154.286)
 *      CONTAINERWIDTH = 28px
 *      SHRINK_TIME = 400ms
 */

 :host {
  display: inline-block;
  position: relative;
  width: 28px; /* CONTAINERWIDTH */
  height: 28px; /* CONTAINERWIDTH */
}

#spinnerContainer {
  width: 100%;
  height: 100%;
}

#spinnerContainer.active {
  /* duration: 360 * ARCTIME / (ARCSTARTROT + (360-ARCSIZE)) */
  -webkit-animation: container-rotate 1568ms linear infinite;
  animation: container-rotate 1568ms linear infinite;
}

@-webkit-keyframes container-rotate {
  to { -webkit-transform: rotate(360deg) }
}

@keyframes container-rotate {
  to { transform: rotate(360deg) }
}

.spinner-layer {
  position: absolute;
  width: 100%;
  height: 100%;
  opacity: 0;
}

.layer-1 {
  border-color: var(--paper-spinner-layer-1-color, --google-blue-500);
}

.layer-2 {
  border-color: var(--paper-spinner-layer-2-color, --google-red-500);
}

.layer-3 {
  border-color: var(--paper-spinner-layer-3-color, --google-yellow-500);
}

.layer-4 {
  border-color: var(--paper-spinner-layer-4-color, --google-blue-500);
}

/**
 * IMPORTANT NOTE ABOUT CSS ANIMATION PROPERTIES (keanulee):
 *
 * iOS Safari (tested on iOS 8.1) does not handle animation-delay very well - it doesn't
 * guarantee that the animation will start _exactly_ after that value. So we avoid using
 * animation-delay and instead set custom keyframes for each color (as layer-2undant as it
 * seems).
 *
 * We write out each animation in full (instead of separating animation-name,
 * animation-duration, etc.) because under the polyfill, Safari does not recognize those
 * specific properties properly, treats them as -webkit-animation, and overrides the
 * other animation rules. See https://github.com/Polymer/platform/issues/53.
 */
.active .spinner-layer.layer-1 {
  /* durations: 4 * ARCTIME */
  -webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-1-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
  animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-1-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
}

.active .spinner-layer.layer-2 {
  /* durations: 4 * ARCTIME */
  -webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-2-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
  animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-2-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
}

.active .spinner-layer.layer-3 {
  /* durations: 4 * ARCTIME */
  -webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-3-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
  animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-3-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
}

.active .spinner-layer.layer-4 {
  /* durations: 4 * ARCTIME */
  -webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-4-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
  animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-4-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
}

@-webkit-keyframes fill-unfill-rotate {
  12.5% { -webkit-transform: rotate(135deg);  } /* 0.5 * ARCSIZE */
  25%   { -webkit-transform: rotate(270deg);  } /* 1   * ARCSIZE */
  37.5% { -webkit-transform: rotate(405deg);  } /* 1.5 * ARCSIZE */
  50%   { -webkit-transform: rotate(540deg);  } /* 2   * ARCSIZE */
  62.5% { -webkit-transform: rotate(675deg);  } /* 2.5 * ARCSIZE */
  75%   { -webkit-transform: rotate(810deg);  } /* 3   * ARCSIZE */
  87.5% { -webkit-transform: rotate(945deg);  } /* 3.5 * ARCSIZE */
  to    { -webkit-transform: rotate(1080deg); } /* 4   * ARCSIZE */
}

@keyframes fill-unfill-rotate {
  12.5% { transform: rotate(135deg);  } /* 0.5 * ARCSIZE */
  25%   { transform: rotate(270deg);  } /* 1   * ARCSIZE */
  37.5% { transform: rotate(405deg);  } /* 1.5 * ARCSIZE */
  50%   { transform: rotate(540deg);  } /* 2   * ARCSIZE */
  62.5% { transform: rotate(675deg);  } /* 2.5 * ARCSIZE */
  75%   { transform: rotate(810deg);  } /* 3   * ARCSIZE */
  87.5% { transform: rotate(945deg);  } /* 3.5 * ARCSIZE */
  to    { transform: rotate(1080deg); } /* 4   * ARCSIZE */
}

/**
 * HACK: Even though the intention is to have the current .spinner-layer at
 * `opacity: 1`, we set it to `opacity: 0.99` instead since this forces Chrome
 * to do proper subpixel rendering for the elements being animated. This is
 * especially visible in Chrome 39 on Ubuntu 14.04. See:
 *
 * - https://github.com/Polymer/paper-spinner/issues/9
 * - https://code.google.com/p/chromium/issues/detail?id=436255
 */
@-webkit-keyframes layer-1-fade-in-out {
  from { opacity: 0.99; }
  25% { opacity: 0.99; }
  26% { opacity: 0; }
  89% { opacity: 0; }
  90% { opacity: 0.99; }
  100% { opacity: 0.99; }
}

@keyframes layer-1-fade-in-out {
  from { opacity: 0.99; }
  25% { opacity: 0.99; }
  26% { opacity: 0; }
  89% { opacity: 0; }
  90% { opacity: 0.99; }
  100% { opacity: 0.99; }
}

@-webkit-keyframes layer-2-fade-in-out {
  from { opacity: 0; }
  15% { opacity: 0; }
  25% { opacity: 0.99; }
  50% { opacity: 0.99; }
  51% { opacity: 0; }
}

@keyframes layer-2-fade-in-out {
  from { opacity: 0; }
  15% { opacity: 0; }
  25% { opacity: 0.99; }
  50% { opacity: 0.99; }
  51% { opacity: 0; }
}

@-webkit-keyframes layer-3-fade-in-out {
  from { opacity: 0; }
  40% { opacity: 0; }
  50% { opacity: 0.99; }
  75% { opacity: 0.99; }
  76% { opacity: 0; }
}

@keyframes layer-3-fade-in-out {
  from { opacity: 0; }
  40% { opacity: 0; }
  50% { opacity: 0.99; }
  75% { opacity: 0.99; }
  76% { opacity: 0; }
}

@-webkit-keyframes layer-4-fade-in-out {
  from { opacity: 0; }
  65% { opacity: 0; }
  75% { opacity: 0.99; }
  90% { opacity: 0.99; }
  100% { opacity: 0; }
}

@keyframes layer-4-fade-in-out {
  from { opacity: 0; }
  65% { opacity: 0; }
  75% { opacity: 0.99; }
  90% { opacity: 0.99; }
  100% { opacity: 0; }
}

/**
 * Patch the gap that appear between the two adjacent div.circle-clipper while the
 * spinner is rotating (appears on Chrome 38, Safari 7.1, and IE 11).
 *
 * Update: the gap no longer appears on Chrome when .spinner-layer's opacity is 0.99,
 * but still does on Safari and IE.
 */
.gap-patch {
  position: absolute;
  box-sizing: border-box;
  top: 0;
  left: 45%;
  width: 10%;
  height: 100%;
  overflow: hidden;
  border-color: inherit;
}

.gap-patch .circle {
  width: 1000%;
  left: -450%;
}

.circle-clipper {
  display: inline-block;
  position: relative;
  width: 50%;
  height: 100%;
  overflow: hidden;
  border-color: inherit;
}

.circle-clipper .circle {
  width: 200%;
}

.circle {
  box-sizing: border-box;
  height: 100%;
  border-width: 3px; /* STROKEWIDTH */
  border-style: solid;
  border-color: inherit;
  border-bottom-color: transparent !important;
  border-radius: 50%;
  -webkit-animation: none;
  animation: none;

  @apply(--layout-fit);
}

.circle-clipper.left .circle {
  border-right-color: transparent !important;
  -webkit-transform: rotate(129deg);
  transform: rotate(129deg);
}

.circle-clipper.right .circle {
  left: -100%;
  border-left-color: transparent !important;
  -webkit-transform: rotate(-129deg);
  transform: rotate(-129deg);
}

.active .circle-clipper.left .circle {
  /* duration: ARCTIME */
  -webkit-animation: left-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
  animation: left-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
}

.active .circle-clipper.right .circle {
  /* duration: ARCTIME */
  -webkit-animation: right-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
  animation: right-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
}

@-webkit-keyframes left-spin {
  from { -webkit-transform: rotate(130deg); }
  50% { -webkit-transform: rotate(-5deg); }
  to { -webkit-transform: rotate(130deg); }
}

@keyframes left-spin {
  from { transform: rotate(130deg); }
  50% { transform: rotate(-5deg); }
  to { transform: rotate(130deg); }
}

@-webkit-keyframes right-spin {
  from { -webkit-transform: rotate(-130deg); }
  50% { -webkit-transform: rotate(5deg); }
  to { -webkit-transform: rotate(-130deg); }
}

@keyframes right-spin {
  from { transform: rotate(-130deg); }
  50% { transform: rotate(5deg); }
  to { transform: rotate(-130deg); }
}

#spinnerContainer.cooldown {
  /* duration: SHRINK_TIME */
  -webkit-animation: container-rotate 1568ms linear infinite, fade-out 400ms cubic-bezier(0.4, 0.0, 0.2, 1);
  animation: container-rotate 1568ms linear infinite, fade-out 400ms cubic-bezier(0.4, 0.0, 0.2, 1);
}

@-webkit-keyframes fade-out {
  from { opacity: 0.99; }
  to { opacity: 0; }
}

@keyframes fade-out {
  from { opacity: 0.99; }
  to { opacity: 0; }
}

</style>

  <template>

    <div id="spinnerContainer" class-name="[[_spinnerContainerClassName]]">
      <div class="spinner-layer layer-1">
        <div class="circle-clipper left">
          <div class="circle"></div>
        </div><div class="gap-patch">
          <div class="circle"></div>
        </div><div class="circle-clipper right">
          <div class="circle"></div>
        </div>
      </div>

      <div class="spinner-layer layer-2">
        <div class="circle-clipper left">
          <div class="circle"></div>
        </div><div class="gap-patch">
          <div class="circle"></div>
        </div><div class="circle-clipper right">
          <div class="circle"></div>
        </div>
      </div>

      <div class="spinner-layer layer-3">
        <div class="circle-clipper left">
          <div class="circle"></div>
        </div><div class="gap-patch">
          <div class="circle"></div>
        </div><div class="circle-clipper right">
          <div class="circle"></div>
        </div>
      </div>

      <div class="spinner-layer layer-4">
        <div class="circle-clipper left">
          <div class="circle"></div>
        </div><div class="gap-patch">
          <div class="circle"></div>
        </div><div class="circle-clipper right">
          <div class="circle"></div>
        </div>
      </div>
    </div>

  </template>

  <script>

    (function() {

      'use strict';

      function classNames(obj) {
        var classNames = [];
        for (var key in obj) {
          if (obj.hasOwnProperty(key) && obj[key]) {
            classNames.push(key);
          }
        }

        return classNames.join(' ');
      }

      Polymer({

        is: 'paper-spinner',

        listeners: {
          'animationend': 'reset',
          'webkitAnimationEnd': 'reset'
        },

        properties: {

          /**
           * Displays the spinner.
           *
           * @attribute active
           * @type boolean
           * @default false
           */
          active: {
            observer: '_activeChanged',
            type: Boolean,
            value: false
          },

          /**
           * Alternative text content for accessibility support.
           * If alt is present, it will add an aria-label whose content matches alt when active.
           * If alt is not present, it will default to 'loading' as the alt value.
           *
           * @attribute alt
           * @type string
           * @default 'loading'
           */
          alt: {
            observer: '_altChanged',
            type: String,
            value: 'loading'
          },

          /**
           * True when the spinner is going from active to inactive. This is represented by a fade
           * to 0% opacity to the user.
           */
          _coolingDown: {
            type: Boolean,
            value: false
          },

          _spinnerContainerClassName: {
            type: String,
            computed: '_computeSpinnerContainerClassName(active, _coolingDown)'
          }

        },

        _computeSpinnerContainerClassName: function(active, _coolingDown) {
          return classNames({
            active: active || _coolingDown,
            cooldown: _coolingDown
          });
        },

        ready: function() {
          // Allow user-provided `aria-label` take preference to any other text alternative.
          if (this.hasAttribute('aria-label')) {
            this.alt = this.getAttribute('aria-label');
          } else {
            this.setAttribute('aria-label', this.alt);
          }

          if (!this.active) {
            this.setAttribute('aria-hidden', 'true');
          }
        },

        _activeChanged: function() {
          if (this.active) {
            this.removeAttribute('aria-hidden');
          } else {
            this._coolingDown = true;
            this.setAttribute('aria-hidden', 'true');
          }
        },

        _altChanged: function() {
          if (this.alt === '') {
            this.setAttribute('aria-hidden', 'true');
          } else {
            this.removeAttribute('aria-hidden');
          }

          this.setAttribute('aria-label', this.alt);
        },

        reset: function() {
          this.active = false;
          this._coolingDown = false;
        }

      });

    }());

  </script>

</dom-module>
<iron-iconset-svg name="paper-tabs" size="24">
<svg><defs>
<g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
<g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
</defs></svg>
</iron-iconset-svg>
<dom-module id="paper-tab" assetpath="../bower_components/paper-tabs/">

  <style>

    :host {
      @apply(--layout-inline);
      @apply(--layout-center);
      @apply(--layout-center-justified);
      @apply(--layout-flex);

      position: relative;
      padding: 0 12px;
      overflow: hidden;
      cursor: pointer;

      @apply(--paper-tab);
    }

    :host(:focus) {
      outline: none;
    }

    :host([link]) {
      padding: 0;
    }

    .tab-content {
      height: 100%;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      transition: opacity 0.1s cubic-bezier(0.4, 0.0, 1, 1);

      @apply(--paper-tab-content);
    }

    :host(:not(.iron-selected)) > .tab-content {
      opacity: 0.8;
    }

    :host(:focus) .tab-content {
      opacity: 1;
      font-weight: 700;
    }

    #ink {
      color: var(--paper-tab-ink, --paper-yellow-a100);
      pointer-events: none;
    }

    .tab-content > ::content > a {
      height: 100%;
      /* flex */
      -ms-flex: 1 1 0.000000001px;
      -webkit-flex: 1;
      flex: 1;
      -webkit-flex-basis: 0.000000001px;
      flex-basis: 0.000000001px;
    }

  </style>

  <template>

    <div class="tab-content flex-auto center-center horizontal layout">
      <content></content>
    </div>

    <template is="dom-if" if="[[!noink]]">
      <paper-ripple id="ink" initial-opacity="0.95" opacity-decay-velocity="0.98"></paper-ripple>
    </template>

  </template>

</dom-module>

<script>

  Polymer({

    is: 'paper-tab',

    behaviors: [
      Polymer.IronControlState
    ],

    properties: {

      /**
       * If true, ink ripple effect is disabled.
       *
       * @attribute noink
       */
      noink: {
        type: Boolean,
        value: false
      }

    },

    hostAttributes: {
      role: 'tab'
    },

    listeners: {
      down: '_onDown'
    },

    get _parentNoink () {
      var parent = Polymer.dom(this).parentNode;
      return !!parent && !!parent.noink;
    },

    _onDown: function(e) {
      this.noink = !!this.noink || !!this._parentNoink;
    }
  });

</script>
<dom-module id="paper-tabs" assetpath="../bower_components/paper-tabs/">

  <style>

    :host {
      @apply(--layout);
      @apply(--layout-center);

      height: 48px;
      font-size: 14px;
      font-weight: 500;
      overflow: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);

      @apply(--paper-tabs);
    }

    #tabsContainer {
      position: relative;
      height: 100%;
      white-space: nowrap;
      overflow: hidden;
    }

    #tabsContent {
      height: 100%;
    }

    #tabsContent.scrollable {
      position: absolute;
      white-space: nowrap;
    }

    .hidden {
      display: none;
    }

    .not-visible {
      opacity: 0;
    }

    paper-icon-button {
      width: 24px;
      padding: 16px;
    }

    #selectionBar {
      position: absolute;
      height: 2px;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: var(--paper-tabs-selection-bar-color, --paper-yellow-a100);
      -webkit-transform-origin: left center;
      transform-origin: left center;
      -webkit-transform: scale(0);
      transform: scale(0);
      transition: -webkit-transform;
      transition: transform;

      @apply(--paper-tabs-selection-bar);
    }

    #selectionBar.align-bottom {
      top: 0;
      bottom: auto;
    }

    #selectionBar.expand {
      transition-duration: 0.15s;
      transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
    }

    #selectionBar.contract {
      transition-duration: 0.18s;
      transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
    }

    #tabsContent > ::content > *:not(#selectionBar) {
      height: 100%;
    }

  </style>

  <template>

    <paper-icon-button icon="paper-tabs:chevron-left" class$="[[_computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons)]]" on-up="_onScrollButtonUp" on-down="_onLeftScrollButtonDown"></paper-icon-button>

    <div id="tabsContainer" class="flex" on-scroll="_scroll">

      <div id="tabsContent" class$="[[_computeTabsContentClass(scrollable)]]">

        <content select="*"></content>

        <div id="selectionBar" class$="[[_computeSelectionBarClass(noBar, alignBottom)]]" on-transitionend="_onBarTransitionEnd"></div>

      </div>

    </div>

    <paper-icon-button icon="paper-tabs:chevron-right" class$="[[_computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons)]]" on-up="_onScrollButtonUp" on-down="_onRightScrollButtonDown"></paper-icon-button>

  </template>

</dom-module>

<script>

  Polymer({

    is: 'paper-tabs',

    behaviors: [
      Polymer.IronResizableBehavior,
      Polymer.IronMenubarBehavior
    ],

    properties: {

      /**
       * If true, ink ripple effect is disabled.
       */
      noink: {
        type: Boolean,
        value: false
      },

      /**
       * If true, the bottom bar to indicate the selected tab will not be shown.
       */
      noBar: {
        type: Boolean,
        value: false
      },

      /**
       * If true, the slide effect for the bottom bar is disabled.
       */
      noSlide: {
        type: Boolean,
        value: false
      },

      /**
       * If true, tabs are scrollable and the tab width is based on the label width.
       */
      scrollable: {
        type: Boolean,
        value: false
      },

      /**
       * If true, dragging on the tabs to scroll is disabled.
       */
      disableDrag: {
        type: Boolean,
        value: false
      },

      /**
       * If true, scroll buttons (left/right arrow) will be hidden for scrollable tabs.
       */
      hideScrollButtons: {
        type: Boolean,
        value: false
      },

      /**
       * If true, the tabs are aligned to bottom (the selection bar appears at the top).
       */
      alignBottom: {
        type: Boolean,
        value: false
      },

      /**
       * Gets or sets the selected element. The default is to use the index of the item.
       */
      selected: {
        type: String,
        notify: true
      },

      selectable: {
        type: String,
        value: 'paper-tab'
      },

      _step: {
        type: Number,
        value: 10
      },

      _holdDelay: {
        type: Number,
        value: 1
      },

      _leftHidden: {
        type: Boolean,
        value: false
      },

      _rightHidden: {
        type: Boolean,
        value: false
      },

      _previousTab: {
        type: Object
      }
    },

    hostAttributes: {
      role: 'tablist'
    },

    listeners: {
      'iron-resize': '_onResize',
      'iron-select': '_onIronSelect',
      'iron-deselect': '_onIronDeselect'
    },

    _computeScrollButtonClass: function(hideThisButton, scrollable, hideScrollButtons) {
      if (!scrollable || hideScrollButtons) {
        return 'hidden';
      }

      if (hideThisButton) {
        return 'not-visible';
      }

      return '';
    },

    _computeTabsContentClass: function(scrollable) {
      return scrollable ? 'scrollable' : 'horizontal layout';
    },

    _computeSelectionBarClass: function(noBar, alignBottom) {
      if (noBar) {
        return 'hidden';
      } else if (alignBottom) {
        return 'align-bottom';
      }
    },

    // TODO(cdata): Add `track` response back in when gesture lands.

    _onResize: function() {
      this.debounce('_onResize', function() {
        this._scroll();
        this._tabChanged(this.selectedItem);
      }, 10);
    },

    _onIronSelect: function(event) {
      this._tabChanged(event.detail.item, this._previousTab);
      this._previousTab = event.detail.item;
      this.cancelDebouncer('tab-changed');
    },

    _onIronDeselect: function(event) {
      this.debounce('tab-changed', function() {
        this._tabChanged(null, this._previousTab);
      // See polymer/polymer#1305
      }, 1);
    },

    get _tabContainerScrollSize () {
      return Math.max(
        0,
        this.$.tabsContainer.scrollWidth -
          this.$.tabsContainer.offsetWidth
      );
    },

    _scroll: function() {
      var scrollLeft;

      if (!this.scrollable) {
        return;
      }

      scrollLeft = this.$.tabsContainer.scrollLeft;

      this._leftHidden = scrollLeft === 0;
      this._rightHidden = scrollLeft === this._tabContainerScrollSize;
    },

    _onLeftScrollButtonDown: function() {
      this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
    },

    _onRightScrollButtonDown: function() {
      this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay);
    },

    _onScrollButtonUp: function() {
      clearInterval(this._holdJob);
      this._holdJob = null;
    },

    _scrollToLeft: function() {
      this.$.tabsContainer.scrollLeft -= this._step;
    },

    _scrollToRight: function() {
      this.$.tabsContainer.scrollLeft += this._step;
    },

    _tabChanged: function(tab, old) {
      if (!tab) {
        this._positionBar(0, 0);
        return;
      }

      var r = this.$.tabsContent.getBoundingClientRect();
      var w = r.width;
      var tabRect = tab.getBoundingClientRect();
      var tabOffsetLeft = tabRect.left - r.left;

      this._pos = {
        width: this._calcPercent(tabRect.width, w),
        left: this._calcPercent(tabOffsetLeft, w)
      };

      if (this.noSlide || old == null) {
        // position bar directly without animation
        this._positionBar(this._pos.width, this._pos.left);
        return;
      }

      var oldRect = old.getBoundingClientRect();
      var oldIndex = this.items.indexOf(old);
      var index = this.items.indexOf(tab);
      var m = 5;

      // bar animation: expand
      this.$.selectionBar.classList.add('expand');

      if (oldIndex < index) {
        this._positionBar(this._calcPercent(tabRect.left + tabRect.width - oldRect.left, w) - m,
            this._left);
      } else {
        this._positionBar(this._calcPercent(oldRect.left + oldRect.width - tabRect.left, w) - m,
            this._calcPercent(tabOffsetLeft, w) + m);
      }

      if (this.scrollable) {
        this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
      }
    },

    _scrollToSelectedIfNeeded: function(tabWidth, tabOffsetLeft) {
      var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;
      if (l < 0) {
        this.$.tabsContainer.scrollLeft += l;
      } else {
        l += (tabWidth - this.$.tabsContainer.offsetWidth);
        if (l > 0) {
          this.$.tabsContainer.scrollLeft += l;
        }
      }
    },

    _calcPercent: function(w, w0) {
      return 100 * w / w0;
    },

    _positionBar: function(width, left) {
      this._width = width;
      this._left = left;
      this.transform(
          'translate3d(' + left + '%, 0, 0) scaleX(' + (width / 100) + ')',
          this.$.selectionBar);
    },

    _onBarTransitionEnd: function(e) {
      var cl = this.$.selectionBar.classList;
      // bar animation: expand -> contract
      if (cl.contains('expand')) {
        cl.remove('expand');
        cl.add('contract');
        this._positionBar(this._pos.width, this._pos.left);
      // bar animation done
      } else if (cl.contains('contract')) {
        cl.remove('contract');
      }
    }

  });

</script>
<dom-module id="paper-input-container" assetpath="../bower_components/paper-input/">

  <style>

    :host {
      display: block;
      padding: 8px 0;

      @apply(--paper-input-container);
    }

    :host[inline] {
      display: inline-block;
    }

    :host([disabled]) {
      pointer-events: none;
      opacity: 0.33;
    }

    .floated-label-placeholder {
      @apply(--paper-font-caption);
    }

    .underline {
      position: relative;
    }

    .focused-line {
      height: 2px;

      -webkit-transform-origin: center center;
      transform-origin: center center;
      -webkit-transform: scale3d(0,1,1);
      transform: scale3d(0,1,1);

      background: var(--paper-input-container-focus-color, --default-primary-color);
    }

    .underline.is-highlighted .focused-line {
      -webkit-transform: none;
      transform: none;
      -webkit-transition: -webkit-transform 0.25s;
      transition: transform 0.25s;

      @apply(--paper-transition-easing);
    }

    .underline.is-invalid .focused-line {
      background: var(--paper-input-container-invalid-color, --google-red-500);

      -webkit-transform: none;
      transform: none;
      -webkit-transition: -webkit-transform 0.25s;
      transition: transform 0.25s;

      @apply(--paper-transition-easing);
    }

    .unfocused-line {
      height: 1px;
      background: var(--paper-input-container-color, --secondary-text-color);
    }

    :host([disabled]) .unfocused-line {
      border-bottom: 1px dashed;
      border-color: var(--paper-input-container-color, --secondary-text-color);
      background: transparent;
    }

    .input-content {
      position: relative;
    }

    .input-content ::content label,
    .input-content ::content .paper-input-label {
      position: absolute;
      top: 0;
      right: 0;
      left: 0;
      font: inherit;
      color: var(--paper-input-container-color, --secondary-text-color);

      @apply(--paper-font-subhead);
      @apply(--paper-input-container-label);
    }

    .input-content.label-is-floating ::content label,
    .input-content.label-is-floating ::content .paper-input-label {
      -webkit-transform: translate3d(0, -75%, 0) scale(0.75);
      transform: translate3d(0, -75%, 0) scale(0.75);
      -webkit-transform-origin: left top;
      transform-origin: left top;
      -webkit-transition: -webkit-transform 0.25s;
      transition: transform 0.25s;

      @apply(--paper-transition-easing);
    }

    .input-content.label-is-highlighted ::content label,
    .input-content.label-is-highlighted ::content .paper-input-label {
      color: var(--paper-input-container-focus-color, --default-primary-color);
    }

    .input-content.is-invalid ::content label,
    .input-content.is-invalid ::content .paper-input-label {
      color: var(--paper-input-container-invalid-color, --google-red-500);
    }

    .input-content.label-is-hidden ::content label,
    .input-content.label-is-hidden ::content .paper-input-label {
      visibility: hidden;
    }

    .input-content ::content input,
    .input-content ::content textarea,
    .input-content ::content iron-autogrow-textarea,
    .input-content ::content .paper-input-input {
      position: relative; /* to make a stacking context */
      outline: none;
      box-shadow: none;
      padding: 0;
      width: 100%;
      background: transparent;
      border: none;
      color: var(--paper-input-container-input-color, --primary-text-color);

      @apply(--paper-font-subhead);
      @apply(--paper-input-container-input);
    }

    /* Firefox sets a min-width on the input, which can cause layout issues */
    .input-content ::content input {
      min-width: 0;
    }

    .input-content ::content textarea {
      resize: none;
    }

    .add-on-content.is-invalid ::content * {
      color: var(--paper-input-container-invalid-color, --google-red-500);
    }

    .add-on-content.is-highlighted ::content * {
      color: var(--paper-input-container-focus-color, --default-primary-color);
    }

  </style>

  <template>

    <template is="dom-if" if="[[!noLabelFloat]]">
      <div class="floated-label-placeholder">&nbsp;</div>
    </template>

    <div class$="[[_computeInputContentClass(noLabelFloat,alwaysFloatLabel,focused,invalid,_inputHasContent)]]">
      <content select=":not([add-on])"></content>
    </div>

    <div class$="[[_computeUnderlineClass(focused,invalid)]]">
      <div class="unfocused-line fit"></div>
      <div class="focused-line fit"></div>
    </div>

    <div class$="[[_computeAddOnContentClass(focused,invalid)]]">
      <content id="addOnContent" select="[add-on]"></content>
    </div>

  </template>

</dom-module>

<script>
(function() {

  Polymer({

    is: 'paper-input-container',

    properties: {

      /**
       * Set to true to disable the floating label. The label disappears when the input value is
       * not null.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the floating label.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * The attribute to listen for value changes on.
       */
      attrForValue: {
        type: String,
        value: 'bind-value'
      },

      /**
       * Set to true to auto-validate the input value when it changes.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * True if the input is invalid. This property is set automatically when the input value
       * changes if auto-validating, or when the `iron-input-valid` event is heard from a child.
       */
      invalid: {
        observer: '_invalidChanged',
        type: Boolean,
        value: false
      },

      /**
       * True if the input has focus.
       */
      focused: {
        readOnly: true,
        type: Boolean,
        value: false
      },

      _addons: {
        type: Array,
        value: function() {
          return [];
        }
      },

      _inputHasContent: {
        type: Boolean,
        value: false
      },

      _inputSelector: {
        type: String,
        value: 'input,textarea,.paper-input-input'
      },

      _boundOnFocus: {
        type: Function,
        value: function() {
          return this._onFocus.bind(this);
        }
      },

      _boundOnBlur: {
        type: Function,
        value: function() {
          return this._onBlur.bind(this);
        }
      },

      _boundOnInput: {
        type: Function,
        value: function() {
          this._onInput.bind(this)
        }
      },

      _boundValueChanged: {
        type: Function,
        value: function() {
          return this._onValueChanged.bind(this);
        }
      }

    },

    listeners: {
      'addon-attached': '_onAddonAttached',
      'iron-input-validate': '_onIronInputValidate'
    },

    get _valueChangedEvent() {
      return this.attrForValue + '-changed';
    },

    get _propertyForValue() {
      return Polymer.CaseMap.dashToCamelCase(this.attrForValue);
    },

    get _inputElement() {
      return Polymer.dom(this).querySelector(this._inputSelector);
    },

    ready: function() {
      this.addEventListener('focus', this._boundOnFocus, true);
      this.addEventListener('blur', this._boundOnBlur, true);
      if (this.attrForValue) {
        this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
      } else {
        this.addEventListener('input', this._onInput);
      }
    },

    attached: function() {
      this._handleValue(this._inputElement);
    },

    _onAddonAttached: function(event) {
      this._addons.push(event.target);
      this._handleValue(this._inputElement);
    },

    _onFocus: function() {
      this._setFocused(true);
    },

    _onBlur: function() {
      this._setFocused(false);
    },

    _onInput: function(event) {
      this._handleValue(event.target);
    },

    _onValueChanged: function(event) {
      this._handleValue(event.target);
    },

    _handleValue: function(inputElement) {
      var value = inputElement[this._propertyForValue] || inputElement.value;

      if (this.autoValidate) {
        var valid;
        if (inputElement.validate) {
          valid = inputElement.validate(value);
        } else {
          valid = inputElement.checkValidity();
        }
        this.invalid = !valid;
      }

      // type="number" hack needed because this.value is empty until it's valid
      if (value || (inputElement.type === 'number' && !inputElement.checkValidity())) {
        this._inputHasContent = true;
      } else {
        this._inputHasContent = false;
      }

      this.updateAddons({
        inputElement: inputElement,
        value: value,
        invalid: this.invalid
      });
    },

    _onIronInputValidate: function(event) {
      this.invalid = this._inputElement.invalid;
    },

    _invalidChanged: function() {
      if (this._addons) {
        this.updateAddons({invalid: this.invalid});
      }
    },

    /**
     * Call this to update the state of add-ons.
     * @param {Object} state Add-on state.
     */
    updateAddons: function(state) {
      for (var addon, index = 0; addon = this._addons[index]; index++) {
        addon.update(state);
      }
    },

    _computeInputContentClass: function(noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
      var cls = 'input-content';
      if (!noLabelFloat) {
        if (alwaysFloatLabel || _inputHasContent) {
          cls += ' label-is-floating';
          if (invalid) {
            cls += ' is-invalid';
          } else if (focused) {
            cls += " label-is-highlighted";
          }
        }
      } else {
        if (_inputHasContent) {
          cls += ' label-is-hidden';
        }
      }
      return cls;
    },

    _computeUnderlineClass: function(focused, invalid) {
      var cls = 'underline';
      if (invalid) {
        cls += ' is-invalid';
      } else if (focused) {
        cls += ' is-highlighted'
      }
      return cls;
    },

    _computeAddOnContentClass: function(focused, invalid) {
      var cls = 'add-on-content';
      if (invalid) {
        cls += ' is-invalid';
      } else if (focused) {
        cls += ' is-highlighted'
      }
      return cls;
    }

  });

})();
</script>
<dom-module id="paper-input-error" assetpath="../bower_components/paper-input/">

  <style>

    :host {
      /* need to use display: none for role="alert" */
      display: none;
      float: left;

      color: var(--paper-input-container-invalid-color, --google-red-500);

      @apply(--paper-font-caption);
      @apply(--paper-input-error);
    }

    :host([invalid]) {
      display: inline-block;
    };

  </style>

  <template>

    <content></content>

  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-input-error',

    behaviors: [
      Polymer.PaperInputAddonBehavior
    ],

    hostAttributes: {
      'role': 'alert'
    },

    properties: {

      /**
       * True if the error is showing.
       */
      invalid: {
        readOnly: true,
        reflectToAttribute: true,
        type: Boolean
      }

    },

    update: function(state) {
      this._setInvalid(state.invalid);
    }

  })

})();

</script>
<dom-module id="paper-input-char-counter" assetpath="../bower_components/paper-input/">

  <style>

    :host {
      display: inline-block;
      float: right;

      @apply(--paper-font-caption);
      @apply(--paper-input-char-counter);
    }

  </style>

  <template>

    <span>[[_charCounterStr]]</span>

  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-input-char-counter',

    behaviors: [
      Polymer.PaperInputAddonBehavior
    ],

    properties: {

      _charCounterStr: {
        type: String,
        value: '0'
      }

    },

    update: function(state) {
      if (!state.inputElement) {
        return;
      }

      state.value = state.value || '';

      // Account for the textarea's new lines.
      var str = state.value.replace(/(\r\n|\n|\r)/g, '--').length;

      if (state.inputElement.hasAttribute('maxlength')) {
        str += '/' + state.inputElement.getAttribute('maxlength');
      }
      this._charCounterStr = str;
    }

  });

})();

</script>
<dom-module id="paper-input" assetpath="../bower_components/paper-input/">

  <style>

    :host {
      display: block;
    }

    input::-webkit-input-placeholder {
      color: var(--paper-input-container-color, --secondary-text-color);
    }

    input:-moz-placeholder {
      color: var(--paper-input-container-color, --secondary-text-color);
    }

    input::-moz-placeholder {
      color: var(--paper-input-container-color, --secondary-text-color);
    }

    input:-ms-input-placeholder {
      color: var(--paper-input-container-color, --secondary-text-color);
    }

  </style>

  <template>

    <paper-input-container no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate$="[[autoValidate]]" disabled$="[[disabled]]" invalid="[[invalid]]">

      <label hidden$="[[!label]]">[[label]]</label>

      <input is="iron-input" id="input" aria-labelledby$="[[_ariaLabelledBy]]" aria-describedby$="[[_ariaDescribedBy]]" disabled$="[[disabled]]" bind-value="{{value}}" invalid="{{invalid}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" validator="[[validator]]" type$="[[type]]" pattern$="[[pattern]]" maxlength$="[[maxlength]]" required$="[[required]]" autocomplete$="[[autocomplete]]" autofocus$="[[autofocus]]" inputmode$="[[inputmode]]" minlength$="[[minlength]]" name$="[[name]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]" size$="[[size]]">

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error>[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter></paper-input-char-counter>
      </template>

    </paper-input-container>

  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-input',

    behaviors: [
      Polymer.PaperInputBehavior,
      Polymer.IronFormElementBehavior
    ]

  })

})();

</script>
<dom-module id="paper-toggle-button" assetpath="../bower_components/paper-toggle-button/">

  <style>
/*
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

:host {
  display: inline-block;
}

:host([disabled]) {
  pointer-events: none;
}

:host(:focus) {
  outline:none;
}

:host .toggle-bar {
  background-color: var(--paper-toggle-button-unchecked-bar-color);
}

:host .toggle-button {
  background-color: var(--paper-toggle-button-unchecked-button-color);
}

:host([checked]) .toggle-bar {
  background-color: var(--paper-toggle-button-checked-bar-color);
}

:host([checked]) .toggle-button {
  background-color: var(--paper-toggle-button-checked-button-color);
}

:host .toggle-ink {
  color: var(--paper-toggle-button-unchecked-ink-color);
}

:host([checked]) .toggle-ink {
  color: var(--paper-toggle-button-checked-ink-color);
}

/* ID selectors should not be overriden by users. */

#toggleContainer {
  position: relative;
  width: 36px;
  height: 14px;
}

#toggleBar {
  position: absolute;
  height: 100%;
  width: 100%;
  border-radius: 8px;
  pointer-events: none;
  opacity: 0.4;
  transition: background-color linear .08s;
}

:host([checked]) #toggleBar {
  opacity: 0.5;
}

:host([disabled]) #toggleBar {
  background-color: #000;
  opacity: 0.12;
}

#toggleButton {
  position: absolute;
  top: -3px;
  height: 20px;
  width: 20px;
  border-radius: 50%;
  box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.6);
  transition: -webkit-transform linear .08s, background-color linear .08s;
  transition: transform linear .08s, background-color linear .08s;
  will-change: transform;
}

#toggleButton.dragging {
  -webkit-transition: none;
  transition: none;
}

:host([checked]) #toggleButton {
  -webkit-transform: translate(16px, 0);
  transform: translate(16px, 0);
}

:host([disabled]) #toggleButton {
  background-color: #bdbdbd;
  opacity: 1;
}

#ink {
  position: absolute;
  top: -14px;
  left: -14px;
  width: 48px;
  height: 48px;
  opacity: 0.5;
}

</style>

  <template>

    <div id="toggleContainer">
      <div id="toggleBar" class="toggle-bar"></div>
      <div id="toggleButton" class="toggle-button">
        <paper-ripple id="ink" class="toggle-ink circle" recenters=""></paper-ripple>
      </div>
    </div>

  </template>

  <script>
    Polymer({
      is: 'paper-toggle-button',

      behaviors: [
        Polymer.PaperInkyFocusBehavior
      ],

      hostAttributes: {
        role: 'button',
        'aria-pressed': 'false',
        tabindex: 0
      },

      properties: {
        /**
         * Fired when the checked state changes due to user interaction.
         *
         * @event change
         */
        /**
         * Fired when the checked state changes.
         *
         * @event iron-change
         */
        /**
         * Gets or sets the state, `true` is checked and `false` is unchecked.
         *
         * @attribute checked
         * @type boolean
         * @default false
         */
        checked: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          notify: true,
          observer: '_checkedChanged'
        },

        /**
         * If true, the button toggles the active state with each tap or press
         * of the spacebar.
         *
         * @attribute toggles
         * @type boolean
         * @default true
         */
        toggles: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        }
      },

      listeners: {
        track: '_ontrack'
      },

      ready: function() {
        this._isReady = true;
      },

      // button-behavior hook
      _buttonStateChanged: function() {
        if (this.disabled) {
          return;
        }
        if (this._isReady) {
          this.checked = this.active;
        }
      },

      _checkedChanged: function(checked) {
        this.active = this.checked;
        this.fire('iron-change');
      },

      _ontrack: function(event) {
        var track = event.detail;
        if (track.state === 'start') {
          this._trackStart(track);
        } else if (track.state === 'track') {
          this._trackMove(track);
        } else if (track.state === 'end') {
          this._trackEnd(track);
        }
      },

      _trackStart: function(track) {
        this._width = this.$.toggleBar.offsetWidth / 2;
        /*
         * keep an track-only check state to keep the dragging behavior smooth
         * while toggling activations
         */
        this._trackChecked = this.checked;
        this.$.toggleButton.classList.add('dragging');
      },

      _trackMove: function(track) {
        var dx = track.dx;
        this._x = Math.min(this._width,
            Math.max(0, this._trackChecked ? this._width + dx : dx));
        this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
        this._userActivate(this._x > (this._width / 2));
      },

      _trackEnd: function(track) {
        this.$.toggleButton.classList.remove('dragging');
        this.transform('', this.$.toggleButton);
      }

    });
  </script>

</dom-module>
<dom-module id="iron-overlay-backdrop" assetpath="../bower_components/iron-overlay-behavior/">

  <style>

    :host {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: var(--iron-overlay-backdrop-background-color, #000);
      opacity: 0;
      transition: opacity 0.2s;

      @apply(--iron-overlay-backdrop);
    }

    :host([opened]) {
      opacity: var(--iron-overlay-backdrop-opacity, 0.6);

      @apply(--iron-overlay-backdrop-opened);
    }

  </style>

  <template>
    <content></content>
  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'iron-overlay-backdrop',

    properties: {

      /**
       * Returns true if the backdrop is opened.
       */
      opened: {
        readOnly: true,
        reflectToAttribute: true,
        type: Boolean,
        value: false
      },

      _manager: {
        type: Object,
        value: Polymer.IronOverlayManager
      }

    },

    /**
     * Appends the backdrop to document body and sets its `z-index` to be below the latest overlay.
     */
    prepare: function() {
      if (!this.parentNode) {
        Polymer.dom(document.body).appendChild(this);
        this.style.zIndex = this._manager.currentOverlayZ() - 1;
      }
    },

    /**
     * Shows the backdrop if needed.
     */
    open: function() {
      // only need to make the backdrop visible if this is called by the first overlay with a backdrop
      if (this._manager.getBackdrops().length < 2) {
        this._setOpened(true);
      }
    },

    /**
     * Hides the backdrop if needed.
     */
    close: function() {
      // only need to make the backdrop invisible if this is called by the last overlay with a backdrop
      if (this._manager.getBackdrops().length < 2) {
        this._setOpened(false);
      }
    },

    /**
     * Removes the backdrop from document body if needed.
     */
    complete: function() {
      // only remove the backdrop if there are no more overlays with backdrops
      if (this._manager.getBackdrops().length === 0 && this.parentNode) {
        Polymer.dom(this.parentNode).removeChild(this);
      }
    }

  });

})();

</script>
<dom-module id="paper-dialog" assetpath="../bower_components/paper-dialog/">

  <style>
/*
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

:host {
  display: block;
  margin: 24px 40px;

  background: var(--paper-dialog-background-color, --primary-background-color);
  color: var(--paper-dialog-color, --primary-text-color);

  @apply(--layout-scroll);
  @apply(--paper-font-body1);
  @apply(--shadow-elevation-16dp);
  @apply(--paper-dialog);
}

:host > ::content > * {
  margin-top: 20px;
  padding: 0 24px;
}

:host > ::content > .no-padding {
  padding: 0;
};

:host > ::content > *:first-child {
  margin-top: 24px;
}

:host > ::content > *:last-child {
  margin-bottom: 24px;
}

:host > ::content h2 {
  position: relative;
  margin: 0;
  @apply(--paper-font-title);

  @apply(--paper-dialog-title);
}

:host > ::content .buttons {
  position: relative;
  padding: 8px 8px 8px 24px;
  margin: 0;

  color: var(--paper-dialog-button-color, --default-primary-color);

  @apply(--layout-horizontal);
  @apply(--layout-end-justified);
}

</style>

  <template>
    <content></content>
  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-dialog',

    behaviors: [
      Polymer.PaperDialogBehavior,
      Polymer.NeonAnimationRunnerBehavior
    ],

    listeners: {
      'neon-animation-finish': '_onNeonAnimationFinish'
    },

    _renderOpened: function() {
      if (this.withBackdrop) {
        this.backdropElement.open();
      }
      this.playAnimation('entry');
    },

    _renderClosed: function() {
      if (this.withBackdrop) {
        this.backdropElement.close();
      }
      this.playAnimation('exit');
    },

    _onNeonAnimationFinish: function() {
      if (this.opened) {
        this._finishRenderOpened();
      } else {
        this._finishRenderClosed();
      }
    }

  });

})();

</script>
<dom-module id="paper-dialog-scrollable" assetpath="../bower_components/paper-dialog-scrollable/">

  <style>

    :host {
      display: block;
      position: relative;
    }

    :host(.is-scrolled:not(:first-child))::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--divider-color);
    }

    :host(.can-scroll:not(.scrolled-to-bottom):not(:last-child))::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--divider-color);
    }

    .scrollable {
      padding: 0 24px;

      @apply(--layout-scroll);

      @apply(--paper-dialog-scrollable);
    }
  </style>

  <template>
    <div id="scrollable" class="scrollable">
      <content></content>
    </div>
  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'paper-dialog-scrollable',

    properties: {

      /**
       * The dialog element that implements `Polymer.PaperDialogBehavior` containing this element.
       */
      dialogElement: {
        type: Object,
        value: function() {
          return this.parentNode;
        }
      }

    },

    listeners: {
      'scrollable.scroll': '_onScroll',
      'iron-resize': '_onIronResize'
    },

    /**
     * Returns the scrolling element.
     */
    get scrollTarget() {
      return this.$.scrollable;
    },

    attached: function() {
      this.classList.add('no-padding');
      // Set itself to the overlay sizing target
      this.dialogElement.sizingTarget = this.scrollTarget;
      // If the host is sized, fit the scrollable area to the container. Otherwise let it be
      // its natural size.
      requestAnimationFrame(function() {
        if (this.offsetHeight > 0) {
          this.$.scrollable.classList.add('fit');
        }
        this._scroll();
      }.bind(this));
    },

    _scroll: function() {
      this.toggleClass('is-scrolled', this.scrollTarget.scrollTop > 0);
      this.toggleClass('can-scroll', this.scrollTarget.offsetHeight < this.scrollTarget.scrollHeight);
      this.toggleClass('scrolled-to-bottom',
        this.scrollTarget.scrollTop + this.scrollTarget.offsetHeight >= this.scrollTarget.scrollHeight);
    },

    _onScroll: function() {
      this._scroll();
    }

  })

})();

</script>
<dom-module id="mat-paper" assetpath="../bower_components/mat-paper/">

    <style>
        :host {
            border: 0 solid transparent;
            display: block;
            overflow: hidden;
            position: relative;
            -webkit-transition: border 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                box-shadow 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                opacity 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                visibility 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                border-radius 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                                height 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                                -webkit-transform 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                                width 0.8s cubic-bezier(0.55, 0, 0.01, 1);
            transition: border 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        box-shadow 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        opacity 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        visibility 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        border-radius 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                        height 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                        transform 0.8s cubic-bezier(0.55, 0, 0.01, 1),
                        width 0.8s cubic-bezier(0.55, 0, 0.01, 1);
        }

        /* FOREGROUND */

        :host([foreground="dark"]) {
            background: hsla(0, 0%, 98%, 1);
            border-color: hsla(0, 0%, 0%, 0.12);
            color: hsla(0, 0%, 0%, 0.87);
        }

        :host([foreground="light"]) {
            background: hsla(0, 0%, 26%, 1);
            border-color: hsla(0, 0%, 100%, 0.12);
            color: hsla(0, 0%, 100%, 1);
        }

        /* BRIGHTNESS */

        :host([brightness="header"][foreground="dark"]) { background: hsla(0, 0%, 88%, 1); }
        :host([brightness="header"][foreground="light"]) { background: hsla(0, 0%, 13%, 1); }
        :host([brightness="placeholder"][foreground="dark"]) { background: hsla(0, 0%, 88%, 1); }
        :host([brightness="placeholder"][foreground="light"]) { background: hsla(0, 0%, 46%, 1); }
        :host([brightness="shell"][foreground="dark"]) { background: hsla(0, 0%, 93%, 1); }
        :host([brightness="shell"][foreground="light"]) { background: hsla(0, 0%, 19%, 1); }
        :host([brightness="toolbar"][foreground="dark"]) { background: hsla(0, 0%, 96%, 1); }
        :host([brightness="toolbar"][foreground="light"]) { background: hsla(0, 0%, 38%, 1); }

        /* SHADOW */

        :host([z="1"]) { @apply(--mat-shadow-z1); }
        :host([z="2"]) { @apply(--mat-shadow-z2); }
        :host([z="3"]) { @apply(--mat-shadow-z3); }
        :host([z="4"]) { @apply(--mat-shadow-z4); }
        :host([z="5"]) { @apply(--mat-shadow-z5); }
        :host([z="6"]) { @apply(--mat-shadow-z6); }
        :host([z="7"]) { @apply(--mat-shadow-z7); }
        :host([z="8"]) { @apply(--mat-shadow-z8); }
        :host([z="9"]) { @apply(--mat-shadow-z9); }
        :host([z="10"]) { @apply(--mat-shadow-z10); }
        :host([z="11"]) { @apply(--mat-shadow-z11); }
        :host([z="12"]) { @apply(--mat-shadow-z12); }
        :host([z="13"]) { @apply(--mat-shadow-z13); }
        :host([z="14"]) { @apply(--mat-shadow-z14); }
        :host([z="15"]) { @apply(--mat-shadow-z15); }
        :host([z="16"]) { @apply(--mat-shadow-z16); }
        :host([z="17"]) { @apply(--mat-shadow-z17); }
        :host([z="18"]) { @apply(--mat-shadow-z18); }
        :host([z="19"]) { @apply(--mat-shadow-z19); }
        :host([z="20"]) { @apply(--mat-shadow-z20); }
        :host([z="21"]) { @apply(--mat-shadow-z21); }
        :host([z="22"]) { @apply(--mat-shadow-z22); }
        :host([z="23"]) { @apply(--mat-shadow-z23); }
        :host([z="24"]) { @apply(--mat-shadow-z24); }

        /* DISABLED */
        :host([disabled]) {
            box-shadow: none !important;
            filter: gray;
            filter: grayscale(100%);
            -webkit-filter: grayscale(100%);
            pointer-events: none !important;
        }

        :host([disabled][foreground="dark"]) {
            background: hsla(0, 0%, 0%, 0.12) !important;
            color: hsla(0, 0%, 0%, 0.26);
        }

        :host([disabled][foreground="light"]) {
            background: hsla(0, 0%, 100%, 0.12) !important;
            color: hsla(0, 0%, 100%, 0.30);
        }
    </style>

    <template>
        <template is="xp-master-state" slaves="{{inks}}" slave-tag="mat-ink"></template>
        <template is="xp-master-state" slaves="{{papers}}" slave-tag="mat-paper"></template>
        <template is="xp-slave-state" master="{{layer}}" master-tag="mat-paper"></template>
        <content id="content"></content>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-paper',

            // BEHAVIORS
            behaviors: [
                Polymer.MatPalette
            ],

            /*********************************************************************/

            /**
             * Falls the paper.
             *
             * @method fall
             * @returns {Element}
             */
            fall: function () {

                // Vars
                var self = this;

                // Checking
                if (self.raising || !self.z) { return self; }

                // Setting
                self._setRaising(false);
                self.z         = self.pressed ? self.z : self.zPrevious;
                self.zPrevious = self.pressed ? self.zPrevious : 0;

                return self;
            },

            /**
             * Raises the paper.
             *
             * @method raise
             * @returns {Element}
             */
            raise: function () {

                // Vars
                var self = this;

                // Checking
                if (self.raising || !self.z) { return self; }

                // Setting
                self._setRaising(true);
                self.zPrevious = self.z;
                self.z         = Math.min(self.z + self.zElevation, self.zMax);

                // Delaying
                XP.delay(function () { self._setRaising(false); self.fall(); }, 300);

                return self;
            },

            /*********************************************************************/

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {
                var self = this;
                XP.setStyle(self, 'background', !self.disabled && self._getColor(self.background));
                return self;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'down': '_handleTouch',
                'up': '_handleTouch'
            },

            // OBSERVERS
            observers: [
                '_refresh(background, disabled)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The paper's brightness.
                 *
                 * @attribute brightness
                 * @type string
                 */
                brightness: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The paper's foreground color.
                 *
                 * @attribute foreground
                 * @type "dark" | "light"
                 * @notifies
                 * @readonly
                 */
                foreground: {
                    computed: '_computeForeground(background, brightness, theme, disabled)',
                    notify: true,
                    observer: '_foregroundChanged',
                    reflectToAttribute: true,
                    type: String
                },

                /**
                 * The slave inks.
                 *
                 * @attribute inks
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                inks: {
                    notify: true,
                    type: Array
                },

                /**
                 * The master paper.
                 *
                 * @attribute layer
                 * @type Element
                 * @notifies
                 */
                layer: {
                    notify: true,
                    observer: '_layerChanged',
                    value: null
                },

                /**
                 * The slave papers.
                 *
                 * @attribute papers
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                papers: {
                    notify: true,
                    type: Array
                },

                /**
                 * If set to true, the element is pressable.
                 *
                 * @attribute pressable
                 * @type boolean
                 * @default false
                 */
                pressable: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is pressed.
                 *
                 * @attribute pressed
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                pressed: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the paper is raising from the rest position.
                 *
                 * @attribute raising
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                raising: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The paper's theme, used to apply the default foreground color.
                 *
                 * @attribute theme
                 * @type "dark" | "light"
                 * @default "light"
                 * @notifies
                 */
                theme: {
                    notify: true,
                    observer: '_themeChanged',
                    type: String,
                    value: 'light'
                },

                /**
                 * The paper's z-axis position.
                 *
                 * @attribute z
                 * @type number
                 * @default 0
                 * @notifies
                 */
                z: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Number,
                    value: 0
                }
            },

            /**
             * The brightness list.
             *
             * @property brightnessList
             * @type Array
             * @default ["header", "overlay", "placeholder", "shell", "toolbar"]
             * @readonly
             */
            brightnessList: ['header', 'overlay', 'placeholder', 'shell', 'toolbar'],

            /**
             * The list of instances.
             *
             * @property instances
             * @type Array
             * @default []
             * @readonly
             */
            instances: [],

            /**
             * The elevation value of z.
             *
             * @property zElevation
             * @type number
             * @default 6
             * @readonly
             */
            zElevation: 6,

            /**
             * The maximum value of z.
             *
             * @property zMax
             * @type number
             * @default 24
             * @readonly
             */
            zMax: 24,

            /**
             * The previous value of z.
             *
             * @property zPrevious
             * @type number
             * @default 0
             * @readonly
             */
            zPrevious: 0,

            /*********************************************************************/

            // COMPUTER
            _computeForeground: function (background, brightness, theme, disabled) {
                var palette = (!disabled && background) || (brightness !== "overlay" && theme) || "light";
                return this._getForeground(palette, brightness === "placeholder" && !background && !disabled);
            },

            /*********************************************************************/

            // OBSERVER
            _foregroundChanged: function (post) {
                XP.forEach(this.inks || [], function (ink) { ink._setForeground(post); });
            },

            // OBSERVER
            _layerChanged: function (post) {
                if (post && arguments.length > 1) { this.theme = post.theme; }
            },

            // OBSERVER
            _themeChanged: function (post) {
                XP.forEach(this.papers || [], function (paper) { paper.theme = post; });
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this.push('instances', this);
            },

            /*********************************************************************/

            // HANDLER
            _handleTouch: function (event) {

                // Vars
                var self = this;

                // Checking
                if (!self.pressable) { return; }

                // Setting
                self._setPressed(event.type === 'down');

                // Animating
                self[event.type === 'down' ? 'raise' : 'fall']();
            }
        });
    </script>

</dom-module><dom-module id="xp-overlay" assetpath="../bower_components/xp-overlay/">

    <style>
:host {
    display: block;
    opacity: 0;
    overflow: visible;
    position: fixed;
    text-align: left;
    transition: opacity 0.2s, visibility 0.2s;
    visibility: hidden;
    z-index: 9999;
}

:host([showed]) {
    opacity: 1;
    visibility: visible;
}

:host(:not([showed])) {
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            margin: 16px;
        }

        :host #xpOverlayWrapper {
            background: inherit;
            height: 100%;
            overflow: auto;
        }
    </style>

    <template>
        <div id="xpOverlayWrapper">
            <content id="content"></content>
        </div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-overlay',

            // BEHAVIORS
            behaviors: [
                Polymer.XPOverlayBehavior
            ],

            /*********************************************************************/

            /**
             * Aligns the overlay.
             *
             * @method _align
             * @returns {Element}
             * @private
             */
            _align: function () {
                var self = this, target = self.showed && self.findTarget();
                if (target) { XP.alignElement(self, target, self.position, self.autoCenter); } else { self.hide(); }
                return self;
            },

            /*********************************************************************/

            // OBSERVERS
            observers: [
                '_align(autoCenter, position, showed, target)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the overlay is center aligned.
                 *
                 * @attribute auto-center
                 * @type boolean
                 * @default false
                 */
                autoCenter: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The overlay position relative to the target.
                 *
                 * 'over' is over the target.
                 *
                 * 'aside' is to the side of the target.
                 *
                 * 'baseline' is underneath the target.
                 *
                 * @attribute position
                 * @type "aside" | "baseline" | "over"
                 * @default "over"
                 */
                position: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'over'
                }
            },

            /**
             * The list of positions.
             *
             * @property positions
             * @type Array
             * @default ["aside", "baseline", "over"]
             * @readonly
             */
            positions: ['aside', 'baseline', 'over'],

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this.listen(window, 'resize', '_handleResize');
            },

            /*********************************************************************/

            // HANDLER
            _handleResize: function () {
                this._align();
            }
        });
    </script>

</dom-module><dom-module id="mat-overlay" assetpath="../bower_components/mat-overlay/">

    <style>
        :host {
            display: block;
            overflow: visible;
            position: absolute;
        }

        :host #matOverlayAdaptee {
            margin: 16px;
        }

        :host #matOverlayAdaptee::shadow > #xpOverlayWrapper {
            overflow: visible;
        }

        :host #matOverlayWrapper {
            border-radius: inherit;
            height: 100%;
            overflow: auto;
            padding: 8px 0;
        }
    </style>

    <template>
        <xp-overlay id="matOverlayAdaptee" auto-center="[[autoCenter]]" auto-hide-disabled="[[autoHideDisabled]]" data="{{data}}" position="[[position]]" showed="{{showed}}" target="{{target}}">
            <mat-paper id="matOverlayWrapper" background="[[background]]" brightness="overlay" z="[[z]]">
                <content id="content"></content>
            </mat-paper>
        </xp-overlay>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-overlay',

            // BEHAVIORS
            behaviors: [
                Polymer.XPTargeterBehavior
            ],

            /*********************************************************************/

            /**
             * Hides the overlay.
             *
             * @method hide
             * @returns {Element}
             */
            hide: function () {
                var self = this;
                self.$.matOverlayAdaptee.hide();
                return self;
            },

            /**
             * Shows the overlay.
             *
             * @method show
             * @param {Element | string} target
             * @param {*} [data]
             * @returns {Element}
             */
            show: function (target, data) {
                var self = this;
                self.$.matOverlayAdaptee.show(target, data);
                return self;
            },

            /**
             * Toggles the overlay.
             *
             * @method toggle
             * @param {Element | string} target
             * @param {*} [data]
             * @returns {Element}
             */
            toggle: function (target, data) {
                var self = this;
                self.$.matOverlayAdaptee.toggle(target, data);
                return self;
            },

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the overlay is center aligned.
                 *
                 * @attribute auto-center
                 * @type boolean
                 * @default false
                 */
                autoCenter: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the overlay will not close by clicking outside.
                 *
                 * @attribute auto-hide-disabled
                 * @type boolean
                 * @default false
                 */
                autoHideDisabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * The overlay position relative to the target.
                 *
                 * 'over' is over the target.
                 *
                 * 'aside' is to the side of the target.
                 *
                 * 'baseline' is underneath the target.
                 *
                 * @attribute position
                 * @type "aside" | "baseline" | "over"
                 * @default "over"
                 */
                position: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'over'
                },

                /**
                 * If set to true, the overlay is showed.
                 *
                 * @attribute showed
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                showed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The paper's z-axis position.
                 *
                 * @attribute z
                 * @type number
                 * @default 8
                 */
                z: {
                    reflectToAttribute: true,
                    type: Number,
                    value: 8
                }
            }
        });
    </script>

</dom-module><dom-module id="mat-menu" assetpath="../bower_components/mat-menu/">

    <style>
        :host {
            display: block;
            overflow: visible;
            position: absolute;
        }

        :host([cascade]) #matMenuWrapper::shadow #matOverlayBody {
            padding: 16px 0;
        }
    </style>

    <template>
        <template is="xp-master-state" id="xpMasterState" slaves="{{submenus}}" slave-tag="mat-submenu" on-slaves-changed="_handleSlaves"></template>
        <mat-overlay id="matMenuWrapper" background="[[background]]" data="{{data}}" position="[[_computePosition(cascade)]]" showed="{{showed}}" target="{{target}}" z="[[z]]">
            <content id="content"></content>
        </mat-overlay>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-menu',

            // BEHAVIORS
            behaviors: [
                Polymer.XPTargeterBehavior
            ],

            /*********************************************************************/

            /**
             * Hides the menu.
             *
             * @method hide
             * @returns {Element}
             */
            hide: function () {
                var self = this;
                self.$.matMenuWrapper.hide();
                return self;
            },

            /**
             * Shows the menu.
             *
             * @method show
             * @param {Element | string} target
             * @param {*} [data]
             * @returns {Element}
             */
            show: function (target, data) {
                var self = this;
                self.$.matMenuWrapper.show(target, data);
                return self;
            },

            /**
             * Toggles the menu.
             *
             * @method toggle
             * @param {Element | string} target
             * @param {*} [data]
             * @returns {Element}
             */
            toggle: function (target, data) {
                var self = this;
                self.$.matMenuWrapper.toggle(target, data);
                return self;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'xp-activate': '_handleActivate'
            },

            // PROPERTIES
            properties: {

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    observer: '_backgroundChanged',
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the menu is a cascade one.
                 *
                 * @attribute cascade
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                cascade: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the overlay is showed.
                 *
                 * @attribute showed
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                showed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The slave submenus.
                 *
                 * @attribute submenus
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                submenus: {
                    notify: true,
                    type: Array
                },

                /**
                 * The paper's z-axis position.
                 *
                 * @attribute z
                 * @type number
                 * @default 8
                 * @readonly
                 */
                z: {
                    readOnly: true,
                    type: Number,
                    value: 8
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computePosition: function (cascade) {
                return cascade ? 'baseline' : 'over';
            },

            /*********************************************************************/

            // OBSERVER
            _backgroundChanged: function (post) {
                XP.forEach(this.submenus || [], function (submenu) { submenu.background = post; });
            },

            /*********************************************************************/

            // HANDLER
            _handleActivate: function (event) {
                var self = this;
                if (!XP.matches(event.detail.firer, 'mat-option') || event.detail.firer.toggleable) { return; }
                XP.delay(function () { if (!event.defaultPrevented) { self.hide(); } });
            },

            // HANDLE
            _handleSlaves: function () {
                var self = this;
                XP.delay(function () { self.cascade = self.cascade || self.submenus.length > 0; });
            }
        });
    </script>

</dom-module><dom-module id="mat-ink" assetpath="../bower_components/mat-ink/">

    <style>
        :host {
            display: block;
            overflow: visible;
        }

        /* FOREGROUND */

        :host([foreground="dark"]) { color: hsla(0, 0%, 0%, 0.87); }
        :host([foreground="light"]) { color: hsla(0, 0%, 100%, 1); }

        /* OPACITY */

        :host([opacity="divider"][foreground="dark"]) { color: hsla(0, 0%, 0%, 0.12); }
        :host([opacity="divider"][foreground="light"]) { color: hsla(0, 0%, 100%, 0.12); }
        :host([opacity="hint"][foreground="dark"]) { color: hsla(0, 0%, 0%, 0.26); }
        :host([opacity="hint"][foreground="light"]) { color: hsla(0, 0%, 100%, 0.30); }
        :host([opacity="icon"][foreground="dark"]) { color: hsla(0, 0%, 0%, 0.54); }
        :host([opacity="icon"][foreground="light"]) { color: hsla(0, 0%, 100%, 1); }
        :host([opacity="secondary"][foreground="dark"]) { color: hsla(0, 0%, 0%, 0.54); }
        :host([opacity="secondary"][foreground="light"]) { color: hsla(0, 0%, 100%, 0.70); }

        /* DISABLED */
        :host([disabled]) {
            filter: gray;
            filter: grayscale(100%);
            -webkit-filter: grayscale(100%);
            pointer-events: none !important;
            text-shadow: none !important;
        }

        :host([disabled][foreground="dark"]) {
            color: hsla(0, 0%, 0%, 0.26) !important;
        }

        :host([disabled][foreground="light"]) {
            color: hsla(0, 0%, 100%, 0.30) !important;
        }
    </style>

    <template>
        <template is="xp-slave-state" master="{{layer}}" master-tag="mat-paper"></template>
        <content id="content"></content>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-ink',

            // BEHAVIORS
            behaviors: [
                Polymer.MatPalette
            ],

            /*********************************************************************/

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {
                var self = this;
                XP.setStyle(self, 'color', !self.disabled && self._getColor(self.color));
                return self;
            },

            /*********************************************************************/

            // OBSERVERS
            observers: [
                '_refresh(color, disabled)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The ink's foreground color.
                 *
                 * @attribute foreground
                 * @type "dark" | "light"
                 * @notifies
                 * @readonly
                 */
                foreground: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: String,
                    value: function () { return this._getForeground(); }
                },

                /**
                 * The paper layer where ink is placed.
                 *
                 * @attribute layer
                 * @type Element
                 * @notifies
                 */
                layer: {
                    notify: true,
                    observer: '_layerChanged',
                    value: null
                },

                /**
                 * The ink's opacity level.
                 *
                 * @attribute opacity
                 * @type string
                 */
                opacity: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /**
             * The opacity list.
             *
             * @property opacityList
             * @type Array
             * @default ["divider", "hint", "icon", "secondary"]
             * @readonly
             */
            opacityList: ['divider', 'hint', 'icon', 'secondary'],

            /*********************************************************************/

            // OBSERVER
            _layerChanged: function (post) {
                if (post && arguments.length > 1) { this._setForeground(post.foreground); }
            }
        });
    </script>

</dom-module><dom-module id="xp-iconset" assetpath="../bower_components/xp-iconset/">

    <style>
        :host {
            display: none !important;
        }
    </style>

    <template>
        <content id="content"></content>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-iconset',

            // BEHAVIORS
            behaviors: [
                Polymer.XPArrayBehavior
            ],

            /*********************************************************************/

            /**
             * Returns a copy of an iconset's icon.
             *
             * @method findIcon
             * @param {string} [name = ""]
             * @returns {Node}
             */
            findIcon: function (name) {

                // Asserting
                XP.assertArgument(XP.isVoid(name) || XP.isString(name), 1, 'string');

                // Vars
                var self    = this,
                    wrapper = name ? XP.getDistributedElement(Polymer.dom((self.instance || self).$.content), 'svg') : null,
                    icon    = wrapper ? XP.getElement(Polymer.dom(wrapper), 'g[id="' + name + '"]') : null,
                    clone   = icon ? icon.cloneNode(true) : null;

                // Cleaning
                if (clone) { clone.removeAttribute('id'); }

                return clone;
            },

            /**
             * Returns an iconset instance.
             *
             * @method findInstance
             * @param {string} [name = ""]
             * @returns {Element}
             */
            findInstance: function (name) {
                XP.assertArgument(XP.isVoid(name) || XP.isString(name), 1, 'string');
                return (name && XP.find(this.instances, function (instance) { return name === instance.name; })) || null;
            },

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The iconset's instance.
                 *
                 * @attribute instance
                 * @type Element
                 * @notifies
                 * @readonly
                 */
                instance: {
                    computed: '_computeInstance(name, refers)',
                    notify: true
                },

                /**
                 * The instance's name.
                 *
                 * @attribute name
                 * @type string
                 */
                name: {
                    observer: '_nameChanged',
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The referred instance's name.
                 *
                 * @attribute refers
                 * @type string
                 */
                refers: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /**
             * The list of instances.
             *
             * @property instances
             * @type Array
             * @default []
             * @readonly
             */
            instances: [],

            /*********************************************************************/

            // COMPUTER
            _computeInstance: function (name, refers) {
                return (!name && this.findInstance(refers)) || null;
            },

            /*********************************************************************/

            // OBSERVER
            _nameChanged: function (post) {
                this[post ? 'append' : 'pull']('instances', this);
            }
        });
    </script>

</dom-module><dom-module id="xp-icon" assetpath="../bower_components/xp-icon/">

    <style>
        :host {
            display: inline-block;
            height: 24px;
            overflow: visible;
            width: 24px;
        }

        :host([empty]) {
            display: none !important;
        }

        :host #xpIconWrapper,
        :host #xpIconWrapper * {
            border-radius: inherit;
            height: 100%;
            width: 100%;
        }

        :host svg {
            display: block;
            fill: currentcolor;
        }
    </style>

    <template>
        <div id="xpIconWrapper"></div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-icon',

            /*********************************************************************/

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {

                // Vars
                var self        = this,
                    icon        = self.iconSet && self.iconName ? self.iconSet.findIcon(self.iconName) : null,
                    iconElement = icon ? XP.createElementNS('http://www.w3.org/2000/svg', 'svg', {children: [icon]}) : (self.src ? XP.createElement('div') : null),
                    iconTag     = iconElement ? XP.getTag(XP.addAttribute(iconElement, 'icon')) : null;

                // Setting
                self._setIconElement(iconElement);
                self._setEmpty(!iconElement);
                self._setRaster(iconTag !== 'svg');

                // Stylizing
                if (iconTag === 'div') { XP.setStyles(iconElement, {background: 'url(' + self.src + ') 100% no-repeat', 'background-size': '100% 100%'}); }
                if (iconTag === 'svg') { XP.setAttributes(iconElement, {xmlns: "http://www.w3.org/2000/svg", height: 24, width: 24, viewBox: '0 0 ' + 24 + ' ' + 24}); }

                // Replacing
                XP.setChildren(Polymer.dom(self.$.xpIconWrapper), [iconElement]);

                return self;
            },

            /*********************************************************************/

            // OBSERVERS
            observers: [
                '_refresh(iconName, iconSet, src)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The iconset used to find others.
                 *
                 * @attribute finder
                 * @type Element
                 * @readonly
                 */
                finder: {
                    readOnly: true,
                    value: function () { return XP.createElement('xp-iconset'); }
                },

                /**
                 * The icon's rendered element.
                 *
                 * @attribute icon-element
                 * @type Element
                 * @readonly
                 */
                iconElement: {
                    readOnly: true,
                    value: null
                },

                /**
                 * The icon's name.
                 *
                 * @attribute icon-name
                 * @type string
                 * @notifies
                 * @readonly
                 */
                iconName: {
                    notify: true,
                    readOnly: true,
                    type: String,
                    value: null
                },

                /**
                 * The icon's iconset.
                 *
                 * @attribute icon-set
                 * @type Element
                 * @notifies
                 * @readonly
                 */
                iconSet: {
                    notify: true,
                    readOnly: true,
                    value: null
                },

                /**
                 * The icon's iconset:name.
                 *
                 * @attribute name
                 * @type string
                 */
                name: {
                    observer: '_nameChanged',
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the icon is rendered as `div` background instead of `svg`.
                 *
                 * @attribute raster
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    readOnly: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The icon's src.
                 *
                 * @attribute src
                 * @type string
                 */
                src: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /**
             * The list iconsets.
             *
             * @property iconSets
             * @type Object
             * @readonly
             */
            iconSets: {},

            /*********************************************************************/

            // OBSERVER
            _nameChanged: function (post) {

                // Vars
                var self  = this,
                    parts = XP.split(post, ':');

                // Finding
                if (parts[0]) { self.iconSets[parts[0]] = self.iconSets[parts[0]] || self.finder.findInstance(parts[0]); }

                // Setting
                self._setIconName(parts[1] || '');
                self._setIconSet(parts[0] ? self.iconSets[parts[0]] : null);
            }
        });
    </script>

</dom-module>
<dom-module id="mat-icon" assetpath="../bower_components/mat-icon/">

    <style>
        :host {
            display: inline-block;
            height: 24px;
            overflow: visible;
            width: 24px;
        }

        :host([empty]) {
            display: none !important;
        }

        :host #matIconWrapper,
        :host #matIconAdaptee {
            border-radius: inherit;
            display: block;
            height: 100%;
            width: 100%;
        }
    </style>

    <template>
        <mat-ink id="matIconWrapper" color="[[color]]" disabled="[[disabled]]" opacity="[[_computeOpacity(opacity, raster)]]">
            <xp-icon id="matIconAdaptee" empty="{{empty}}" name="[[name]]" raster="{{raster}}" src="[[src]]"></xp-icon>
        </mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-icon',

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The ink's color.
                 *
                 * @property color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The icon's iconset:name.
                 *
                 * @attribute name
                 * @type string
                 */
                name: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The ink's opacity level.
                 *
                 * @attribute opacity
                 * @type string
                 */
                opacity: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the icon is rendered as `div` background instead of `svg`.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The icon's src.
                 *
                 * @attribute src
                 * @type string
                 */
                src: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeOpacity: function (opacity, raster) {
                return opacity || (raster ? '' : 'icon');
            }
        });
    </script>

</dom-module>
<dom-module id="mat-ripple" assetpath="../bower_components/mat-ripple/">

    <style>
        :host {
            @apply(--layout-fit);
            border-radius: inherit;
            display: block;
            overflow: hidden;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-select: none;
            user-select: none;
        }

        :host([animated]) {
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
        }

        :host #matRippleWrapper {
            @apply(--layout-fit);
            border-radius: inherit;
            color: inherit;
            pointer-events: none !important;
        }

        :host #matRippleBackground {
            @apply(--layout-fit);
            background: currentColor;
            border-radius: inherit;
            opacity: 0;
            transition: opacity 0.8s;
            will-change: opacity;
        }

        :host(:not([auto-center])) #matRippleBackground[rippling] {
            opacity: 0.10;
        }

        :host #matRippleWaves {
            @apply(--layout-fit);
            border-radius: 50%;
        }

        :host #matRippleWaves * {
            background: currentColor;
            border-radius: inherit;
            opacity: 0.10;
            position: absolute;
            -webkit-transform: translate(0, 0) scale(0);
            transform: translate(0, 0) scale(0);
            -webkit-transition: opacity 0.54s, -webkit-transform 0.54s;
            transition: opacity 0.54s, transform 0.54s;
            will-change: opacity, transform;
        }

        :host([auto-center]) #matRippleWaves * {
            opacity: 0.20;
        }

        :host #matRippleWaves *[smoothing] {
            opacity: 0;
            -webkit-transform: scale(1);
            transform: scale(1);
            -webkit-transition: opacity 0.54s, -webkit-transform 0.54s;
            transition: opacity 0.54s, transform 0.54s;
        }
    </style>

    <template>
        <mat-ink id="matRippleWrapper" color="[[color]]">
            <div id="matRippleBackground"></div>
            <div id="matRippleWaves"></div>
        </mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-ripple',

            /*********************************************************************/

            /**
             * Ripples a wave.
             *
             * @method ripple
             * @param {number} [startX]
             * @param {number} [startY]
             * @returns {Element}
             */
            ripple: function (startX, startY) {

                // Asserting
                XP.assertArgument(XP.isVoid(startX) || XP.isNumber(startX), 1, 'number');
                XP.assertArgument(XP.isVoid(startY) || XP.isNumber(startY), 2, 'number');

                // Vars
                var self       = this,
                    background = self.$.matRippleBackground,
                    waves      = self.$.matRippleWaves,
                    wave       = XP.appendChild(Polymer.dom(waves), XP.createElement('div')),
                    data       = self._waveData(wave, startX, startY);

                // Setting
                self.timeLast = Date.now();

                // Animation
                XP.delay(function () {

                    // Styling
                    XP.setStyle(wave, 'height', data.radius + 'px');
                    XP.setStyle(wave, 'left', data.left + 'px');
                    XP.setStyle(wave, 'top', data.top + 'px');
                    XP.setStyle(wave, 'width', data.radius + 'px');
                    XP.setStyle(wave, '-webkit-transform', 'translate(' + data.dx + 'px, ' + data.dy + 'px) scale(1)');
                    XP.setStyle(wave, 'transform', 'translate(' + data.dx + 'px, ' + data.dy + 'px) scale(1)');

                    // Setting
                    XP.addAttribute(self, 'animated');
                    XP.addAttribute(background, 'rippling');
                    XP.addAttribute(wave, 'rippling');

                    // Smoothing
                    if (!self.pressed) { self.smooth(); }
                });

                return self;
            },

            /**
             * Smooths a wave.
             *
             * @method smooth
             * @param {boolean} [force = false]
             * @returns {Element}
             */
            smooth: function (force) {

                // Vars
                var self = this;

                // Animation
                XP.delay(function () {

                    // Vars
                    var elapsed    = Date.now() - self.timeLast,
                        background = self.$.matRippleBackground,
                        waves      = self.$.matRippleWaves,
                        wave       = XP.getElement(Polymer.dom(waves), '[rippling]');

                    // Checking
                    if (!wave) { return; }

                    // Delaying
                    if (!force && elapsed < 240) { XP.delay(function () { self.smooth(true); }, 240 - elapsed); return; }

                    // Wave
                    XP.removeAttribute(wave, 'rippling');
                    XP.removeAttribute(!XP.getElement(Polymer.dom(waves), '[rippling]') ? background : null, 'rippling');
                    XP.addAttribute(wave, 'smoothing');

                    // Delaying
                    XP.delay(function() {

                        // Removing
                        XP.removeChild(Polymer.dom(waves), wave);
                        XP.removeAttribute(!Polymer.dom(waves).children.length ? self : null, 'animated');

                    }, 600);
                });

                return self;
            },

            /*********************************************************************/

            /**
             * Creates the data to position the wave.
             *
             * @method _waveData
             * @param {Element} wave
             * @param {number} [startX]
             * @param {number} [startY]
             * @returns {Object}
             * @private
             */
            _waveData: function (wave, startX, startY) {

                // Asserting
                XP.assertArgument(XP.isElement(wave), 1, 'Element');
                XP.assertArgument(XP.isVoid(startX) || XP.isNumber(startX), 2, 'number');
                XP.assertArgument(XP.isVoid(startY) || XP.isNumber(startY), 3, 'number');

                // Vars
                var self      = this,
                    boundings = XP.getBoundings(self),
                    centerX   = XP.isVoid(startX) || self.autoCenter,
                    centerY   = XP.isVoid(startY) || self.autoCenter,
                    data      = {};

                // Setting
                data.radius = Math.floor(Math.max(boundings.width, boundings.height)) * 1.5;
                data.left   = (centerX ? (boundings.width / 2) : Math.max(startX, boundings.left) - Math.min(startX, boundings.left)) - (data.radius / 2);
                data.top    = (centerY ? (boundings.height / 2) : Math.max(startY, boundings.top) - Math.min(startY, boundings.top)) - (data.radius / 2);
                data.dx     = (boundings.width / 2) - data.left - (data.radius / 2);
                data.dy     = (boundings.height / 2) - data.top - (data.radius / 2);

                return data;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                down: '_handleTouch',
                up: '_handleTouch'
            },

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the waves will propagate from the center instead of the touch point.
                 *
                 * @attribute auto-center
                 * @type boolean
                 * @default false
                 */
                autoCenter: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The context element.
                 *
                 * @attribute context
                 * @type Element
                 */
                context: {
                    observer: '_contextChanged',
                    value: null
                },

                /**
                 * If set to true, the element is pressed.
                 *
                 * @attribute pressed
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                pressed: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                }
            },

            /**
             * The timestamp of the last wave.
             *
             * @property timeLast
             * @type number
             * @default 0
             * @readonly
             */
            timeLast: 0,

            /*********************************************************************/

            // OBSERVER
            _contextChanged: function (post, pre) {

                // Vars
                var self = this;

                // Checking
                if (arguments.length < 2) { return; }

                // Listening
                if (pre) { self.unlisten(pre, 'down', '_handleTouch'); self.unlisten(pre, 'up', '_handleTouch'); }
                if (post) { self.listen(post, 'down', '_handleTouch'); self.listen(post, 'up', '_handleTouch'); }

                // Styling
                XP.setStyle(self, 'pointer-events', post ? 'none' : null);
            },

            /*********************************************************************/

            // HANDLER
            _handleTouch: function (event) {

                // Vars
                var self = this;

                // Setting
                self._setPressed(event.type === 'down');

                // Animating
                if (event.type === 'down') { self.ripple(event.detail.x, event.detail.y); } else { self.smooth(); }
            }
        });
    </script>

</dom-module><dom-module id="mat-icon-button" assetpath="../bower_components/mat-icon-button/">

    <style>
:host {
    cursor: pointer;
    display: inline-block;
    outline: 0;
    overflow: visible;
    position: relative;
    text-align: left;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

:host([disabled]) {
    cursor: default !important;
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            border-radius: 50%;
            height: 40px;
            margin: 4px;
            width: 40px;
        }

        :host([empty]) {
            display: none !important;
        }

        :host #matIconButtonWrapper,
        :host #matIconButtonMain {
            border-radius: inherit;
            height: 100%;
        }

        :host #matIconButtonMain {
            @apply(--layout-horizontal);
            @apply(--layout-center-center);
        }

        :host #matIconButtonAnchor {
            border-radius: inherit;
            display: block;
            height: 100%;
            overflow: hidden;
            text-decoration: none;
        }

        :host #matIconButtonAnchor:after {
            bottom: -4px;
            content: "";
            left: -4px;
            position: absolute;
            right: -4px;
            top: -4px;
        }

        :host #matIconButtonIcons,
        :host #matIconButtonIcon,
        :host #matIconButtonActiveIcon {
            display: block;
            position: relative;
        }

        :host #matIconButtonRipple {
            margin: -4px;
            padding: 4px;
        }

        /* ANIMATION */

        :host #matIconButtonIcon,
        :host #matIconButtonActiveIcon {
            -webkit-transition: opacity 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                -webkit-transform 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                                visibility 0.4s cubic-bezier(0.55, 0, 0.01, 1);
            transition: opacity 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        transform 0.4s cubic-bezier(0.55, 0, 0.01, 1),
                        visibility 0.4s cubic-bezier(0.55, 0, 0.01, 1);
        }

        :host([animated]) #matIconButtonIcon {
            position: absolute;
        }

        :host #matIconButtonIcon,
        :host([active]) #matIconButtonActiveIcon {
            -webkit-transform: scale(1);
            transform: scale(1);
            visibility: visible;
        }

        :host([active][animated]) #matIconButtonIcon,
        :host(:not([active])) #matIconButtonActiveIcon {
            opacity: 0;
            -webkit-transform: scale(0);
            transform: scale(0);
            visibility: hidden;
        }
    </style>

    <template>
        <div id="matIconButtonWrapper">
            <a id="matIconButtonAnchor">
                <div id="matIconButtonMain">
                    <div id="matIconButtonIcons">
                        <mat-icon id="matIconButtonIcon" color="[[_computeColor(active, activeColor, color)]]" disabled="[[disabled]]" name="[[icon]]" raster="{{raster}}" src="[[iconSrc]]"></mat-icon>
                        <mat-icon id="matIconButtonActiveIcon" color="[[_computeColor(active, activeColor, color)]]" disabled="[[disabled]]" name="[[activeIcon]]" raster="{{activeRaster}}" src="[[activeIconSrc]]"></mat-icon>
                    </div>
                </div>
            </a>
            <mat-ripple context="[[self]]" id="matIconButtonRipple" color="[[_computeColor(active, activeColor, color)]]" auto-center=""></mat-ripple>
        </div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-icon-button',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAnchorBehavior,
                Polymer.XPPressedBehavior,
                Polymer.XPReferralBehavior
            ],

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The ink's active color.
                 *
                 * @attribute active-color
                 * @type string
                 */
                activeColor: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The button's active icon.
                 *
                 * @attribute active-icon
                 * @type string
                 */
                activeIcon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The button's active icon's src.
                 *
                 * @attribute active-icon-src
                 * @type string
                 */
                activeIconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the active icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                activeRaster: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, both icon and active icon are set.
                 *
                 * @attribute active-icon
                 * @type string
                 * @notifies
                 * @readonly
                 */
                animated: {
                    computed: '_computeAnimated(activeIcon, activeIconSrc)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    computed: '_computeEmpty(animated, active, icon, iconSrc)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The button's icon.
                 *
                 * @attribute icon
                 * @type string
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The button's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeAnimated: function (activeIcon, activeIconSrc) {
                return !!activeIcon || !!activeIconSrc;
            },

            // COMPUTER
            _computeColor: function (active, activeColor, color) {
                return (active && activeColor) || color;
            },

            // COMPUTER
            _computeEmpty: function (animated, active, icon, iconSrc) {
                return (!animated || !active) && !icon && !iconSrc;
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._setAnchor(this.$.matIconButtonAnchor);
            }
        });
    </script>

</dom-module><xp-iconset name="navigation">
    <svg>
        <defs>
            <g id="apps"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"></path></g>
            <g id="arrow-back"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></g>
            <g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
            <g id="arrow-drop-down-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 12l-4-4h8l-4 4z"></path></g>
            <g id="arrow-drop-up"><path d="M7 14l5-5 5 5z"></path></g>
            <g id="arrow-forward"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></g>
            <g id="cancel"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"></path></g>
            <g id="check"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
            <g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
            <g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
            <g id="close"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
            <g id="expand-less"><path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"></path></g>
            <g id="expand-more"><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></g>
            <g id="fullscreen"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></g>
            <g id="fullscreen-exit"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path></g>
            <g id="menu"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></g>
            <g id="more-horiz"><path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
            <g id="more-vert"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
            <g id="refresh"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></g>
            <g id="unfold-less"><path d="M7.41 18.59L8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"></path></g>
            <g id="unfold-more"><path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"></path></g>
        </defs>
    </svg>
</xp-iconset><dom-module id="mat-menu-button" assetpath="../bower_components/mat-menu-button/">

    <style>
        :host {
            display: inline-block;
            margin: 4px;
            overflow: visible;
        }

        :host #matMenuButtonAdaptee {
            display: block;
            margin: 0 -4px;
        }
    </style>

    <template>
        <mat-icon-button id="matMenuButtonAdaptee" color="[[color]]" data="[[data]]" disabled="[[disabled]]" empty="{{empty}}" focused="{{focused}}" icon="[[icon]]" icon-src="[[iconSrc]]" pressed="{{pressed}}" raster="{{raster}}" target="{{target}}"></mat-icon-button>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-menu-button',

            // BEHAVIORS
            behaviors: [
                Polymer.XPTargeterBehavior
            ],

            /*********************************************************************/

            /**
             * Hides the menu.
             *
             * @method hide
             * @returns {Element}
             */
            hide: function () {
                var self = this, target = self.findTarget();
                if (target && target.hide) { target.hide(); }
                return self;
            },

            /**
             * Shows the menu.
             *
             * @method show
             * @returns {Element}
             */
            show: function () {
                var self = this, target = self.findTarget();
                if (target && target.show) { target.show(self, self.data); }
                return self;
            },

            /**
             * Toggles the menu.
             *
             * @method toggle
             * @returns {Element}
             */
            toggle: function () {
                var self = this, target = self.findTarget();
                if (target && target.toggle) { target.toggle(self, self.data); }
                return self;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'xp-activate': '_handleActivate'
            },

            // PROPERTIES
            properties: {

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is focused.
                 *
                 * @attribute focused
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                focused: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The button's icon.
                 *
                 * @attribute icon
                 * @type string
                 * @default "navigation:more-vert"
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'navigation:more-vert'
                },

                /**
                 * The button's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is pressed.
                 *
                 * @attribute pressed
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                pressed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                }
            },

            /*********************************************************************/

            // HANDLER
            _handleActivate: function (event) {
                var self = this;
                XP.delay(function () { return !event.defaultPrevented && self.show(); });
            }
        });
    </script>

</dom-module><dom-module id="mat-avatar" assetpath="../bower_components/mat-avatar/">

    <style>
:host {
    cursor: pointer;
    display: inline-block;
    outline: 0;
    overflow: visible;
    position: relative;
    text-align: left;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

:host([disabled]) {
    cursor: default !important;
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            border-radius: 50%;
            height: 40px;
            margin: 4px;
            width: 40px;
        }

        :host([big]) {
            height: 64px;
            margin: 0;
            width: 64px;
        }

        :host([empty]) {
            display: none !important;
        }

        :host #matAvatarWrapper,
        :host #matAvatarMain {
            border-radius: inherit;
            height: 100%;
            overflow: visible;
        }

        :host #matAvatarMain {
            @apply(--layout-horizontal);
            @apply(--layout-center-center);
        }

        :host([raster]) #matAvatarWrapper {
            background: transparent !important;
        }

        :host #matAvatarAnchor {
            border-radius: inherit;
            display: block;
            height: 100%;
            overflow: hidden;
            text-decoration: none;
        }

        :host(:not([big])) #matAvatarAnchor:after {
            bottom: -4px;
            content: "";
            left: -4px;
            position: absolute;
            right: -4px;
            top: -4px;
        }

        :host #matAvatarIcon {
            display: block;
            position: relative;
        }

        :host([raster]) #matAvatarIcon {
            border-radius: inherit;
            height: 100%;
            width: 100%;
        }

        :host([raster]) #matAvatarIcon::shadow #matIconAdaptee [icon] {
            box-shadow: 0 0 0 1px hsla(0, 0%, 0%, 0.12) inset;
        }
    </style>

    <template>
        <mat-paper id="matAvatarWrapper" background="[[_computeCurrentBackground(active, activeBackground, background)]]" brightness="placeholder" disabled="[[disabled]]" pressable="">
            <a id="matAvatarAnchor">
                <div id="matAvatarMain">
                    <mat-icon id="matAvatarIcon" color="[[_computeCurrentColor(active, activeColor, color)]]" disabled="[[disabled]]" empty="{{empty}}" name="[[icon]]" raster="{{raster}}" src="[[iconSrc]]"></mat-icon>
                </div>
            </a>
            <mat-ripple context="[[self]]" id="matAvatarRipple" color="[[_computeCurrentColor(active, activeColor, color)]]" auto-center=""></mat-ripple>
        </mat-paper>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-avatar',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAnchorBehavior,
                Polymer.XPPressedBehavior,
                Polymer.XPReferralBehavior
            ],

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The paper's active background color.
                 *
                 * @attribute active-background
                 * @type string
                 */
                activeBackground: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The ink's active color.
                 *
                 * @attribute active-color
                 * @type string
                 */
                activeColor: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The paper's background color.
                 *
                 * @attribute background
                 * @type string
                 */
                background: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element has 64px diameter instead of 40px.
                 *
                 * @attribute big
                 * @type boolean
                 * @default false
                 */
                big: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The button's icon.
                 *
                 * @attribute icon
                 * @type string
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The button's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                raster: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeCurrentBackground: function (active, activeBackground, background) {
                return (active && activeBackground) || background;
            },

            // COMPUTER
            _computeCurrentColor: function (active, activeColor, color) {
                return (active && activeColor) || color;
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._setAnchor(this.$.matAvatarAnchor);
            }
        });
    </script>

</dom-module><xp-iconset name="toggle">
    <svg>
        <defs>
            <g id="check-box"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
            <g id="check-box-outline-blank"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
            <g id="radio-button-off"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
            <g id="radio-button-on"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
            <g id="star"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
            <g id="star-half"><path d="M22 9.74l-7.19-.62L12 2.5 9.19 9.13 2 9.74l5.46 4.73-1.64 7.03L12 17.77l6.18 3.73-1.63-7.03L22 9.74zM12 15.9V6.6l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.9z"></path></g>
            <g id="star-outline"><path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"></path></g>
        </defs>
    </svg>
</xp-iconset><dom-module id="mat-checkbox" assetpath="../bower_components/mat-checkbox/">

    <style>
        :host {
            @apply(--mat-font-subhead);
            cursor: pointer;
            display: block;
            height: 48px;
            line-height: 48px !important; /* override */
            overflow: visible;
            text-overflow: ellipsis !important; /* override */
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-select: none;
            user-select: none;
            white-space: nowrap !important; /* override */
        }

        :host([disabled]) {
            cursor: not-allowed !important;
            pointer-events: none !important;
        }

        :host([empty-label]) {
            height: 40px;
            margin: 4px;
            width: 40px;
        }

        :host([flip]) {
            margin-right: -12px;
            text-align: right;
        }

        :host(:not([flip])) {
            margin-left: -12px;
            text-align: left;
        }

        :host ::content input {
            display: none !important;
        }

        :host #matCheckboxWrapper {
            height: 100%;
            position: relative;
        }

        :host([disabled]) #matCheckboxToggle[active]::shadow #matIconButtonIcon {
            display: none !important;
        }

        :host([empty-label]) #matCheckboxToggle {
            margin: 0;
        }

        :host(:not([empty-label])[flip]) #matCheckboxToggle {
            right: 0;
            position: absolute;
        }

        :host(:not([empty-label]):not([flip])) #matCheckboxToggle {
            left: 0;
            position: absolute;
        }

        :host #matCheckboxLabel {
            height: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        :host([flip]) #matCheckboxLabel {
            padding-right: 64px;
        }

        :host(:not([flip])) #matCheckboxLabel {
            padding-left: 64px;
        }

        /* ANIMATION */

        :host #matCheckboxToggle::shadow #matIconButtonIcon {
            -webkit-transform: scale(1);
            transform: scale(1);
            transition-delay: -0.05s;
        }

        :host #matCheckboxToggle[active]::shadow #matIconButtonIcon {
            opacity: 0;
            transition-delay: 0.1s;
        }

        :host #matCheckboxToggle::shadow #matIconButtonIcon #matIconWrapper {
            transition: color 0.4s;
        }
    </style>

    <template>
        <div id="matCheckboxWrapper">
            <mat-icon-button id="matCheckboxToggle" active="{{checked}}" active-color="teal" active-icon="toggle:check-box" disabled="[[disabled]]" focused="{{focused}}" icon="toggle:check-box-outline-blank" toggleable=""></mat-icon-button>
            <template is="dom-if" if="[[label]]"><mat-ink id="matCheckboxLabel" disabled="[[disabled]]" on-click="_handleToggle">{{label}}</mat-ink></template>
        </div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-checkbox',

            // BEHAVIORS
            behaviors: [
                Polymer.XPInputBehavior
            ],

            /*********************************************************************/

            /**
             * Blurs the input.
             *
             * @method blur
             * @returns {Element}
             */
            blur: function () {
                var self = this;
                self.$.matCheckboxToggle.blur();
                return self;
            },

            /**
             * Focuses the input
             *
             * @method focus
             * @returns {Element}
             */
            focus: function () {
                var self = this;
                self.$.matCheckboxToggle.focus();
                return self;
            },

            /*********************************************************************/

            /**
             * Commits from input's value.
             *
             * @method _commitFrom
             * @returns {Element}
             * @private
             */
            _commitFrom: function () {
                var self = this;
                self.checked = self.injected.checked;
                return self;
            },

            /**
             * Commits to input's value.
             *
             * @method _commitTo
             * @returns {Element}
             * @private
             */
            _commitTo: function () {
                var self = this;
                if (self.checked !== self.injected.checked) { self.injected.checked = self.checked; }
                return self;
            },

            /**
             * Indexes the input.
             *
             * @method _index
             * @param {number} value
             * @returns {Element}
             * @private
             */
            _index: function (value) {
                var self = this;
                self.$.matCheckboxToggle.tabIndex = value;
                return self;
            },

            /**
             * Injects the input element.
             *
             * @method _inject
             * @returns {Element}
             * @private
             */
            _inject: function () {
                var self = this;
                self._setInjected(XP.appendChild(Polymer.dom(self), XP.createElement('input', {attributes: {type: self.type, checked: self.checked}})));
                return self;
            },

            /**
             * Updates the input.
             *
             * @method _updateInput
             * @returns {Element}
             * @private
             */
            _update: function () {
                var self = this;
                XP.setAttribute(self.injected, 'disabled', self.disabled);
                XP.setAttribute(self.injected, 'name', self.name);
                return self;
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'keyup': '_handleToggle'
            },

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the check is right floated.
                 *
                 * @attribute flip
                 * @type boolean
                 * @default false
                 */
                flip: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The input's type.
                 *
                 * TODO Temporary webcomponents polyfill's fix for `hostAttributes`.
                 *
                 * @attribute type
                 * @type string
                 * @default "checkbox"
                 */
                type: {
                    observer: '_typeChanged',
                    reflectToAttribute: true,
                    type: String,
                    value: 'checkbox'
                }
            },

            /*********************************************************************/

            // HANDLER
            _handleToggle: function (event) {
                if (!event.button && (!event.keyCode || event.keyCode === 32)) { this.toggle(); }
            }
        });
    </script>

</dom-module><dom-module id="mat-divider" assetpath="../bower_components/mat-divider/">

    <style>
        :host {
            display: block;
            margin: 7px 0 8px 0;
            overflow: hidden;
            transition: margin 0.33s cubic-bezier(0.55, 0, 0.01, 1);
            will-change: margin;
        }

        :host([baseline]),
        :host([cap]) {
            left: 0;
            margin: 0;
            position: absolute;
            right: 0;
        }

        :host([baseline]) {
            bottom: 0;
        }

        :host([cap]) {
            top: 0;
        }

        :host #matDividerWrapper {
            border-top: 1px solid currentColor;
        }

        :host([inset]) #matDividerWrapper {
            margin-left: 72px;
        }
    </style>

    <template>
        <mat-ink id="matDividerWrapper" opacity="divider"></mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-divider',

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the divider is aligned baseline.
                 *
                 * @attribute baseline
                 * @type boolean
                 * @default false
                 */
                baseline: {
                    observer: '_baselineChanged',
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the divider is aligned cap.
                 *
                 * @attribute cap
                 * @type boolean
                 * @default false
                 */
                cap: {
                    observer: '_capChanged',
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is indented.
                 *
                 * @attribute inset
                 * @type boolean
                 * @default false
                 */
                inset: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                }
            },

            /*********************************************************************/

            // OBSERVER
            _baselineChanged: function (post) {
                this.cap = this.cap && !post;
            },

            // OBSERVER
            _capChanged: function (post) {
                this.baseline = this.baseline && !post;
            }
        });
    </script>

</dom-module><dom-module id="mat-item" assetpath="../bower_components/mat-item/">

    <style>
:host {
    cursor: pointer;
    display: inline-block;
    outline: 0;
    overflow: visible;
    position: relative;
    text-align: left;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

:host([disabled]) {
    cursor: default !important;
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            display: block;
            min-height: 48px;
            text-align: left;
        }

        :host [action] {
            margin: 4px 8px;
        }

        :host mat-avatar[action] {
            margin: 8px 16px;
        }

        :host [primary][action] {
            pointer-events: none;
        }

        :host(:not([empty-body])) [action] {
            margin-top: 8px;
        }

        :host(:not([empty-body])) mat-avatar[action] {
            margin-top: 16px;
        }

        :host(:not([empty-body])) [primary][action] {
            @apply(--layout-self-start);
        }

        :host #matItemWrapper,
        :host #matItemMain {
            @apply(--layout-horizontal);
            @apply(--layout-center);
        }

        :host #matItemPrimary {
            @apply(--layout-flex);
            overflow: hidden;
        }

        :host #matItemPrimary mat-avatar[action] {
            margin-right: 0;
        }

        :host #matItemAnchor {
            display: block;
            overflow: hidden;
            text-decoration: none;
        }

        :host #matItemAnchor[href]:hover {
            text-decoration: underline;
        }

        :host #matItemText {
            @apply(--layout-flex);
            overflow: hidden;
            padding: 11px 16px 13px 16px;
        }

        :host([empty-body]:not([empty-description])) #matItemText {
            padding: 15px 16px 13px 16px;
        }

        :host #matItemLabel {
            @apply(--mat-font-subhead);
            overflow: hidden;
            text-overflow: ellipsis !important; /* override */
            white-space: nowrap !important; /* override */
        }

        :host #matItemDescription {
            @apply(--mat-font-body);
            overflow: hidden;
            text-overflow: ellipsis !important; /* override */
            white-space: nowrap !important; /* override */
        }

        :host #matItemBody {
            @apply(--mat-font-body);
        }

        :host([empty-body]) #matItemBody {
            display: none !important;
        }

        :host #matItemSecondary {
            text-align: right;
        }

        :host([empty-secondary]) #matItemSecondary {
            display: none !important;
        }

        :host([secondary-no-tap]) #matItemSecondary {
            pointer-events: none !important;
        }

        :host([secondary-text]:not([secondary-text=""])) #matItemSecondary,
        :host(:not([empty-body])) #matItemSecondary {
            @apply(--layout-self-start);
        }

        :host #matItemSecondary [action] {
            margin-left: -8px;
        }

        :host #matItemSecondary mat-avatar[action] {
            margin-left: 0;
        }

        :host #matItemSecondaryText {
            @apply(--mat-font-caption);
            margin: 14px 16px 0 0;
        }

        :host([secondary-text=""]) #matItemSecondaryText,
        :host(:not([secondary-text])) #matItemSecondaryText {
            display: none !important;
        }

        :host([empty-body][primary-type="avatar"]) #matItemSecondaryText {
            margin-top: 18px;
        }

        :host #matItemDivider {
            display: none;
        }
    </style>

    <template>
        <mat-ink id="matItemWrapper" disabled="[[disabled]]">
            <mat-divider id="matItemDivider" inset="[[inset]]" baseline=""></mat-divider>
            <div id="matItemPrimary" on-xp-active="_handleStop" on-xp-activate="_handleStop" on-xp-input-change="_handleStop">
                <a id="matItemAnchor">
                    <div id="matItemMain">
                        <template is="dom-if" if="[[inset]]" restamp="">
                            <template is="dom-if" if="[[_isPrimaryAvatar(primaryType)]]" restamp=""><mat-avatar background="[[_computePrimaryBackground(active, primaryActiveBackground, primaryBackground)]]" color="[[_computePrimaryColor(active, primaryActiveColor, primaryColor)]]" icon="[[primaryIcon]]" icon-src="[[primaryIconSrc]]" tabindex="-1" primary="" action=""></mat-avatar></template>
                            <template is="dom-if" if="[[_isPrimaryButton(primaryType)]]" restamp=""><mat-icon-button active="[[active]]" active-icon="[[primaryActiveIcon]]" active-icon-src="[[primaryActiveIconSrc]]" color="[[_computePrimaryColor(active, primaryActiveColor, primaryColor)]]" icon="[[primaryIcon]]" icon-src="[[primaryIconSrc]]" tabindex="-1" toggleable="" primary="" action=""></mat-icon-button></template>
                            <template is="dom-if" if="[[_isPrimaryCheckbox(primaryType)]]" restamp=""><mat-checkbox model="[[active]]" tabindex="-1" primary="" action=""></mat-checkbox></template>
                        </template>
                        <div id="matItemText">
                            <template is="dom-if" if="[[label]]" restamp=""><div id="matItemLabel">{{label}}</div></template>
                            <template is="dom-if" if="[[description]]" restamp=""><mat-ink id="matItemDescription" opacity="secondary">{{description}}</mat-ink></template>
                            <div id="matItemBody"><content id="content"></content></div>
                        </div>
                    </div>
                </a>
            </div>
            <div id="matItemSecondary" on-xp-active="_handleSecondary" on-xp-activate="_handleSecondary" on-xp-input-change="_handleSecondary">
                <template is="dom-if" if="[[!emptySecondary]]" restamp="">
                    <template is="dom-if" if="[[secondaryText]]" restamp=""><div id="matItemSecondaryText">{{secondaryText}}</div></template>
                    <template is="dom-if" if="[[secondaryMenu]]" restamp=""><mat-menu-button color="[[secondaryColor]]" data="[[data]]" disabled="[[secondaryDisabled]]" target="{{secondaryMenu}}" tabindex="{{bindableTabIndex}}" on-down="_handleStop" on-click="_handleStop" on-up="_handleStop" secondary="" action=""></mat-menu-button></template>
                    <template is="dom-if" if="[[_isSecondaryAvatar(secondaryMenu, secondaryType)]]" restamp=""><mat-avatar active="{{secondaryActive}}" background="[[_computeSecondaryBackground(secondaryActive, secondaryActiveBackground, secondaryBackground)]]" color="[[_computeSecondaryColor(secondaryActive, secondaryActiveColor, secondaryColor)]]" data="[[data]]" disabled="[[secondaryDisabled]]" icon="[[secondaryIcon]]" icon-src="[[secondaryIconSrc]]" target="{{secondaryTarget}}" tabindex="{{bindableTabIndex}}" toggleable="[[secondaryToggleable]]" on-down="_handleStop" on-click="_handleStop" on-up="_handleStop" secondary="" action=""></mat-avatar></template>
                    <template is="dom-if" if="[[_isSecondaryButton(secondaryMenu, secondaryType)]]" restamp=""><mat-icon-button active="{{secondaryActive}}" active-icon="[[secondaryActiveIcon]]" active-icon-src="[[secondaryActiveIconSrc]]" color="[[_computeSecondaryColor(secondaryActive, secondaryActiveColor, secondaryColor)]]" data="[[data]]" disabled="[[secondaryDisabled]]" icon="[[secondaryIcon]]" icon-src="[[secondaryIconSrc]]" tabindex="[[bindableTabIndex]]" target="{{secondaryTarget}}" toggleable="[[secondaryToggleable]]" on-down="_handleStop" on-click="_handleStop" on-up="_handleStop" secondary="" action=""></mat-icon-button></template>
                    <template is="dom-if" if="[[_isSecondaryCheckbox(secondaryMenu, secondaryType)]]" restamp=""><mat-checkbox changed="{{secondaryChanged}}" disabled="[[secondaryDisabled]]" model="{{secondaryValue}}" tabindex="{{bindableTabIndex}}" on-down="_handleStop" on-click="_handleStop" on-up="_handleStop" secondary="" action=""></mat-checkbox></template>
                </template>
            </div>
            <mat-ripple context="[[self]]" id="matItemRipple"></mat-ripple>
        </mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-item',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAnchorBehavior,
                Polymer.XPPressedBehavior,
                Polymer.XPReferralBehavior
            ],

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * The item's description.
                 *
                 * @attribute description
                 * @type string
                 */
                description: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the body is hidden.
                 *
                 * @attribute empty-body
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                emptyBody: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the description is hidden.
                 *
                 * @attribute empty-description
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                emptyDescription: {
                    computed: '_computeEmptyDescription(description)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the label is hidden.
                 *
                 * @attribute empty-label
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                emptyLabel: {
                    computed: '_computeEmptyLabel(label)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the secondary is hidden.
                 *
                 * @attribute empty-secondary
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                emptySecondary: {
                    computed: '_computeEmptySecondary(secondaryType, secondaryIcon, secondaryIconSrc, secondaryMenu, secondaryText)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the element is indented.
                 *
                 * @attribute inset
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                inset: {
                    computed: '_computeInset(primaryActiveIcon, primaryActiveIconSrc, primaryIcon, primaryIconSrc, primaryType)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The item's label.
                 *
                 * @attribute label
                 * @type string
                 */
                label: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary active background.
                 *
                 * @attribute primary-active-background
                 * @type string
                 */
                primaryActiveBackground: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary active color.
                 *
                 * @attribute primary-active-color
                 * @type string
                 */
                primaryActiveColor: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary active icon.
                 *
                 * @attribute primary-active-icon
                 * @type string
                 */
                primaryActiveIcon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary active icon's src.
                 *
                 * @attribute primary-active-icon-src
                 * @type string
                 */
                primaryActiveIconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary background.
                 *
                 * @attribute primary-background
                 * @type string
                 */
                primaryBackground: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary color.
                 *
                 * @attribute primary-color
                 * @type string
                 */
                primaryColor: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary icon.
                 *
                 * @attribute primary-icon
                 * @type string
                 */
                primaryIcon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary icon's src.
                 *
                 * @attribute primary-icon-src
                 * @type string
                 */
                primaryIconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's primary type.
                 *
                 * @attribute primary-type
                 * @type string
                 * @default "button"
                 */
                primaryType: {
                    observer: '_primaryTypeChanged',
                    reflectToAttribute: true,
                    type: String,
                    value: 'button'
                },

                /**
                 * If set to true, the secondary is active.
                 *
                 * @attribute secondary-active
                 * @type boolean
                 * @default false
                 */
                secondaryActive: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The item's secondary active background.
                 *
                 * @attribute secondary-active-background
                 * @type string
                 */
                secondaryActiveBackground: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's secondary active color.
                 *
                 * @attribute secondary-active-color
                 * @type string
                 */
                secondaryActiveColor: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's secondary active icon.
                 *
                 * @attribute secondary-active-icon
                 * @type string
                 */
                secondaryActiveIcon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's secondary active icon's src.
                 *
                 * @attribute secondary-active-icon-src
                 * @type string
                 */
                secondaryActiveIconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's secondary background.
                 *
                 * @attribute secondary-background
                 * @type string
                 */
                secondaryBackground: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the secondary action is changed.
                 *
                 * @attribute secondary-changed
                 * @type boolean
                 * @default false
                 */
                secondaryChanged: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the secondary action is checked.
                 *
                 * @attribute secondary-value
                 * @type boolean
                 * @default false
                 */
                secondaryChecked: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The item's secondary background.
                 *
                 * @attribute secondary-color
                 * @type string
                 */
                secondaryColor: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the secondary action is disabled.
                 *
                 * @attribute secondary-disabled
                 * @type boolean
                 * @default false
                 */
                secondaryDisabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The item's secondary icon.
                 *
                 * @attribute secondary-icon
                 * @type string
                 */
                secondaryIcon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's secondary icon's src.
                 *
                 * @attribute secondary-icon-src
                 * @type string
                 */
                secondaryIconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The menu to toggle on secondary press.
                 *
                 * @attribute secondary-menu
                 * @type Element | string
                 * @notifies
                 */
                secondaryMenu: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the secondary action has pointer events disabled.
                 *
                 * @attribute secondary-no-tap
                 * @type boolean
                 * @default false
                 */
                secondaryNoTap: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The `id` of the secondary targeted element or the element itself.
                 *
                 * @attribute secondary-target
                 * @type Element | string
                 * @notifies
                 */
                secondaryTarget: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the secondary action is toggleable.
                 *
                 * @attribute secondary-toggleable
                 * @type boolean
                 * @default false
                 */
                secondaryToggleable: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The item's secondary text.
                 *
                 * @attribute secondary-text
                 * @type string
                 */
                secondaryText: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The item's secondary type.
                 *
                 * @attribute secondary-type
                 * @type string
                 * @default "button"
                 */
                secondaryType: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'button'
                }
            },

            /**
             * The bindable tabIndex.
             *
             * @property bindableTabIndex
             * @type number
             * @default -1
             * @readonly
             */
            bindableTabIndex: -1,

            /**
             * The list of types.
             *
             * @property types
             * @type Array
             * @default ["avatar", "button", "checkbox"]
             * @readonly
             */
            types: ['avatar', 'button', 'checkbox'],

            /*********************************************************************/

            // COMPUTER
            _computeEmptyDescription: function (description) {
                return !description;
            },

            // COMPUTER
            _computeEmptyLabel: function (label) {
                return !label;
            },

            // COMPUTER
            _computeEmptySecondary: function (secondaryType, secondaryIcon, secondaryIconSrc, secondaryMenu, secondaryText) {
                return secondaryType !== 'checkbox' && !secondaryIcon && !secondaryIconSrc && !secondaryMenu && !secondaryText;
            },

            // COMPUTER
            _computeInset: function (primaryActiveIcon, primaryActiveIconSrc, primaryIcon, primaryIconSrc, primaryType) {
                return !!primaryActiveIcon || !!primaryActiveIconSrc || !!primaryIcon || !!primaryIconSrc || primaryType === "checkbox";
            },

            // COMPUTER
            _computePrimaryBackground: function (active, primaryActiveBackground, primaryBackground) {
                return (active && primaryActiveBackground) || primaryBackground;
            },

            // COMPUTER
            _computePrimaryColor: function (active, primaryActiveColor, primaryColor) {
                return (active && primaryActiveColor) || primaryColor;
            },

            // COMPUTER
            _computeSecondaryBackground: function (secondaryActive, secondaryActiveBackground, secondaryBackground) {
                return (secondaryActive && secondaryActiveBackground) || secondaryBackground;
            },

            // COMPUTER
            _computeSecondaryColor: function (secondaryActive, secondaryActiveColor, secondaryColor) {
                return (secondaryActive && secondaryActiveColor) || secondaryColor;
            },

            // COMPUTER
            _isPrimaryAvatar: function (primaryType) {
                return primaryType === 'avatar';
            },

            // COMPUTER
            _isPrimaryButton: function (primaryType) {
                return primaryType !== 'avatar' && primaryType !== 'checkbox';
            },

            // COMPUTER
            _isPrimaryCheckbox: function (primaryType) {
                return primaryType === 'checkbox';
            },

            // COMPUTER
            _isSecondaryAvatar: function (secondaryMenu, secondaryType) {
                return !secondaryMenu && secondaryType === 'avatar';
            },

            // COMPUTER
            _isSecondaryButton: function (secondaryMenu, secondaryType) {
                return !secondaryMenu && secondaryType !== 'avatar' && secondaryType !== 'checkbox';
            },

            // COMPUTER
            _isSecondaryCheckbox: function (secondaryMenu, secondaryType) {
                return !secondaryMenu && secondaryType === 'checkbox';
            },

            /*********************************************************************/

            // OBSERVER
            _primaryTypeChanged: function (post) {
                if (post === 'checkbox') { this.toggleable = true; }
            },

            /*********************************************************************/

            // LISTENER
            attached: function () {
                this.mutated();
            },

            // LISTENER
            mutated: function () {

                // Vars
                var self = this;

                // Setting
                self._setEmptyBody(!XP.isContent(Polymer.dom(self.$.content), true));
                self.bindableTabIndex = self.tabIndex;

                // Observing
                XP.onMutation(self, self.mutated.bind(self), {attributes: true, childList: true, subtree: true, attributeFilter: ['tabindex']});
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._setAnchor(this.$.matItemAnchor);
            },

            /*********************************************************************/

            // HANDLER
            _handleSecondary: function (event) {
                var self = this;
                if (XP.matches(event.detail.firer, '[secondary][action]')) { event.stopPropagation(); } else { return; }
                if (self.fire(event.type, XP.assign(event.detail, {firer: self, isSecondary: true}), {cancelable: true}).defaultPrevented) { event.preventDefault(); }
            },

            // HANDLER
            _handleStop: function (event) {
                event.stopPropagation();
            }
        });
    </script>

</dom-module><dom-module id="mat-menu-label-button" assetpath="../bower_components/mat-menu-label-button/">

    <style>
        :host {
            display: inline-block;
            /*margin: 4px;*/
            overflow: visible;
            opacity: 0.8;
        }

        :host #matMenuButtonAdaptee {
            display: block;
            margin: 0 -4px;
        }

        .label {
            font-size: 20px;
        }
        .label.white{
            color: white;
        }
        mat-item{
            min-height: 45px;
        }
    </style>

    <template>
        
           
        <mat-item target="{{target}}" data="[[data]]" disabled="[[disabled]]" empty="{{empty}}" focused="{{focused}}" pressed="{{pressed}}" raster="{{raster}}" primary-color="white">
        <div class="label white" fit=""><span>{{label}}</span> <iron-icon style="top: 5px;vertical-align: inherit;" icon="arrow-drop-down-circle"></iron-icon></div>
            <mat-ripple color="#FFFFFF"></mat-ripple>
        </mat-item>
    </template>

    <script>
        Polymer({
            // ELEMENT
            is: 'mat-menu-label-button',
            // BEHAVIORS
            behaviors: [
                Polymer.XPTargeterBehavior
            ],
            /*********************************************************************/
            /**
             * Hides the menu.
             *
             * @method hide
             * @returns {Element}
             */
            hide: function () {
                var self = this, target = self.findTarget();
                if (target && target.hide) {
                    target.hide();
                }
                return self;
            },
            /**
             * Shows the menu.
             *
             * @method show
             * @returns {Element}
             */
            show: function () {
                var self = this, target = self.findTarget();
                if (target && target.show) {
                    target.show(self, self.data);
                }
                return self;
            },
            /**
             * Toggles the menu.
             *
             * @method toggle
             * @returns {Element}
             */
            toggle: function () {
                var self = this, target = self.findTarget();
                if (target && target.toggle) {
                    target.toggle(self, self.data);
                }
                return self;
            },
            /*********************************************************************/
            // LISTENERS
            listeners: {
                'xp-activate': '_handleActivate'
            },
            // PROPERTIES
            properties: {
                /**
                 * The ink's color.
                 *
                 * @attribute color
                 * @type string
                 */
                color: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },
                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },
                /**
                 * If set to true, the element is disabled.
                 *
                 * @attribute disabled
                 * @type boolean
                 * @default false
                 */
                disabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },
                /**
                 * If set to true, the element is focused.
                 *
                 * @attribute focused
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                focused: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },
                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },
                /**
                 * The button's icon.
                 *
                 * @attribute icon
                 * @type string
                 * @default "navigation:more-vert"
                 */
                label: {
                    /*reflectToAttribute: true,*/
                    type: String
                    /* value: ''*/
                },
                /**
                 * The button's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },
                /**
                 * If set to true, the element is pressed.
                 *
                 * @attribute pressed
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                pressed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },
                /**
                 * If set to true, the icon is a raster one instead of svg.
                 *
                 * @attribute raster
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                raster: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                }
            },
            /*********************************************************************/
            // HANDLER
            _handleActivate: function (event) {
                var self = this;
                XP.delay(function () {
                    return !event.defaultPrevented && self.show();
                });
            }
        });
    </script>

</dom-module><dom-module id="mat-option" assetpath="../bower_components/mat-option/">

    <style>
:host {
    cursor: pointer;
    display: inline-block;
    outline: 0;
    overflow: visible;
    position: relative;
    text-align: left;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

:host([disabled]) {
    cursor: default !important;
    pointer-events: none !important;
}
</style>

    <style>
        :host {
            @apply(--mat-font-subhead);
            display: block;
            height: 48px;
            text-align: left;
            text-overflow: ellipsis !important; /* override */
            white-space: nowrap !important; /* override */
        }

        :host #matOptionWrapper,
        :host #matOptionMain {
            height: 100%;
        }

        :host #matOptionMain {
            @apply(--layout-horizontal);
            @apply(--layout-center);
        }

        :host #matOptionAnchor {
            display: block;
            height: 100%;
            overflow: hidden;
            text-decoration: none;
        }

        :host #matOptionAnchor[href]:hover {
            text-decoration: underline;
        }

        :host #matOptionMain {
            padding: 0 16px;
        }

        :host #matOptionIcon {
            margin-right: 24px;
        }

        :host #matOptionIcon[empty] {
            display: block !important;
            opacity: 0 !important;
            visibility: hidden !important;
        }

        :host #matOptionLabel {
            overflow: hidden;
        }

        :host #matOptionSpacer {
            @apply(--layout-flex);
        }
    </style>

    <template>
        <mat-ink id="matOptionWrapper" disabled="[[disabled]]">
            <a id="matOptionAnchor">
                <div id="matOptionMain">
                    <template is="dom-if" if="[[_hasIcon(toggleable, icon, iconSrc)]]" restamp=""><mat-icon id="matOptionIcon" disabled="[[disabled]]" name="[[_computeIcon(toggleable, icon, active)]]" src="[[_computeIconSrc(toggleable, iconSrc)]]"></mat-icon></template>
                    <div id="matOptionLabel">{{_computeLabel(label, value)}}</div>
                    <div id="matOptionSpacer"></div>
                    <template is="dom-if" if="[[_hasSecondaryText(secondaryText, secondaryIcon, secondaryIconSrc)]]" restamp=""><div id="matOptionSecondaryText">{{secondaryText}}</div></template>
                    <template is="dom-if" if="[[_hasSecondaryIcon(secondaryIcon, secondaryIconSrc)]]" restamp=""><mat-icon id="matOptionSecondaryIcon" disabled="[[disabled]]" name="[[secondaryIcon]]" opacity="hint" src="[[secondaryIconSrc]]"></mat-icon></template>
                </div>
            </a>
            <mat-ripple context="[[self]]" id="matOptionRipple"></mat-ripple>
        </mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-option',

            // BEHAVIORS
            behaviors: [
                Polymer.XPAnchorBehavior,
                Polymer.XPPressedBehavior,
                Polymer.XPReferralBehavior
            ],

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * The element's data.
                 *
                 * @attribute data
                 * @type *
                 * @notifies
                 */
                data: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    computed: '_computeEmpty(label)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The option's icon.
                 *
                 * @attribute icon
                 * @type string
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is indented.
                 *
                 * @attribute inset
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                inset: {
                    computed: '_computeInset(toggleable, icon, iconSrc)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The option's label.
                 *
                 * @attribute label
                 * @type string
                 */
                label: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's secondary icon.
                 *
                 * @attribute secondary-icon
                 * @type string
                 */
                secondaryIcon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's secondary icon's src.
                 *
                 * @attribute secondary-icon-src
                 * @type string
                 */
                secondaryIconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's secondary text.
                 *
                 * @attribute secondary-text
                 * @type string
                 */
                secondaryText: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The option's value.
                 *
                 * @attribute value
                 * @type string
                 * @default ""
                 */
                value: {
                    reflectToAttribute: true,
                    type: String,
                    value: ''
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeEmpty: function (label) {
                return !label;
            },

            // COMPUTER
            _computeIcon: function (toggleable, icon, active) {
                return !toggleable ? icon : (active ? 'navigation:check' : '');
            },

            // COMPUTER
            _computeIconSrc: function (toggleable, iconSrc) {
                return !toggleable ? iconSrc : '';
            },

            // COMPUTER
            _computeInset: function (toggleable, icon, iconSrc) {
                return toggleable || !!icon || !!iconSrc;
            },

            // COMPUTER
            _computeLabel: function (label, value) {
                return label || value;
            },

            // COMPUTER
            _hasIcon: function (toggleable, icon, iconSrc) {
                return toggleable || !!icon || !!iconSrc;
            },

            // COMPUTER
            _hasSecondaryIcon: function (secondaryIcon, secondaryIconSrc) {
                return !!secondaryIcon || !!secondaryIconSrc;
            },

            // COMPUTER
            _hasSecondaryText: function (secondaryText, secondaryIcon, secondaryIconSrc) {
                return !!secondaryText && !secondaryIcon && !secondaryIconSrc;
            },

            /*********************************************************************/

            // LISTENER
            ready: function () {
                this._setAnchor(this.$.matOptionAnchor);
            }
        });
    </script>

</dom-module><dom-module id="xp-list" assetpath="../bower_components/xp-list/">

    <style>
        :host {
            display: block;
            overflow: visible;
        }
    </style>

    <template>
        <template is="xp-master-state" id="xpMasterState" slaves="{{sublists}}" slave-tag="xp-sublist"></template>
        <content id="content"></content>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-list',

            // BEHAVIORS
            behaviors: [
                Polymer.XPSelectedBehavior
            ],

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'click': '_handleClick',
                'selection-changed': '_handleSelection'
            },

            // PROPERTIES
            properties: {

                /**
                 * If set to true, a sublist expansion wont collapse the siblings.
                 *
                 * @attribute auto-collapse-disabled
                 * @type boolean
                 * @default false
                 */
                autoCollapseDisabled: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the selectable items are searched deep.
                 *
                 * TODO Temporary webcomponents polyfill's fix for `hostAttributes`.
                 *
                 * @attribute deep
                 * @type boolean
                 * @default true
                 */
                deep: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: true
                },

                /**
                 * The slave sublists.
                 *
                 * @attribute sublists
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                sublists: {
                    notify: true,
                    type: Array
                }
            },

            /*********************************************************************/

            // HANDLER
            _handleClick: function (event) {

                // Checking
                if (event.button) { return; }

                // Vars
                var self   = this,
                    target = event.target,
                    item   = self.findItem(target) || self.findItem(XP.findParentElement(Polymer.dom(target), self.itemSelector, self));

                // Switching
                if (item && self[self.isSelected(item, true) ? 'isUnselectable' : 'isSelectable'](item, true)) { self.switch(item, false, true); }
            },

            // HANDLER
            _handleSelection: function () {

                // Vars
                var self      = this,
                    superlist = self.selection && !self.multi && XP.findParentElement(Polymer.dom(self.selection), 'xp-sublist', self);

                // Expanding
                if (superlist) { superlist.expand(); }
            }
        });
    </script>

</dom-module><dom-module id="mat-list" assetpath="../bower_components/mat-list/">

    <style>
        :host {
            display: block;
            overflow: visible;
        }

        :host #matListWrapper {
            padding: 8px 0;
        }

        :host #matListWrapper ::content [item=""] {
            @apply(--mat-font-subhead);
            cursor: pointer;
            display: block;
            line-height: 48px !important; /* override */
            min-height: 48px;
            outline: 0;
            padding: 0 16px;
            text-align: left;
            text-decoration: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        :host #matListWrapper ::content [item=""][href]:hover {
            text-decoration: underline;
        }

        :host #matListWrapper[foreground="dark"] ::content [item=""][active] {
            background: hsla(0, 0%, 0%, 0.12);
        }

        :host #matListWrapper[foreground="light"] ::content [item=""][active] {
            background: hsla(0, 0%, 100%, 0.12);
        }

        :host #matListWrapper[foreground="dark"] ::content > [item=""]:not(:last-of-type) {
            border-bottom: 1px solid hsla(0, 0%, 0%, 0.12);
            margin-bottom: -1px;
        }

        :host #matListWrapper[foreground="light"] ::content > [item=""]:not(:last-of-type) {
            border-bottom: 1px solid hsla(0, 0%, 100%, 0.12);
            margin-bottom: -1px;
        }

        :host #matListWrapper ::content > mat-item[active] #matItemRipple #matRippleBackground {
            opacity: 0.10;
        }

        :host #matListWrapper ::content > mat-item:not(:last-of-type) #matItemDivider {
            display: block;
        }

        :host #matListWrapper ::content mat-sublist + mat-sublist[collapsible]:not([collapsed]) > #matSublistWrapper > #matSublistDividerTop,
        :host #matListWrapper ::content mat-sublist[collapsible]:not([collapsed]):not(:last-of-type) > #matSublistWrapper > #matSublistDividerBottom,
        :host #matListWrapper ::content mat-sublist:not([collapsible]):not(:last-of-type) > #matSublistWrapper > #matSublistDividerBottom {
            height: auto;
            margin: 7px 0 8px 0;
        }

        :host #matListWrapper ::content > mat-subheader,
        :host #matListWrapper ::content mat-sublist:not([collapsible]):not([empty-label]) {
            margin-top: -8px;
        }
    </style>

    <template>
        <template is="xp-master-state" id="xpMasterState" slaves="{{sublists}}" slave-tag="mat-sublist"></template>
        <xp-list context="[[self]]" id="matListAdaptee" default-selected="[[defaultSelected]]" empty-items="{{emptyItems}}" index-attribute="[[indexAttribute]]" initialized="{{initialized}}" ismutated="{{isMutated}}" items="{{items}}" item-selector="[[itemSelector]]" multi="[[multi]]" mutating="{{mutating}}" selected="{{selected}}" selecting="{{selecting}}" selection="{{selection}}" single-item="{{singleItem}}" switchable="[[switchable]]" target="{{target}}">
            <mat-ink id="matListWrapper"><content id="content"></content></mat-ink>
        </xp-list>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-list',

            // BEHAVIORS
            behaviors: [
                Polymer.XPReferralBehavior,
                Polymer.XPTargeterBehavior
            ],

            /*********************************************************************/

            /**
             * Finds an item's index.
             *
             * @method findIndex
             * @param {Element | Function | number | string} identity
             * @returns {number | string}
             */
            findIndex: function (identity) {
                return this.$.matListAdaptee.findIndex(identity);
            },

            /**
             * Finds an item.
             *
             * @method findItem
             * @param {Element | Function | number | string} identity
             * @returns {Element}
             */
            findItem: function (identity) {
                return this.$.matListAdaptee.findItem(identity);
            },

            /**
             * Finds items filtered by predicate.
             *
             * @method findItems
             * @param {Function} [predicate]
             * @returns {Array}
             */
            findItems: function (predicate) {
                return this.$.matListAdaptee.findItems(predicate);
            },

            /**
             * Finds an item's index, iterating from right to left.
             *
             * @method findLastIndex
             * @param {Element | Function | number | string} identity
             * @returns {number | string}
             */
            findLastIndex: function (identity) {
                return this.$.matListAdaptee.findLastIndex(identity);
            },

            /**
             * Finds an item, iterating from right to left.
             *
             * @method findLastItem
             * @param {Element | Function | number | string} identity
             * @returns {Element}
             */
            findLastItem: function (identity) {
                return this.$.matListAdaptee.findLastItem(identity);
            },

            /**
             * Checks if an item is selectable.
             *
             * @method isSelectable
             * @param {Element | Function | number | string} identity
             * @returns {boolean}
             */
            isSelectable: function (identity) {
                return this.$.matListAdaptee.isSelectable(identity);
            },

            /**
             * Checks if an item is selected.
             *
             * @method isSelected
             * @param {Element | Function | number | string} identity
             * @returns {boolean}
             */
            isSelected: function (identity) {
                return this.$.matListAdaptee.isSelected(identity);
            },

            /**
             * Checks if an item is unselectable.
             *
             * @method isUnselectable
             * @param {Element | Function | number | string} identity
             * @param {boolean} [force = false]
             * @returns {boolean}
             */
            isUnselectable: function (identity, force) {
                return this.$.matListAdaptee.isUnselectable(identity, force);
            },

            /**
             * Resets the selection.
             *
             * @method reset
             * @returns {Element}
             */
            reset: function () {
                return this.$.matListAdaptee.reset() && this;
            },

            /**
             * Selects an item.
             *
             * @method select
             * @param {Element | Function | number | string} identity
             * @returns {Element}
             */
            select: function (identity) {
                return this.$.matListAdaptee.select(identity);
            },

            /**
             * Selects all items.
             *
             * @method selectAll
             * @param {Function} [predicate]
             * @returns {Array}
             */
            selectAll: function (predicate) {
                return this.$.matListAdaptee.selectAll(predicate);
            },

            /**
             * Selects the next item.
             *
             * @method selectNext
             * @returns {Element}
             */
            selectNext: function () {
                return this.$.matListAdaptee.selectNext();
            },

            /**
             * Selects the previous item.
             *
             * @method selectPrevious
             * @returns {Element}
             */
            selectPrevious: function () {
                return this.$.matListAdaptee.selectPrevious();
            },

            /**
             * Toggles active state on an item.
             *
             * @method switch
             * @param {Element | Function | number | string} identity
             * @param {boolean} [force = false]
             * @returns {Element}
             */
            switch: function (identity, force) {
                return this.$.matListAdaptee.switch(identity, force);
            },

            /**
             * Toggles active state on all items.
             *
             * @method switchAll
             * @param {Function} [predicate]
             * @param {boolean} [force = false]
             * @returns {Array}
             */
            switchAll: function (predicate, force) {
                return this.$.matListAdaptee.switchAll(predicate, force);
            },

            /**
             * Unselects an item.
             *
             * @method unselect
             * @param {Element | Function | number | string} identity
             * @param {boolean} [force = false]
             * @returns {Element}
             */
            unselect: function (identity, force) {
                return this.$.matListAdaptee.unselect(identity, force);
            },

            /**
             * Unselects all items.
             *
             * @method unselectAll
             * @param {Function} [predicate]
             * @param {boolean} [force = false]
             * @returns {Array}
             */
            unselectAll: function (predicate, force) {
                return this.$.matListAdaptee.unselectAll(predicate, force);
            },

            /*********************************************************************/

            // LISTENERS
            listeners: {
                'selection-changed': '_handleSelection'
            },

            // PROPERTIES
            properties: {

                /**
                 * The index of the item to select by default.
                 *
                 * @attribute default-selected
                 * @type number | string
                 */
                defaultSelected: {
                    value: null
                },

                /**
                 * If set to true, there are no items.
                 *
                 * @attribute empty-items
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                emptyItems: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The attribute used as index.
                 *
                 * @attribute index-attribute
                 * @type string
                 */
                indexAttribute: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the selector is initialized.
                 *
                 * @attribute initialized
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                initialized: {
                    notify: true,
                    type: Boolean
                },

                /**
                 * If set to true, the mutation observer is set.
                 *
                 * @attribute is-mutated
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                isMutated: {
                    notify: true,
                    type: Boolean
                },

                /**
                 * The selector used to recognize selectable items.
                 *
                 * @attribute item-selector
                 * @type string
                 * @default "[selectable]"
                 */
                itemSelector: {
                    reflectToAttribute: true,
                    type: String,
                    value: '[selectable]'
                },

                /**
                 * The selectable items.
                 *
                 * @attribute items
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                items: {
                    notify: true,
                    type: Array
                },

                /**
                 * If set to true, multi selection is allowed.
                 *
                 * @attribute multi
                 * @type boolean
                 * @default false
                 */
                multi: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the selector is currently mutating.
                 *
                 * @attribute mutating
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                mutating: {
                    notify: true,
                    type: Boolean
                },

                /**
                 * The selected item's index.
                 *
                 * @attribute selected
                 * @type Array | number | string
                 * @notifies
                 */
                selected: {
                    notify: true,
                    value: null
                },

                /**
                 * The attribute set on selection.
                 *
                 * @attribute selected-attribute
                 * @type string
                 * @default "active"
                 */
                selectedAttribute: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'active'
                },

                /**
                 * If set to true, the selection is about to change.
                 *
                 * @attribute selecting
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                selecting: {
                    notify: true,
                    type: Boolean
                },

                /**
                 * The selected item.
                 *
                 * @attribute selection
                 * @type Element
                 * @notifies
                 * @readonly
                 */
                selection: {
                    notify: true,
                    value: null
                },

                /**
                 * If set to true, there's only one item.
                 *
                 * @attribute single-item
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                singleItem: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The slave sublists.
                 *
                 * @attribute sublists
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                sublists: {
                    notify: true,
                    type: Array
                },

                /**
                 * If set to true, the unselection is allowed even if not multi.
                 *
                 * @attribute switchable
                 * @type boolean
                 * @default false
                 */
                switchable: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                }
            },

            /*********************************************************************/

            // HANDLER
            _handleSelection: function () {

                // Vars
                var self      = this,
                    superlist = self.selection && !self.multi && XP.findParentElement(Polymer.dom(self.selection), 'mat-sublist[collapsible]', self);

                // Expanding
                if (superlist) { superlist.expand(); }
            }
        });
    </script>

</dom-module><dom-module id="mat-subheader" assetpath="../bower_components/mat-subheader/">

    <style>
        :host {
            @apply(--mat-font-menu);
            display: block;
            height: 48px;
            line-height: 48px !important; /* override */
            overflow: visible;
            text-align: left;
        }

        :host #matSubheaderMain {
            overflow: hidden;
            padding: 0 16px;
        }

        :host([inset]) #matSubheaderMain {
            padding-left: 72px;
        }
    </style>

    <template>
        <mat-ink id="matSubheaderWrapper" opacity="secondary">
            <div id="matSubheaderMain">{{label}}</div>
        </mat-ink>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-subheader',

            /*********************************************************************/

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                empty: {
                    computed: '_computeEmpty(label)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * If set to true, the element is indented.
                 *
                 * @attribute inset
                 * @type boolean
                 * @default false
                 */
                inset: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The subheader's label
                 *
                 * @attribute label
                 * @type string
                 */
                label: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeEmpty: function (label) {
                return !label;
            }
        });
    </script>

</dom-module><dom-module id="xp-collapse" assetpath="../bower_components/xp-collapse/">

    <style>
        :host {
            display: block;
            overflow: hidden;
        }

        :host #xpCollapseWrapper {
            position: relative;
        }

        :host([empty]) #xpCollapseWrapper,
        :host([collapsed]:not([animated])) #xpCollapseWrapper {
            display: none !important;
        }
    </style>

    <template>
        <div id="xpCollapseWrapper">
            <content id="content"></content>
        </div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-collapse',

            /*********************************************************************/

            /**
             * Fired when the collapsed state changes.
             *
             * @event xp-collapse
             * @param {Element} firer
             * @param {boolean} isCollapsed
             * @bubbles
             */

            /*********************************************************************/

            /**
             * Collapses the element.
             *
             * @method collapse
             * @returns {Element}
             */
            collapse: function () {
                var self = this;
                self.collapsed = true;
                return self;
            },

            /**
             * Expands the element.
             *
             * @method expand
             * @returns {Element}
             */
            expand: function () {
                var self = this;
                self.collapsed = false;
                return self;
            },

            /**
             * Toggles the collapsed state.
             *
             * @method toggle
             * @returns {Element}
             */
            toggle: function () {
                return this[this.collapsed ? 'expand' : 'collapse']();
            },

            /*********************************************************************/

            /**
             * Animates the element
             *
             * @method _animate
             * @returns {Element}
             * @private
             */
            _animate: function () {

                // Vars
                var self     = this,
                    animated = self.animated,
                    duration = self.duration / 1000,
                    easing   = self.easing,
                    wrapper  = self.$.xpCollapseWrapper;

                // Setting
                if (self.animatable) { self._setAnimated(true); } else { return self; }

                // Frame 1
                XP.requestAnimationFrame(function () {

                    // Preparing
                    if (!animated) {
                        XP.setStyle(wrapper, 'transition', 'margin-bottom 0s, margin-top 0s');
                        XP.setStyle(wrapper, 'margin-top', !self.backward ? null : (self.collapsed ? 0 : -wrapper.scrollHeight + 'px'));
                        XP.setStyle(wrapper, 'margin-bottom', self.backward ? null : (self.collapsed ? 0 : -wrapper.scrollHeight + 'px'));
                    }

                    // Frame 2
                    XP.requestAnimationFrame(function () {

                        // Animating
                        XP.setStyle(wrapper, 'transition', 'margin-bottom ' + duration + 's ' + easing + ', margin-top ' + duration + 's ' + easing);
                        XP.setStyle(wrapper, 'margin-top', !self.backward ? null : (self.collapsed ? -wrapper.scrollHeight + 'px' : 0));
                        XP.setStyle(wrapper, 'margin-bottom', self.backward ? null : (self.collapsed ? -wrapper.scrollHeight + 'px' : 0));

                        // Debouncing
                        self._jobAnimation();
                    });
                });

                return self;
            },

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {
                var self = this;
                self._jobAnimation = XP.debounce(function () { self._setAnimated(false); }, self.duration);
                return self;
            },

            /*********************************************************************/

            // OBSERVERS
            observers: [
                '_refresh(duration)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the animation can be executed.
                 *
                 * @attribute animatable
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                animatable: {
                    notify: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the collapse animation is running.
                 *
                 * @attribute animated
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                animated: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the animation will act like a slide instead of a compress.
                 *
                 * @attribute backward
                 * @type boolean
                 * @default false
                 */
                backward: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the element is collapsed.
                 *
                 * @attribute collapsed
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                collapsed: {
                    notify: true,
                    observer: '_collapsedChanged',
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The animation's duration.
                 *
                 * @attribute duration
                 * @type number
                 * @default 330
                 */
                duration: {
                    reflectToAttribute: true,
                    type: Number,
                    value: 330
                },

                /**
                 * The animation's easing.
                 *
                 * @attribute easing
                 * @type string
                 * @default ease
                 */
                easing: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'ease'
                },

                /**
                 * If set to true, the element is hidden.
                 *
                 * @attribute empty
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                empty: {
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                }
            },

            /*********************************************************************/

            // OBSERVER
            _collapsedChanged: function (post) {
                this.fire('xp-collapse', {firer: this._animate(), isCollapsed: post});
            },

            /*********************************************************************/

            // LISTENER
            attached: function () {
                var self = this;
                self.mutated();
                XP.delay(function () { self.animatable = true; });
            },

            // LISTENER
            mutated: function () {
                var self = this;
                self._setEmpty(!XP.isContent(Polymer.dom(self.$.content), true));
                XP.onMutation(self, self.mutated.bind(self));
            }
        });
    </script>

</dom-module><dom-module id="xp-sublist" assetpath="../bower_components/xp-list/">

    <style>
        :host {
            display: block;
            overflow: visible;
        }
    </style>

    <template>
        <template is="xp-master-state" id="xpMasterState" slaves="{{sublists}}" slave-tag="xp-sublist"></template>
        <template is="xp-slave-state" master="{{list}}" master-tag="xp-list"></template>
        <template is="xp-slave-state" master="{{superlist}}" master-tag="xp-sublist"></template>
        <xp-collapse id="xpSublistWrapper" animatable="{{animatable}}" backward="[[backward]]" collapsed="{{collapsed}}" duration="[[duration]]" easing="[[easing]]">
            <content id="content"></content>
        </xp-collapse>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'xp-sublist',

            /*********************************************************************/

            /**
             * Collapses the sublist.
             *
             * @method collapse
             * @returns {Element}
             */
            collapse: function () {
                var self = this;
                self.$.xpSublistWrapper.collapse();
                return self;
            },

            /**
             * Expands the sublist.
             *
             * @method expand
             * @returns {Element}
             */
            expand: function () {
                var self = this;
                self.$.xpSublistWrapper.expand();
                return self;
            },

            /**
             * Toggles the collapsed state.
             *
             * @method toggle
             * @returns {Element}
             */
            toggle: function () {
                var self = this;
                self.$.xpSublistWrapper.toggle();
                return self;
            },

            /*********************************************************************/

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {

                // Vars
                var self = this;

                // Checking
                if (!self.isAttached || !self.list) { return self; }

                // Ensuring
                if (!self.collapsible) { self.collapsed = false; }

                // Collapsing
                if (!self.collapsed && self.collapsible && !self.list.autoCollapseDisabled) { XP.invoke(XP.findSiblingElements(self, 'xp-sublist'), 'collapse'); }

                // Expanding
                if (!self.collapsed && self.collapsible && self.superlist) { self.superlist.expand(); }

                return self;
            },

            /*********************************************************************/

            // OBSERVERS
            observers: [
                '_refresh(collapsed, collapsible, list)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the animation can be executed.
                 *
                 * @attribute animatable
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                animatable: {
                    notify: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the animation will act like a slide instead of a compress.
                 *
                 * @attribute backward
                 * @type boolean
                 * @default false
                 */
                backward: {
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the sublist is collapsed.
                 *
                 * @attribute collapsed
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                collapsed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the sublist is collapsible.
                 *
                 * @attribute collapsible
                 * @type string
                 * @default false
                 * @notifies
                 */
                collapsible: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * The animation's duration.
                 *
                 * @attribute duration
                 * @type number
                 * @default 330
                 */
                duration: {
                    reflectToAttribute: true,
                    type: Number,
                    value: 330
                },

                /**
                 * The animation's easing.
                 *
                 * @attribute easing
                 * @type string
                 * @default "ease"
                 */
                easing: {
                    reflectToAttribute: true,
                    type: String,
                    value: 'ease'
                },

                /**
                 * The master list.
                 *
                 * @attribute list
                 * @type Element
                 * @notifies
                 */
                list: {
                    notify: true,
                    value: null
                },

                /**
                 * The slave sublists.
                 *
                 * @attribute sublists
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                sublists: {
                    notify: true,
                    type: Array
                },

                /**
                 * The master sublist.
                 *
                 * @attribute superlist
                 * @type Element
                 * @notifies
                 */
                superlist: {
                    notify: true,
                    observer: '_superlistChanged',
                    value: null
                }
            },

            /*********************************************************************/

            // OBSERVER
            _superlistChanged: function (post, pre) {

                // Vars
                var self = this;

                // Checking
                if (arguments.length < 2) { return; }

                // Listening
                if (pre) { self.unlisten(pre, 'collapsed-changed', '_handleCollapsed'); }
                if (post) { self.listen(post, 'collapsed-changed', '_handleCollapsed'); }

                // Handling
                self._handleCollapsed();
            },

            /*********************************************************************/

            // HANDLER
            _handleCollapsed: function () {
                if (this.collapsible && this.superlist && this.superlist.collapsed) { this.collapse(); }
            }
        });
    </script>

</dom-module><dom-module id="mat-sublist" assetpath="../bower_components/mat-list/">

    <style>
        :host {
            display: block;
            overflow: visible;
        }

        :host #matSublistWrapper {
            position: relative;
        }

        :host #matSublistDividerTop,
        :host #matSublistDividerBottom {
            height: 0;
            margin: 0;
        }

        :host #matSublistAdaptee::shadow #xpSublistWrapper #xpCollapseWrapper ::content > mat-item[active] #matItemRipple #matRippleBackground {
            opacity: 0.10;
        }
    </style>

    <template>
        <template is="xp-master-state" id="xpMasterState" slaves="{{sublists}}" slave-tag="mat-sublist"></template>
        <template is="xp-slave-state" master="{{list}}" master-tag="mat-list"></template>
        <template is="xp-slave-state" master="{{superlist}}" master-tag="mat-sublist"></template>
        <div id="matSublistWrapper">
            <mat-divider id="matSublistDividerTop"></mat-divider>
            <template is="dom-if" if="[[_hasCollapser(collapsible, label)]]" restamp=""><mat-item id="matSublistCollapser" active="{{collapsed}}" label="[[label]]" primary-icon="[[icon]]" primary-icon-src="[[iconSrc]]" secondary-icon="[[_computeArrowIcon(collapsed)]]" secondary-no-tap="" toggleable=""></mat-item></template>
            <template is="dom-if" if="[[_hasHeader(collapsible, label)]]" restamp=""><mat-subheader id="matSublistHeader" inset="[[inset]]" label="[[label]]"></mat-subheader></template>
            <template is="dom-if" if="[[_hasIcon(icon, iconSrc, label)]]" restamp=""><mat-icon id="matSublistIcon" name="[[icon]]" src="[[iconSrc]]"></mat-icon></template>
            <xp-sublist id="matSublistAdaptee" animatable="{{animatable}}" backward="" collapsed="{{collapsed}}" collapsible="[[collapsible]]" easing="cubic-bezier(0.55, 0, 0.01, 1)"><content id="content"></content></xp-sublist>
            <mat-divider id="matSublistDividerBottom"></mat-divider>
        </div>
    </template>

    <script>
        Polymer({

            // ELEMENT
            is: 'mat-sublist',

            /*********************************************************************/

            /**
             * Collapses the sublist.
             *
             * @method collapse
             * @returns {Element}
             */
            collapse: function () {
                var self = this;
                self.$.matSublistAdaptee.collapse();
                return self;
            },

            /**
             * Expands the sublist.
             *
             * @method expand
             * @returns {Element}
             */
            expand: function () {
                var self = this;
                self.$.matSublistAdaptee.expand();
                return self;
            },

            /**
             * Toggles the collapsed state.
             *
             * @method toggle
             * @returns {Element}
             */
            toggle: function () {
                var self = this;
                self.$.matSublistAdaptee.toggle();
                return self;
            },

            /*********************************************************************/

            /**
             * Refreshes the element.
             *
             * @method _refresh
             * @returns {Element}
             * @private
             */
            _refresh: function () {

                // Vars
                var self = this;

                // Checking
                if (!self.isAttached || !self.list) { return self; }

                // Collapsing
                if (!self.collapsed && self.collapsible && !self.list.autoCollapseDisabled) { XP.invoke(XP.findSiblingElements(self, 'mat-sublist'), 'collapse'); }

                return self;
            },

            /*********************************************************************/

            // COMPUTED
            computed: {
                'emptyLabel': '!label',
                'inset': '!!icon || !!iconSrc'
            },

            // OBSERVERS
            observers: [
                '_refresh(collapsed, collapsible, list)'
            ],

            // PROPERTIES
            properties: {

                /**
                 * If set to true, the animation can be executed.
                 *
                 * @attribute animatable
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                animatable: {
                    notify: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the sublist is collapsed.
                 *
                 * @attribute collapsed
                 * @type boolean
                 * @default false
                 * @notifies
                 */
                collapsed: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the sublist is collapsible.
                 *
                 * @attribute collapsible
                 * @type string
                 * @default false
                 * @notifies
                 */
                collapsible: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * If set to true, the label is hidden.
                 *
                 * @attribute empty-label
                 * @type boolean
                 * @notifies
                 * @readonly
                 */
                emptyLabel: {
                    computed: '_computeEmptyLabel(label)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The sublist's icon.
                 *
                 * @attribute icon
                 * @type string
                 */
                icon: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The sublist's icon's src.
                 *
                 * @attribute icon-src
                 * @type string
                 */
                iconSrc: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * If set to true, the element is indented.
                 *
                 * @attribute inset
                 * @type boolean
                 * @default false
                 * @notifies
                 * @readonly
                 */
                inset: {
                    computed: '_computeInset(icon, iconSrc)',
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean
                },

                /**
                 * The sublist's label.
                 *
                 * @attribute label
                 * @type string
                 */
                label: {
                    reflectToAttribute: true,
                    type: String,
                    value: null
                },

                /**
                 * The master list.
                 *
                 * @attribute list
                 * @type Element
                 * @notifies
                 * @readonly
                 */
                list: {
                    notify: true,
                    value: null
                },

                /**
                 * The slave sublists.
                 *
                 * @attribute sublists
                 * @type Array
                 * @notifies
                 * @readonly
                 */
                sublists: {
                    notify: true,
                    type: Array
                },

                /**
                 * The master sublist.
                 *
                 * @attribute superlist
                 * @type Element
                 * @notifies
                 * @readonly
                 */
                superlist: {
                    notify: true,
                    value: null
                }
            },

            /*********************************************************************/

            // COMPUTER
            _computeArrowIcon: function (collapsed) {
                return collapsed ? 'navigation:expand-more' : 'navigation:expand-less';
            },

            // COMPUTER
            _computeEmptyLabel: function (label) {
                return !label;
            },

            // COMPUTER
            _computeInset: function (icon, iconSrc) {
                return !!icon || !!iconSrc;
            },

            // COMPUTER
            _hasCollapser: function (collapsible, label) {
                return collapsible && !!label;
            },

            // COMPUTER
            _hasHeader: function (collapsible, label) {
                return !collapsible && !!label;
            },

            // COMPUTER
            _hasIcon: function (icon, iconSrc, label) {
                return (!!icon || !!iconSrc) && !label;
            }
        });
    </script>

</dom-module><dom-module id="neon-animated-pages" assetpath="../bower_components/neon-animation/">

  <style>

    :host {
      display: block;
      position: relative;
    }

    :host > ::content > * {
      @apply(--layout-fit);
      height: 100%;
    }

    :host > ::content > :not(.iron-selected):not(.neon-animating) {
      display: none !important;
    }

    :host > ::content > .neon-animating {
      pointer-events: none;
    }

  </style>

  <template>
    <content id="content"></content>
  </template>

</dom-module>

<script>
(function() {

  Polymer({

    is: 'neon-animated-pages',

    behaviors: [
      Polymer.IronResizableBehavior,
      Polymer.IronSelectableBehavior,
      Polymer.NeonAnimationRunnerBehavior
    ],

    properties: {

      activateEvent: {
        type: String,
        value: ''
      },

      // if true, the initial page selection will also be animated according to its animation config.
      animateInitialSelection: {
        type: Boolean,
        value: false
      }

    },

    observers: [
      '_selectedChanged(selected)'
    ],

    listeners: {
      'neon-animation-finish': '_onNeonAnimationFinish'
    },

    _selectedChanged: function(selected) {

      var selectedPage = this.selectedItem;
      var oldPage = this._prevSelected || false;
      this._prevSelected = selectedPage;

      // on initial load and if animateInitialSelection is negated, simply display selectedPage.
      if (!oldPage && !this.animateInitialSelection) {
        this._completeSelectedChanged();
        return;
      }

      // insert safari fix.
      this.animationConfig = [{
        name: 'opaque-animation',
        node: selectedPage
      }];

      // configure selectedPage animations.
      if (this.entryAnimation) {
        this.animationConfig.push({
          name: this.entryAnimation,
          node: selectedPage
        });
      } else {
        if (selectedPage.getAnimationConfig) {
          this.animationConfig.push({
            animatable: selectedPage,
            type: 'entry'
          });
        }
      }

      // configure oldPage animations iff exists.
      if (oldPage) {

        // cancel the currently running animation if one is ongoing.
        if (oldPage.classList.contains('neon-animating')) {
          this._squelchNextFinishEvent = true;
          this.cancelAnimation();
          this._completeSelectedChanged();
        }

        // configure the animation.
        if (this.exitAnimation) {
          this.animationConfig.push({
            name: this.exitAnimation,
            node: oldPage
          });
        } else {
          if (oldPage.getAnimationConfig) {
            this.animationConfig.push({
              animatable: oldPage,
              type: 'exit'
            });
          }
        }

        // display the oldPage during the transition.
        oldPage.classList.add('neon-animating');
      }

      // display the selectedPage during the transition.
      selectedPage.classList.add('neon-animating');

      // actually run the animations.
      if (this.animationConfig.length > 1) {

        // on first load, ensure we run animations only after element is attached.
        if (!this.isAttached) {
          this.async(function () {
            this.playAnimation(null, {
              fromPage: null,
              toPage: selectedPage
            });
          });

        } else {
          this.playAnimation(null, {
            fromPage: oldPage,
            toPage: selectedPage
          });
        }

      } else {
        this._completeSelectedChanged(oldPage, selectedPage);
      }
    },

    _completeSelectedChanged: function(oldPage, selectedPage) {
      if (selectedPage) {
        selectedPage.classList.remove('neon-animating');
      }
      if (oldPage) {
        oldPage.classList.remove('neon-animating');
      }
      if (!selectedPage || !oldPage) {
        var nodes = Polymer.dom(this.$.content).getDistributedNodes();
        for (var node, index = 0; node = nodes[index]; index++) {
          node.classList && node.classList.remove('neon-animating');
        }
      }
      this.async(this.notifyResize);
    },

    _onNeonAnimationFinish: function(event) {
      if (this._squelchNextFinishEvent) {
        this._squelchNextFinishEvent = false;
        return;
      }
      this._completeSelectedChanged(event.detail.fromPage, event.detail.toPage);
    }

  })

})();
</script>
<dom-module id="neon-animatable" assetpath="../bower_components/neon-animation/">

  <style>

    :host {
      display: block;
    }

  </style>

  <template>
    <content></content>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'neon-animatable',

    behaviors: [
      Polymer.NeonAnimatableBehavior
    ]

  });

</script>
<dom-module id="ripple-wrapper" assetpath="ripple-wrapper/">
    <style is="custom-style">
        :host {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
    </style>
    <template>
        <paper-ripple></paper-ripple>
    </template>
</dom-module>
<script>
    Polymer({is: 'ripple-wrapper'});
</script><dom-module id="everhome-news" assetpath="everhome-news/">
    <style>

    /* Application theme */
  :root {
    --dark-primary-color: #303F9F;
    --default-primary-color: #3F51B5;
    --light-primary-color: #C5CAE9;
    --text-primary-color: #ffffff; /*text/icons*/
    --accent-color: #FF4081;
    --primary-background-color: #c5cae9;
    --primary-text-color: #212121;
    --secondary-text-color: #727272;
    --disabled-text-color: #bdbdbd;
    --divider-color: #B6B6B6;
    --paper-tabs-selection-bar-color:#FFFFFF;

    /* Components */

    /* paper-drawer-panel */
    --drawer-menu-color: #ffffff;
    --drawer-border-color: 1px solid #ccc;
    --drawer-toolbar-border-color: 1px solid rgba(0, 0, 0, 0.22);

    /* paper-menu */
    --paper-menu-background-color: #fff;
    --menu-link-color: #111111;
  }

  /* General styles */
  
  .paper-tab-0 #ink.paper-tab {
  color: #303F9F;
  }
  #drawerToolbar {
    color: var(--secondary-text-color);
    background-color: var(--drawer-menu-color);
    border-bottom: var(--drawer-toolbar-border-color);
    height: 64px;
  }

  paper-item{
    position: relative;
    height: 48px;
    line-height: 48px;
    /*color: #646464;*/
    font-size: 0.9em;
  }

  paper-item.paper-item-0{
    font-family: "Roboto Mono", Roboto, sans-serif;
    letter-spacing: 0.25px;
  }

  paper-material {
    border-radius: 2px;
    padding: 16px 0 16px 0;
    width: calc(98.66% - 16px);
    margin: 16px auto;
    background: white;
  }

  paper-menu iron-icon {
    margin-right: 33px;
    opacity: 0.54;
  }

  .paper-menu > .iron-selected {
    color: var(--default-primary-color);
  }

  paper-menu a {
    text-decoration: none;
    color: var(--menu-link-color);
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
    font-family: 'Roboto', 'Noto', sans-serif;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    font-size: 14px;
    font-weight: 400;
    line-height: 24px;
    min-height: 48px;
    padding: 0 16px;
  }

  #mainToolbar .middle {
    margin-left: 48px;
  }

  /* -webkit-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    -moz-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    -blink-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);*/

  #mainToolbar.has-shadow .middle {
    /*font-size: 20px;*/
    padding-bottom: 0;
    margin-left: 48px;
  }

  /* Height of the scroll area */
  /*.content {
    height: 900px;
  }*/

  /* Breakpoints */

  /* Small */
  @media (max-width: 600px) {

    paper-material {
      --menu-container-display: none;
      width: calc(97.33% - 32px);
      padding-left: 16px;
      padding-right: 16px;
    }

    .paper-font-display1 {
      font-size: 12px;
    }

    .app-name {
      font-size: 26px;
    }

    #drawer .paper-toolbar {
      margin-left: 16px;
    }

    #overlay {
      min-width: 360px;
    }

    .bg {
      background: white;
    }

    img{
      width: calc(98.66% - 16px);
    }

  }

  /* Tablet+ */
  @media (min-width: 601px) {

    paper-material {
      width: calc(98% - 46px);
      margin-bottom: 32px;
      padding-left: 30px;
      padding-right: 30px;
    }

    #drawer.paper-drawer-panel > [drawer] {
      border-right: 1px solid rgba(0, 0, 0, 0.14);
    }

    iron-pages {
      padding: 48px 62px;
    }

  }

  /* Material Design Adaptive Breakpoints */
  /*
    Below you'll find CSS media queries based on the breakpoint guidance
    published by the Material Design team. You can choose to use, customise
    or remove these breakpoints based on your needs.

    http://www.google.com/design/spec/layout/adaptive-ui.html#adaptive-ui-breakpoints
   */

  /* mobile-small */
  @media all and (min-width: 0) and (max-width: 360px) and (orientation: portrait) {
   }
  /* mobile-large */
  @media all and (min-width: 361px) and (orientation: portrait) {
   }
  /* mobile-small-landscape */
  @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) { }
  /* mobile-large-landscape */
  @media all and (min-width: 481px) and (orientation: landscape) { }
  /* tablet-small-landscape */
  @media all and (min-width: 600px) and (max-width: 960px) and (orientation: landscape) { }
  /* tablet-large-landscape */
  @media all and (min-width: 961px) and (orientation: landscape) { }
  /* tablet-small */
  @media all and (min-width: 600px) and (orientation: portrait) { }
  /* tablet-large */
  @media all and (min-width: 601px) and (max-width: 840px) and (orientation : portrait) { }
  /* desktop-x-small-landscape */
  @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) { }
  /* desktop-x-small */
  @media all and (min-width: 0) and (max-width: 480px) and (max-aspect-ratio: 4/3) { }
  /* desktop-small-landscape */
  @media all and (min-width: 481px) and (max-width: 840px) and (orientation: landscape) { }
  /* desktop-small */
  @media all and (min-width: 481px) and (max-width: 840px) and (max-aspect-ratio: 4/3) { }
  /* desktop-medium-landscape */
  @media all and (min-width: 841px) and (max-width: 1280px) and (orientation: landscape) { }
  /* desktop-medium */
  @media all and (min-width: 841px) and (max-width: 1280px) and (max-aspect-ratio: 4/3) { }
  /* desktop-large */
  @media all and (min-width: 1281px) and (max-width: 1600px) { }
  /* desktop-xlarge */
  @media all and (min-width: 1601px) and (max-width: 1920px) { }

</style>
    <style>
        .news-card {
            width: 400px;
            margin-right: 15px;
            z-index: 0;
        }

        h2 {
            margin-top: 20px;
            margin-bottom: 10px;
        }

        h3 {
            font-family: "Lato", Georgia;
            font-weight: bold;
            font-size: 24px;
        }

        p {
            font-family: "Lato", Georgia;
        }

        #newsLayout {
            transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -moz-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -webkit-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
        }

        #fab-container {
            margin-top: 10px;
        }
    </style>
    <template>
        <div class="layout vertical flex-none">
            <div class="layout horizontal center-justified">
                <h2 class="self-start flex light">News</h2>

                <div id="fab-container" class="flex self-center">
                    <everhome-arrow-fab id="scrollLeftButton" on-click="scrollLeft" icon="chevron-left" disabled="true"></everhome-arrow-fab>
                    <everhome-arrow-fab id="scrollRightButton" on-click="scrollRight" icon="chevron-right"></everhome-arrow-fab>
                </div>
                
            </div>
            <div id="newsLayout" class="layout horizontal">
                <template is="dom-repeat" items="{{items}}">
                    <paper-material class="news-card flex-none" elevation="1">
                        <h3>{{item.title}}</h3>

                        <p>{{item.content}}</p>
                    </paper-material>
                </template>
            </div>
        </div>
    </template>
    <script>
        var marginLeft = 0;
        var click = 0;
        Polymer({
            is: "everhome-news",
            scrollRight: function () {
                if (click < 3) {
                    var newsLayout = document.querySelector('#newsLayout');
                    var card = document.querySelectorAll('.news-card');
                    marginLeft += -card[click].offsetWidth;
                    if(marginLeft < -1300){
                      marginLeft = -1300;
                    }
                    newsLayout.style.marginLeft = marginLeft + "px";
                    click++;
                    checkScroll();
                }
            },
            scrollLeft: function () {
                var newsLayout = document.querySelector('#newsLayout');
                if (click > 0) {
                    var card = document.querySelectorAll('.news-card');
                    marginLeft += card[click].offsetWidth;
                    if(marginLeft > 0){
                        marginLeft = 0;
                    }
                    newsLayout.style.marginLeft = marginLeft + "px";
                    click--;
                    checkScroll();
                }
            },
            properties: {
                items: {
                    type: Array,
                    notify: true
                }
            }
        });


        function checkScroll() {
            console.log(click);
            var scrollLeftButton = document.querySelector('#scrollLeftButton');
            var scrollRightButton = document.querySelector('#scrollRightButton');
            if (click == 0) {
                scrollLeftButton.setAttribute("disabled", "true");
            } else {
                scrollLeftButton.removeAttribute("disabled");
            }
            if (click == 3) {
                scrollRightButton.setAttribute("disabled", "true")
            } else {
                scrollRightButton.removeAttribute("disabled");
            }
        }

    </script>

</dom-module><dom-module id="everhome-test" assetpath="everhome-test/">
    
    <style>
        :host {
            font-family: "Lato", Georgia;
            font-weight: 300;
           /* z-index: 1;*/
        }

        paper-button {
            font-weight: normal;
        }

        #title,#everhometitle{
            margin-left: 15px;
        }

        .main-card:not(.nowidth) {
            background-color: var(--default-primary-color);
            width: 500px;
            /*z-index: 1;*/
            margin-right: 15px;
            padding: 0;
        }

        .main-card {
            background-color: var(--default-primary-color);
           /* z-index: 1;*/
            margin-right: 15px;
            margin-left: 15px;
            padding: 0;
        }

        .main-card > h3, p {
            padding-left: 30px;
            padding-right: 30px;
            padding-top: 16px;
            padding-bottom: 16px;
        }

        .main-card-click {
            background-color: #FFFFFF;
        }

        .main-card-click > iron-icon {
            padding: 8px;
        }

        .main-card-click > paper-button {
            margin: 0;
        }

        .main-card-arrow {
            float: right;
            margin-bottom: 10px;
        }

        div > paper-button {
            border-top-width: 1px;
            border-top-color: #333;
            border-top-style: solid;
            border-radius: 0px;
        }

        div > paper-button:first-child {
            border-top-width: 0px;
            border-top-style: inherit;
        }

        h3 {
            font-style: italic;
            font-size: 25px;
        }

        p {
            font-size: 20px;
        }

        .main-card-button-text {
            float: left;
            padding-top: 3px;
        }

        .light {
            font-weight: 300;
            font-size: 48px;
            color: #FFFFFF;
            font-style: inherit;
        }

        .light.small {
            font-weight: 300;
            font-size: 30px;
            color: #FFFFFF;
            font-style: inherit;
            margin-left: 15px;
        }

        /*@media (max-width: 600px) {
         .main-card{
           width: calc(98.66% - 16px);
         }

       }*/

    </style>
    <template>
        <h3 id="title" class$="{{classTitle(smalltoptitle)}}">{{toptitle}}</h3>

        <h3 id="everhometitle" class$="{{classTitle(smalltoptitle)}}">
            <everhome-title small=""></everhome-title>
            <span>{{toptitle}}</span></h3>
        <paper-material class$="{{classCard(nowidth)}}" elevation="1">
            <h3 id="cardtitle" class="color white">{{title}}</h3>

            <h3 id="cardeverhometitle" class="color white">
                <everhome-title small=""></everhome-title>
                - Smart Home in der Cloud
            </h3>
            <p class="color white">{{content}}</p>

            <div class="main-card-click layout vertical">
                <template is="dom-repeat" items="{{buttons}}">
                    <paper-button class="flex" href="{{item.link}}"><span class="main-card-button-text">{{item.title}}</span>
                        <iron-icon class="main-card-arrow" icon="{{item.icon}}"></iron-icon>
                    </paper-button>
                </template>
            </div>
        </paper-material>
    </template>
    <script>
        Polymer({
            is: "everhome-test",
            properties: {
                buttons: {
                    type: Array,
                    notify: true
                },
                content: {
                    type: String
                },
                toptitle: {
                    type: String
                },
                title: {
                    type: String
                },
                smalltoptitle: {
                    type: String
                },
                everhomestart: {
                    type: String
                },
                notitle: Boolean,
                nowidth: String
            },
            ready: function () {
                if (typeof this.toptitle === "undefined") {
                    this.$.title.style.display = "none";
                } else {
                    this.$.cardtitle.style.display = "none";
                    this.$.cardeverhometitle.style.display = "none";
                }
                if (typeof this.buttons === "undefined") {
                    var button = {title: "everHome testen", icon: "arrow-forward"};
                    this.buttons = new Array(button);
                }
                if (typeof this.title === "undefined") {
                    this.$.cardtitle.style.display = "none";
                } else {
                    this.$.cardeverhometitle.style.display = "none";
                }
                if (typeof this.smalltoptitle === "undefined") {
                    this.smalltoptitle = "false";
                }
                if (typeof this.everhomestart === "undefined") {
                    this.$.everhometitle.style.display = "none";
                } else {
                    this.$.title.style.display = "none";
                }
                if (typeof this.notitle === "undefined") {

                } else {
                    this.$.cardeverhometitle.style.display = "none";
                }
                if (typeof this.nowidth === "undefined") {
                    this.nowidth = "false";
                }
            },
            classTitle: function (small) {
                if (small == "true") {
                    return 'light small';
                } else {
                    return 'light';
                }
            },
            classCard: function (nowidth) {
                if (nowidth == "true") {
                    return 'main-card nowidth';
                } else {
                    return 'main-card';
                }
            },
            titleHtml: function (title) {
                if (this.everhomestart == "true") {
                    return '<everhome-title small></everhome-title>' + title;
                } else {
                    return title;
                }
            }
        });
    </script>

</dom-module><dom-module id="everhome-app" assetpath="everhome-app/">
    
    <style>
        :host {
            font-family: "Lato", Georgia;
            font-weight: 300;
        }

        paper-button {
            font-weight: normal;
        }

        h3 {
            font-style: italic;
            font-size: 25px;
        }

        p {
            font-size: 20px;
        }

        .main-card {
            background-color: var(--default-primary-color);
            /*width: 500px;*/
            /*z-index: 1;*/
            margin-right: 15px;
            margin-left: 15px;
            padding: 0;
        }

        .main-card > h3, p {
            padding-left: 30px;
            padding-right: 30px;
            padding-top: 16px;
            padding-bottom: 16px;
        }

        .main-card-click {
            background-color: #FFFFFF;
        }

        .main-card-click > iron-icon {
            padding: 8px;
        }

        .main-card-click > paper-button {
            margin: 0;
        }

        .main-card-arrow {
            float: right;
            margin-bottom: 10px;
        }

        .main-card-button-text {
            float: left;
            padding-top: 3px;
        }

        div > paper-button:nth-child(1) {
            border-right-width: 2px;
            border-right-color: #333;
            border-right-style: solid;
            border-radius: 0;
        }

        @media (max-width: 600px) {
            .main-card {
                width: calc(98.66% - 16px);
            }
        }

    </style>
    <template>
        <paper-material class="main-card" elevation="1">
            <h3 class="color white">everHome - Smart Home in der Cloud</h3>

            <p class="color white">{{content}}</p>

            <div class="main-card-click layout horizontal">
                <paper-button class="flex" on-click="goLink" link="https://itunes.apple.com/de/app/id934744174"><span class="main-card-button-text">Play Store</span>
                    <iron-icon class="main-card-arrow" icon="eh:google-play"></iron-icon>
                </paper-button>
                <paper-button class="flex" on-click="goLink" link="play.google.com/store/apps/details?id=de.everhome.cloudboxprod"><span class="main-card-button-text">App Store</span>
                    <iron-icon class="main-card-arrow" icon="eh:apple"></iron-icon>
                </paper-button>
            </div>
        </paper-material>
    </template>
    <script>
        Polymer({
            is: "everhome-app",
            properties: {
                content: {
                    type: String,
                }
            },
            goLink: function (event) {
                event = event || window.event;
                var link = (event.target || event.srcElement).getAttribute('link');
                console.log(link);
                //window.location.href = e.target.getAttribute('link');
            }
        });
    </script>

</dom-module><dom-module id="everhome-manufacturer" assetpath="everhome-manufacturer/">
    <style>
        div {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 0;
        }

        img {
            width: 128px;
            height: 128px;
            margin-right: 15px;
            margin-top: 20px;
        }
    </style>
    <template>
        <div class="layout horizontal wrap">
            <template is="dom-repeat" items="{{items}}">
                <img src="{{item}}">
            </template>
        </div>
    </template>
    <script>
        Polymer({
            is: "everhome-manufacturer",
            properties: {
                items: {
                    type: Array,
                    notify: true,
                }
            }
        });
    </script>
</dom-module><dom-module id="everhome-fab" assetpath="everhome-fab/">
    <style>

    /* Application theme */
  :root {
    --dark-primary-color: #303F9F;
    --default-primary-color: #3F51B5;
    --light-primary-color: #C5CAE9;
    --text-primary-color: #ffffff; /*text/icons*/
    --accent-color: #FF4081;
    --primary-background-color: #c5cae9;
    --primary-text-color: #212121;
    --secondary-text-color: #727272;
    --disabled-text-color: #bdbdbd;
    --divider-color: #B6B6B6;
    --paper-tabs-selection-bar-color:#FFFFFF;

    /* Components */

    /* paper-drawer-panel */
    --drawer-menu-color: #ffffff;
    --drawer-border-color: 1px solid #ccc;
    --drawer-toolbar-border-color: 1px solid rgba(0, 0, 0, 0.22);

    /* paper-menu */
    --paper-menu-background-color: #fff;
    --menu-link-color: #111111;
  }

  /* General styles */
  
  .paper-tab-0 #ink.paper-tab {
  color: #303F9F;
  }
  #drawerToolbar {
    color: var(--secondary-text-color);
    background-color: var(--drawer-menu-color);
    border-bottom: var(--drawer-toolbar-border-color);
    height: 64px;
  }

  paper-item{
    position: relative;
    height: 48px;
    line-height: 48px;
    /*color: #646464;*/
    font-size: 0.9em;
  }

  paper-item.paper-item-0{
    font-family: "Roboto Mono", Roboto, sans-serif;
    letter-spacing: 0.25px;
  }

  paper-material {
    border-radius: 2px;
    padding: 16px 0 16px 0;
    width: calc(98.66% - 16px);
    margin: 16px auto;
    background: white;
  }

  paper-menu iron-icon {
    margin-right: 33px;
    opacity: 0.54;
  }

  .paper-menu > .iron-selected {
    color: var(--default-primary-color);
  }

  paper-menu a {
    text-decoration: none;
    color: var(--menu-link-color);
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
    font-family: 'Roboto', 'Noto', sans-serif;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    font-size: 14px;
    font-weight: 400;
    line-height: 24px;
    min-height: 48px;
    padding: 0 16px;
  }

  #mainToolbar .middle {
    margin-left: 48px;
  }

  /* -webkit-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    -moz-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    -blink-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);*/

  #mainToolbar.has-shadow .middle {
    /*font-size: 20px;*/
    padding-bottom: 0;
    margin-left: 48px;
  }

  /* Height of the scroll area */
  /*.content {
    height: 900px;
  }*/

  /* Breakpoints */

  /* Small */
  @media (max-width: 600px) {

    paper-material {
      --menu-container-display: none;
      width: calc(97.33% - 32px);
      padding-left: 16px;
      padding-right: 16px;
    }

    .paper-font-display1 {
      font-size: 12px;
    }

    .app-name {
      font-size: 26px;
    }

    #drawer .paper-toolbar {
      margin-left: 16px;
    }

    #overlay {
      min-width: 360px;
    }

    .bg {
      background: white;
    }

    img{
      width: calc(98.66% - 16px);
    }

  }

  /* Tablet+ */
  @media (min-width: 601px) {

    paper-material {
      width: calc(98% - 46px);
      margin-bottom: 32px;
      padding-left: 30px;
      padding-right: 30px;
    }

    #drawer.paper-drawer-panel > [drawer] {
      border-right: 1px solid rgba(0, 0, 0, 0.14);
    }

    iron-pages {
      padding: 48px 62px;
    }

  }

  /* Material Design Adaptive Breakpoints */
  /*
    Below you'll find CSS media queries based on the breakpoint guidance
    published by the Material Design team. You can choose to use, customise
    or remove these breakpoints based on your needs.

    http://www.google.com/design/spec/layout/adaptive-ui.html#adaptive-ui-breakpoints
   */

  /* mobile-small */
  @media all and (min-width: 0) and (max-width: 360px) and (orientation: portrait) {
   }
  /* mobile-large */
  @media all and (min-width: 361px) and (orientation: portrait) {
   }
  /* mobile-small-landscape */
  @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) { }
  /* mobile-large-landscape */
  @media all and (min-width: 481px) and (orientation: landscape) { }
  /* tablet-small-landscape */
  @media all and (min-width: 600px) and (max-width: 960px) and (orientation: landscape) { }
  /* tablet-large-landscape */
  @media all and (min-width: 961px) and (orientation: landscape) { }
  /* tablet-small */
  @media all and (min-width: 600px) and (orientation: portrait) { }
  /* tablet-large */
  @media all and (min-width: 601px) and (max-width: 840px) and (orientation : portrait) { }
  /* desktop-x-small-landscape */
  @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) { }
  /* desktop-x-small */
  @media all and (min-width: 0) and (max-width: 480px) and (max-aspect-ratio: 4/3) { }
  /* desktop-small-landscape */
  @media all and (min-width: 481px) and (max-width: 840px) and (orientation: landscape) { }
  /* desktop-small */
  @media all and (min-width: 481px) and (max-width: 840px) and (max-aspect-ratio: 4/3) { }
  /* desktop-medium-landscape */
  @media all and (min-width: 841px) and (max-width: 1280px) and (orientation: landscape) { }
  /* desktop-medium */
  @media all and (min-width: 841px) and (max-width: 1280px) and (max-aspect-ratio: 4/3) { }
  /* desktop-large */
  @media all and (min-width: 1281px) and (max-width: 1600px) { }
  /* desktop-xlarge */
  @media all and (min-width: 1601px) and (max-width: 1920px) { }

</style>
    <style>
        paper-material {
            -webkit-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
            transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -moz-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -blink-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
        }

        paper-material {
            background-color: #4e4e4e;
            color: #FFFFFF;
            width: 60px;
            padding-left: 50px;
            height: 18px;
            margin-top: 10px;
            margin-left: -16px;
            padding-right: 20px;
            padding-top: 10px;
            padding-bottom: 10px;
            z-index: 0;
        }

        /*border-radius: 12px;*/
        paper-fab {
            z-index: 1;
            background-color: var(--default-primary-color);
        }

        span {
            color: #FFFFFF;
            float: right;
        }

        paper-material.active {
            padding-left: 70px;
            background-color: #FFFFFF;
            padding-right: 10px;
            color: #4e4e4e;
        }

        paper-material.active > span {
            color: #4e4e4e;
        }
    </style>
    <template>
        <div class="layout horizontal">
            <paper-fab icon="{{icon}}"></paper-fab>
            <paper-material class$="{{state}}">
                <ripple-wrapper></ripple-wrapper>
                <span>{{title}}</span>
            </paper-material>
        </div>
    </template>
    <script>
        Polymer({
            is: "everhome-fab",
            properties: {
                title: String,
                icon: String,
                state: String
            }
        });
    </script>

</dom-module><dom-module id="everhome-title" assetpath="everhome-title/">
    
    <style>
        span.light {
            font-weight: 300;
            font-family: "Lato", Georgia;
        }

        span {
            font-style: normal;
        }

        span.bold {
            font-family: "Lato", Georgia;
            font-weight: bold;
        }

        span.true {
            font-size: 25px;
        }

        @media (max-width: 470px) {
            span.toolbar {
                font-size: 25px;
            }
        }
    </style>
    <template>
        <span class$="{{classSpan(small,toolbar)}}"><span class="color white bold">ever</span>Home</span>
    </template>
    <script>
        Polymer({
            is: "everhome-title",
            properties: {
                small: Boolean,
                toolbar: Boolean,
            },
            classSpan: function (size, toolbar) {
                if (toolbar == false) {
                    return 'color white light ' + size;
                } else {
                    return 'color white light toolbar ' + size;
                }
            },
            ready: function () {
                if (typeof this.small === "undefined") {
                    this.small = false;
                }
                if (typeof this.toolbar === "undefined") {
                    this.toolbar = false;
                }
            }
        });

    </script>

</dom-module><dom-module id="everhome-arrow-fab" assetpath="everhome-arrow-fab/">
    <style>
        :root {
            --paper-fab-background: white;
        }

        paper-fab {
            margin-right: 15px;
            color: #333;
            height: 52px;
            width: 52px;
        }

        paper-fab[news="true"] {
            margin-top: 10px;
        }
    </style>
    <template>
        <paper-fab mini="" icon="{{icon}}" disabled="{{disabled}}"></paper-fab>
    </template>
    <script>
        Polymer({
            is: "everhome-arrow-fab",
            properties: {
                icon: String,
                disabled: Boolean
            }
        });
    </script>
</dom-module><dom-module id="everhome-presentation-screen" assetpath="everhome-presentation-screen/">
    <style>
        h1 {
            margin-bottom: 300px;
            text-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);
            line-height: 1;
        }

        p {
            margin-bottom: 0;
            text-shadow: 0 1px 15px rgb(0, 0, 0);
        }

        .content {
            /*padding-left: 130px;
            padding-right: 130px;*/
            padding-bottom: 65px;
            background-size: cover;
            background-position: center;
        }

        .log.content > div > h1 {
            margin-bottom: 200px;
        }

        @media all and (min-width: 361px) and (orientation: portrait) {
            .content {
                /*padding-left: 20px;
                padding-right: 20px;*/
                padding-bottom: 10px;
            }

            h1, .log.content > div > h1 {
                margin-bottom: 0;
            }
        }

        .automation.content {
            background-image: url("../images/automation.jpg");
        }

        .camera.content {
            background-image: url("../images/camera.jpg");
        }

        .home.content {
            background-image: url("../images/home.jpg");
        }

        .log.content {
            background-image: url("../images/log.jpg");
        }
    </style>
    <template>
        <div class$="{{classImage(image)}}" async="">
            <div class="container">
                <h1 align="center" class="light flex self-center" style="">{{title}}</h1>

                <p style="" class="light flex self-center">{{content}}</p>
            </div>
        </div>
    </template>
    <script>
        Polymer({
            is: "everhome-presentation-screen",
            properties: {
                image: String,
                title: {
                    type: String,
                    notify: true
                },
                content: {
                    type: String,
                    notify: true
                }
            },
            classImage: function (image) {
                return 'content ' + image;
            }
        });
    </script>
</dom-module><dom-module id="everhome-img-carousel" assetpath="everhome-img-carousel/">
    <style>

    /* Application theme */
  :root {
    --dark-primary-color: #303F9F;
    --default-primary-color: #3F51B5;
    --light-primary-color: #C5CAE9;
    --text-primary-color: #ffffff; /*text/icons*/
    --accent-color: #FF4081;
    --primary-background-color: #c5cae9;
    --primary-text-color: #212121;
    --secondary-text-color: #727272;
    --disabled-text-color: #bdbdbd;
    --divider-color: #B6B6B6;
    --paper-tabs-selection-bar-color:#FFFFFF;

    /* Components */

    /* paper-drawer-panel */
    --drawer-menu-color: #ffffff;
    --drawer-border-color: 1px solid #ccc;
    --drawer-toolbar-border-color: 1px solid rgba(0, 0, 0, 0.22);

    /* paper-menu */
    --paper-menu-background-color: #fff;
    --menu-link-color: #111111;
  }

  /* General styles */
  
  .paper-tab-0 #ink.paper-tab {
  color: #303F9F;
  }
  #drawerToolbar {
    color: var(--secondary-text-color);
    background-color: var(--drawer-menu-color);
    border-bottom: var(--drawer-toolbar-border-color);
    height: 64px;
  }

  paper-item{
    position: relative;
    height: 48px;
    line-height: 48px;
    /*color: #646464;*/
    font-size: 0.9em;
  }

  paper-item.paper-item-0{
    font-family: "Roboto Mono", Roboto, sans-serif;
    letter-spacing: 0.25px;
  }

  paper-material {
    border-radius: 2px;
    padding: 16px 0 16px 0;
    width: calc(98.66% - 16px);
    margin: 16px auto;
    background: white;
  }

  paper-menu iron-icon {
    margin-right: 33px;
    opacity: 0.54;
  }

  .paper-menu > .iron-selected {
    color: var(--default-primary-color);
  }

  paper-menu a {
    text-decoration: none;
    color: var(--menu-link-color);
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
    font-family: 'Roboto', 'Noto', sans-serif;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    font-size: 14px;
    font-weight: 400;
    line-height: 24px;
    min-height: 48px;
    padding: 0 16px;
  }

  #mainToolbar .middle {
    margin-left: 48px;
  }

  /* -webkit-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    -moz-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);
    -blink-transition: all 700ms cubic-bezier(0.175, 0.885, 0.320, 1);*/

  #mainToolbar.has-shadow .middle {
    /*font-size: 20px;*/
    padding-bottom: 0;
    margin-left: 48px;
  }

  /* Height of the scroll area */
  /*.content {
    height: 900px;
  }*/

  /* Breakpoints */

  /* Small */
  @media (max-width: 600px) {

    paper-material {
      --menu-container-display: none;
      width: calc(97.33% - 32px);
      padding-left: 16px;
      padding-right: 16px;
    }

    .paper-font-display1 {
      font-size: 12px;
    }

    .app-name {
      font-size: 26px;
    }

    #drawer .paper-toolbar {
      margin-left: 16px;
    }

    #overlay {
      min-width: 360px;
    }

    .bg {
      background: white;
    }

    img{
      width: calc(98.66% - 16px);
    }

  }

  /* Tablet+ */
  @media (min-width: 601px) {

    paper-material {
      width: calc(98% - 46px);
      margin-bottom: 32px;
      padding-left: 30px;
      padding-right: 30px;
    }

    #drawer.paper-drawer-panel > [drawer] {
      border-right: 1px solid rgba(0, 0, 0, 0.14);
    }

    iron-pages {
      padding: 48px 62px;
    }

  }

  /* Material Design Adaptive Breakpoints */
  /*
    Below you'll find CSS media queries based on the breakpoint guidance
    published by the Material Design team. You can choose to use, customise
    or remove these breakpoints based on your needs.

    http://www.google.com/design/spec/layout/adaptive-ui.html#adaptive-ui-breakpoints
   */

  /* mobile-small */
  @media all and (min-width: 0) and (max-width: 360px) and (orientation: portrait) {
   }
  /* mobile-large */
  @media all and (min-width: 361px) and (orientation: portrait) {
   }
  /* mobile-small-landscape */
  @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) { }
  /* mobile-large-landscape */
  @media all and (min-width: 481px) and (orientation: landscape) { }
  /* tablet-small-landscape */
  @media all and (min-width: 600px) and (max-width: 960px) and (orientation: landscape) { }
  /* tablet-large-landscape */
  @media all and (min-width: 961px) and (orientation: landscape) { }
  /* tablet-small */
  @media all and (min-width: 600px) and (orientation: portrait) { }
  /* tablet-large */
  @media all and (min-width: 601px) and (max-width: 840px) and (orientation : portrait) { }
  /* desktop-x-small-landscape */
  @media all and (min-width: 0) and (max-width: 480px) and (orientation: landscape) { }
  /* desktop-x-small */
  @media all and (min-width: 0) and (max-width: 480px) and (max-aspect-ratio: 4/3) { }
  /* desktop-small-landscape */
  @media all and (min-width: 481px) and (max-width: 840px) and (orientation: landscape) { }
  /* desktop-small */
  @media all and (min-width: 481px) and (max-width: 840px) and (max-aspect-ratio: 4/3) { }
  /* desktop-medium-landscape */
  @media all and (min-width: 841px) and (max-width: 1280px) and (orientation: landscape) { }
  /* desktop-medium */
  @media all and (min-width: 841px) and (max-width: 1280px) and (max-aspect-ratio: 4/3) { }
  /* desktop-large */
  @media all and (min-width: 1281px) and (max-width: 1600px) { }
  /* desktop-xlarge */
  @media all and (min-width: 1601px) and (max-width: 1920px) { }

</style>
    <style>
        neon-animatable {
            color: white;
        @apply(- -layout-horizontal);
        @apply(- -layout-center-center);
        @apply(- -paper-font-display4);
        }
    </style>
    <template>
        <paper-material class="main-card" elevation="1">
            <button on-click="_onPrevClick">&lt;&lt;</button>
            <button on-click="_onNextClick">&gt;&gt;</button>
            <neon-animated-pages id="pages" class="flex" selected="{{selected}}" entry-animation="slide-from-right-animation" exit-animation="slide-left-animation">
                <neon-animatable><img width="100px" height="100px" src="../images/nexus_6.png"></neon-animatable>
                <neon-animatable><img width="100px" height="100px" src="../images/nexus_6.png"></neon-animatable>
                <neon-animatable><img width="100px" height="100px" src="../images/nexus_6.png"></neon-animatable>
                <neon-animatable><img width="100px" height="100px" src="../images/nexus_6.png"></neon-animatable>
                <neon-animatable><img width="100px" height="100px" src="../images/nexus_6.png"></neon-animatable>
            </neon-animated-pages>
        </paper-material>
    </template>
    <script>
        Polymer({
            is: "everhome-img-carousel",
            _onPrevClick: function () {
                var scope = document.querySelector('#pages');
                scope.selected = 0;
                this.entryAnimation = 'slide-from-left-animation';
                this.exitAnimation = 'slide-right-animation';
                this.selected = this.selected === 0 ? 4 : (this.selected - 1);
            },
            _onNextClick: function () {
                var scope = document.querySelector('#pages');
                scope.selected = 0;
                this.entryAnimation = 'slide-from-right-animation';
                this.exitAnimation = 'slide-left-animation';
                this.selected = this.selected === 4 ? 0 : (this.selected + 1);
            }
        });
    </script>
</dom-module><dom-module id="everhome-device" assetpath="everhome-device/">
    <style>
        paper-material {
            /*width:500px;*/
            /*z-index: 1;*/
            margin-right: 15px;
            padding: 0;
            background-color: white;
        }

        iron-image {
            width: 128px;
            height: 128px;
            margin-top: 10px;
        }

        .round {
            border-radius: 100%;
            border-style: solid;
            border-width: 3px;
            border-color: #333;
            margin-top: 10px;
        }

        p {
            font-family: "Lato", Georgia;
            font-weight: 300;
            margin-top: 5px;
        }

        h2 {
            margin-bottom: 0;
        }

        paper-input {
            margin-left: 16px;
            margin-right: 16px;
        }

        paper-icon-button {
            margin-right: 16px;
            border-radius: 100%;
        }
    </style>
    <template>
        <paper-material id="card" elevation="1" class="layout vertical" on-mouseover="onHovered" on-mouseout="onUnhovered">
            <div class="layout horizontal start-justified">
                <paper-icon-button icon="star" class="start"></paper-icon-button>
                
            </div>
            <div class="round flex self-center">
                <iron-image sizing="contain" class="flex self-center" preload="" fade="" src="../images/licht.png" height="100px"></iron-image>
                
            </div>
            <h2 id="name" class="flex self-center">{{name}}</h2>
                <p id="roomname" class="flex self-center">{{roomname}}</p>

                <div class="layout horizontal">
                    <template is="dom-repeat" items="{{buttons}}">
                        <paper-button on-click="btnClick" class="flex btn-success">
                            <iron-icon icon="{{item.icon}}"></iron-icon>
                        </paper-button>
                    </template>
                    <mat-menu-button id="menuButton" hidden$="{{!menu}}" target$="{{menuClassName(deviceid,groupid,sceneid)}}"></mat-menu-button>
                    
                    <mat-menu id$="{{menuClassName(deviceid,groupid,sceneid)}}">
                        <div class="layout horizontal">
                            <paper-input label="in Sekunden ein"></paper-input>
                            <paper-icon-button class="btn-success flex self-center" icon="ai:on"></paper-icon-button>
                        </div>
                        
                    </mat-menu>
                </div>
        </paper-material>
    </template>
    <script>
        Polymer({
            is: "everhome-device",
            properties: {
                buttons: {
                    type: Array,
                    notify: true,
                },
                menu: Boolean,
                name: String,
                roomname: String,
                deviceid: 0,
                groupid: 0,
                sceneid: 0,
                roomid: 0,
                imagesource: {
                    type: String,
                    notify: true,
                },
            },
            onHovered: function () {
                this.$.card.elevation = 4
            },
            onUnhovered: function () {
                this.$.card.elevation = 1
            },
            btnClick: function () {
                this.imagesource = "test";
            },
            ready: function () {
                if (typeof this.deviceid === "undefined") {
                    this.deviceid = 0;
                }
                if (typeof this.groupid === "undefined") {
                    this.groupid = 0;
                }
                if (typeof this.sceneid === "undefined") {
                    this.sceneid = 0;
                }
                if (typeof this.roomname === "undefined") {
                    this.$.roomname.style.display = "none";
                    this.$.name.style.marginBottom = "16px";
                }
                if (typeof this.menu === "undefined") {
                    this.$.menuButton.style.display = "none";
                }
            },
            menuClassName: function (deviceid, groupid, sceneid) {
                if (deviceid != 0) {
                    return 'deviceMenu' + deviceid;
                } else if (groupid != 0) {
                    return 'groupMenu' + groupid;
                } else if (sceneid != 0) {
                    return 'sceneMenu' + sceneid;
                } else {
                    return "menu";
                }
            },
        });
    </script>
</dom-module><dom-module id="everhome-index-device" assetpath="everhome-index-device/">
    <style>
        paper-material {
            /*width:500px;*/
            /*z-index: 1;*/
            margin-right: 15px;
            padding: 0;
        }

        iron-image {
            width: 128px;
            height: 128px;
            margin-top: 10px;
            /*background-color: lightgray;*/
        }

        .round {
            border-radius: 100%;
            border-style: solid;
            border-width: 3px;
            border-color: #333;
            margin-top: 10px;
        }

        p {
            font-family: "Lato", Georgia;
            font-weight: 300;
            margin-top: 5px;
        }

        h2 {
            margin-bottom: 0;
        }

        paper-input {
            margin-left: 16px;
            margin-right: 16px;
        }

        paper-button {
            -webkit-transition: all 500ms cubic-bezier(0.4, 0, 1, 1);
            transition: all 500ms cubic-bezier(0.4, 0, 1, 1);
            -moz-transition: all 500ms cubic-bezier(0.4, 0, 1, 1);
        }

        paper-icon-button {
            margin-right: 16px;
            border-radius: 100%;
        }
    </style>
    <template>
        <paper-material id="card" elevation="1" class="layout vertical" on-mouseover="onHovered" on-mouseout="onUnhovered">
            <div class="layout horizontal start-justified">
                <paper-icon-button icon="star" class="start"></paper-icon-button>
                
            </div>
            <div class="round flex self-center">
                <iron-image id="deviceImage" sizing="contain" class="flex self-center" preload="" fade="" src="{{deviceimage}}" height="100px"></iron-image>
                
            </div>
            <h2 id="name" class="flex self-center">{{name}}</h2>
                <p id="roomname" class="flex self-center">{{roomname}}</p>

                <div class="layout horizontal">
                    <template is="dom-repeat" items="{{buttons}}">
                        <paper-button id="{{item.actionid}}" on-click="btnClick" class="off flex btn-success">
                            <iron-icon icon="{{item.icon}}"></iron-icon>
                        </paper-button>
                    </template>
                    <mat-menu-button id="menuButton" hidden$="{{!menu}}" target$="{{menuClassName(deviceid,groupid,sceneid)}}"></mat-menu-button>
                    
                    <mat-menu id$="{{menuClassName(deviceid,groupid,sceneid)}}">
                        <div class="layout horizontal">
                            <paper-input label="in Sekunden ein"></paper-input>
                            <paper-icon-button class="btn-success flex self-center" icon="ai:on"></paper-icon-button>
                        </div>
                        
                    </mat-menu>
                </div>
        </paper-material>
    </template>
    <script>
        Polymer({
            is: "everhome-index-device",
            properties: {
                buttons: {
                    type: Array,
                    notify: true,
                },
                menu: Boolean,
                name: String,
                roomname: String,
                deviceid: 0,
                groupid: 0,
                sceneid: 0,
                roomid: 0,
                deviceimage: String,
                imagesource: {
                    type: String,
                    notify: true,
                },
            },
            onHovered: function () {
                this.$.card.elevation = 4
            },
            onUnhovered: function () {
                this.$.card.elevation = 1
            },
            btnClick: function () {
                var button = $("#1");
                var deviceImage = $("#deviceImage");
                if (button.hasClass("on")) {
                    this.imagesource = "off";
                    button.addClass("off");
                    button.removeClass("on");
                    button.addClass("btn-success");
                    button.removeClass("btn-danger");
                    this.deviceimage = "../../images/licht_off.png";
                } else if (button.hasClass("off")) {
                    this.imagesource = "on";
                    button.addClass("on");
                    button.removeClass("off");
                    //button.setAttribute("state","on");
                    button.addClass("btn-danger");
                    button.removeClass("btn-success");
                    this.deviceimage = "../../images/licht.png";
                }
            },
            ready: function () {
                if (typeof this.deviceimage === "undefined") {
                    this.deviceimage = "../../images/licht_off.png";
                }
                if (typeof this.deviceid === "undefined") {
                    this.deviceid = 0;
                }
                if (typeof this.groupid === "undefined") {
                    this.groupid = 0;
                }
                if (typeof this.sceneid === "undefined") {
                    this.sceneid = 0;
                }
                if (typeof this.roomname === "undefined") {
                    this.$.roomname.style.display = "none";
                    this.$.name.style.marginBottom = "16px";
                }
                if (typeof this.menu === "undefined") {
                    this.$.menuButton.style.display = "none";
                }
            },
            menuClassName: function (deviceid, groupid, sceneid) {
                if (deviceid != 0) {
                    return 'deviceMenu' + deviceid;
                } else if (groupid != 0) {
                    return 'groupMenu' + groupid;
                } else if (sceneid != 0) {
                    return 'sceneMenu' + sceneid;
                } else {
                    return "menu";
                }
            },
        });
    </script>
</dom-module><dom-module id="everhome-house" assetpath="everhome-house/">
    <style is="custom-style">
        #rollladen_kueche_2_2, #rollladen_kueche_2_1 {
            width: 37px;
            transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -webkit-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -moz-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
        }

        #rollladen_kueche_2_2.active, #rollladen_kueche_2_1.active {
            width: 37px;
            height: 77px;
        }

        #lichtkegel_wohnzimmer_1_1.active, #lichtkegel_flur_1_1.active, #lichtkegel_arbeitszimmer_1_1.active, #lichtkegel_kueche_1_1.active, #lichtkegel_kinderzimmer_1_1.active, #lichtkegel_garage_1_1.active{
            opacity: 0.2;
        }

        #lichtkegel_wohnzimmer_1_1, #lichtkegel_flur_1_1, #lichtkegel_arbeitszimmer_1_1, #lichtkegel_kueche_1_1, #lichtkegel_kinderzimmer_1_1, #lichtkegel_garage_1_1 {
            transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -webkit-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -moz-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            opacity: 0;
        }

        #lampe_wohnzimmer_1_1, #lampe_flur_1_1, #lampe_arbeitszimmer_1_1_1_, #lampe_kueche_1_1, #lampe_kinderzimmer_1_1, #lampe_garage_1_1  {
            transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -webkit-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -moz-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            fill: #DBDBDB;
        }

        #lampe_wohnzimmer_1_1.active, #lampe_flur_1_1.active, #lampe_arbeitszimmer_1_1_1_.active, #lampe_kueche_1_1.active, #lampe_kinderzimmer_1_1.active {
            fill: #ffb400;
        }

		#lampe_garage_1_1.active{
			fill:#fffcde;
		}

        #schatten_wohnzimmer_1_, #schatten_flur, #schatten_arbeitszimmer, #schatten_kueche, #schatten_kinderzimmer, #schatten_garage {
            transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -webkit-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            -moz-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
            opacity: 0.25;
        }

        #garagentor {
            transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1);
        }

        #garagentor.active {
            y: -535.5px;
            transform: rotate(90deg);
            x: 417px;
        }

        #schatten_wohnzimmer_1_.active, #schatten_flur.active, #schatten_arbeitszimmer.active, #schatten_kueche.active, #schatten_kinderzimmer.active, #schatten_garage.active {
            opacity: 0;
        }

		#markise_garten_1 > *{
			transition: all 4000ms cubic-bezier(0.175, 0.885, 0.320, 1);
			-webkit-transition: all 4000ms cubic-bezier(0.175, 0.885, 0.320, 1);
			-moz-transition: all 4000ms cubic-bezier(0.175, 0.885, 0.320, 1);
		}

		#markise_garten_1.active > #markise_garten_1_1{
			/*x: 593.5;
			y: 439.7;*/
			x: 925.5;
			y: 410.7;
		}
		#markise_garten_1.active > #markise_garten_1_2{
			/*x: 594.1;
			y: 442.6;*/
			x: 594.1;
			y: 413.6;
		}
		#markise_garten_1.active > #markise_garten_1_3{
		  x: 592;
		}
    </style>
    <template>
        <div class="layout vertical">
            <div>
                <paper-button raised="" on-click="wohnzimmer_ein">Ein</paper-button>
                <paper-button raised="" on-click="wohnzimmer_aus">Aus</paper-button>
            </div>
            <div>
                <paper-button raised="" on-click="flur_ein">Ein</paper-button>
                <paper-button raised="" on-click="flur_aus">Aus</paper-button>
            </div>
            <div>
                <paper-button raised="" on-click="arbeitszimmer_ein">Ein</paper-button>
                <paper-button raised="" on-click="arbeitszimmer_aus">Aus</paper-button>
            </div>
            <div>
                <paper-button raised="" on-click="kueche_ein">Ein</paper-button>
                <paper-button raised="" on-click="kueche_aus">Aus</paper-button>
            </div>
            <div>
                <paper-button raised="" on-click="kinderzimmer_ein">Ein</paper-button>
                <paper-button raised="" on-click="kinderzimmer_aus">Aus</paper-button>
            </div>
			<div>
				<paper-button raised="" on-click="markise_raus">Raus</paper-button>
				<paper-button raised="" on-click="markise_rein">Rein</paper-button>
			</div>
			<div>
				<paper-button raised="" on-click="garage_ein">Ein</paper-button>
				<paper-button raised="" on-click="garage_aus">Aus</paper-button>
			</div>
        </div>
        <div id="container">
			<img src="everhome-house/house.svg">
		</div>
    </template>
    <script>
        Polymer({
            is: "everhome-house",
            wohnzimmer_ein: function () {
                $("#lichtkegel_wohnzimmer_1_1").attr("class", "style-scope everhome-house active");
                $("#lampe_wohnzimmer_1_1").attr("class", "style-scope everhome-house active");
                $("#schatten_wohnzimmer_1_").attr("class", "style-scope everhome-house active");
            },
            wohnzimmer_aus: function () {
                $("#lichtkegel_wohnzimmer_1_1").attr("class", "style-scope everhome-house");
                $("#lampe_wohnzimmer_1_1").attr("class", "style-scope everhome-house");
                $("#schatten_wohnzimmer_1_").attr("class", "style-scope everhome-house");
            }, flur_ein: function () {
                $("#lichtkegel_flur_1_1").attr("class", "style-scope everhome-house active");
                $("#lampe_flur_1_1").attr("class", "style-scope everhome-house active");
                $("#schatten_flur").attr("class", "style-scope everhome-house active");
            },
            flur_aus: function () {
                $("#lichtkegel_flur_1_1").attr("class", "style-scope everhome-house");
                $("#lampe_flur_1_1").attr("class", "style-scope everhome-house");
                $("#schatten_flur").attr("class", "style-scope everhome-house");
            }, arbeitszimmer_ein: function () {
                $("#lichtkegel_arbeitszimmer_1_1").attr("class", "style-scope everhome-house active");
                $("#lampe_arbeitszimmer_1_1_1_").attr("class", "style-scope everhome-house active");
                $("#schatten_arbeitszimmer").attr("class", "style-scope everhome-house active");
            },
            arbeitszimmer_aus: function () {
                $("#lichtkegel_arbeitszimmer_1_1").attr("class", "style-scope everhome-house");
                $("#lampe_arbeitszimmer_1_1_1_").attr("class", "style-scope everhome-house");
                $("#schatten_arbeitszimmer").attr("class", "style-scope everhome-house");
            },
            kueche_ein: function () {
                $("#lichtkegel_kueche_1_1").attr("class", "style-scope everhome-house active");
                $("#lampe_kueche_1_1").attr("class", "style-scope everhome-house active");
                $("#schatten_kueche").attr("class", "style-scope everhome-house active");
            },
            kueche_aus: function () {
                $("#lichtkegel_kueche_1_1").attr("class", "style-scope everhome-house");
                $("#lampe_kueche_1_1").attr("class", "style-scope everhome-house");
                $("#schatten_kueche").attr("class", "style-scope everhome-house");
            },
            kinderzimmer_ein: function () {
                $("#lichtkegel_kinderzimmer_1_1").attr("class", "style-scope everhome-house active");
                $("#lampe_kinderzimmer_1_1").attr("class", "style-scope everhome-house active");
                $("#schatten_kinderzimmer").attr("class", "style-scope everhome-house active");
            },
            kinderzimmer_aus: function () {
                $("#lichtkegel_kinderzimmer_1_1").attr("class", "style-scope everhome-house");
                $("#lampe_kinderzimmer_1_1").attr("class", "style-scope everhome-house");
                $("#schatten_kinderzimmer").attr("class", "style-scope everhome-house");
            },
			garage_ein: function () {
				$("#lichtkegel_garage_1_1").attr("class", "style-scope everhome-house active");
				$("#lampe_garage_1_1").attr("class", "style-scope everhome-house active");
				$("#schatten_garage").attr("class", "style-scope everhome-house active");
			},
			garage_aus: function () {
				$("#lichtkegel_garage_1_1").attr("class", "style-scope everhome-house");
				$("#lampe_garage_1_1").attr("class", "style-scope everhome-house");
				$("#schatten_garage").attr("class", "style-scope everhome-house");
			},
			markise_rein: function () {
				$("#markise_garten_1").attr("class", "style-scope everhome-house");
			},
			markise_raus: function () {
				$("#markise_garten_1").attr("class", "style-scope everhome-house active");
			},
			ready : function(){
				/*var svg = $("#container").svg();
				console.log(svg);
                $('#svgintro').svg({onLoad: drawIntro});
                function drawIntro(svg) {
                    console.log("load");
                    svg.circle(75, 75, 50,
                            {fill: 'none', stroke: 'red', strokeWidth: 3});
                    var g = svg.group({stroke: 'black', strokeWidth: 2});
                    svg.line(g, 15, 75, 135, 75);
                    svg.line(g, 75, 15, 75, 135);
                }*/
				/*$("#cloudbox_kreis", svg.root()).bind('mouseenter', function() {
					alert('path hovered');
				});*/
			}
        });
    </script>
</dom-module>
</div></body></html>
